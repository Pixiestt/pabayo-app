<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use App\Models\Request as RequestModel;
use App\Models\Payment;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

use Pusher\PushNotifications\PushNotifications;

class RequestController extends Controller
{
    /**
     * Map internal status IDs to friendly labels.
     */
    private function friendlyStatusLabel($statusId): string
    {
        $map = [
            // Canonical mapping aligned with Android client
            1  => 'Subject for approval',
            2  => 'Delivery boy pickup',
            3  => 'Waiting for customer drop off',
            4  => 'Pending',
            5  => 'Processing',
            6  => 'Rider out for delivery',
            7  => 'Waiting for customer to claim',
            8  => 'Completed',
            9  => 'Rejected',
            10 => 'Request Accepted',
            11 => 'Partially Accepted',
            12 => 'Milling done',
            13 => 'Delivered',
        ];
        return $map[$statusId] ?? ('Status #' . $statusId);
    }

    /**
     * Normalize an incoming pickup time string to HH:MM (24h) when possible.
     */
    private function normalizePickupTime(?string $time): ?string
    {
        if (!$time) { return null; }
        try {
            return \Carbon\Carbon::parse($time)->format('H:i');
        } catch (\Throwable $e) {
            // Fallbacks for common formats
            $candidates = ['H:i', 'H:i:s', 'g:i A', 'g:i a', 'h:i A', 'h:i a'];
            foreach ($candidates as $fmt) {
                try {
                    return \Carbon\Carbon::createFromFormat($fmt, $time)->format('H:i');
                } catch (\Throwable $e2) {
                    // continue
                }
            }
            // As a final fallback, accept already-looking HH:MM
            if (preg_match('/^\\d{1,2}:\\d{2}(?::\\d{2})?$/', $time)) {
                try {
                    return \Carbon\Carbon::createFromFormat('H:i', substr($time, 0, 5))->format('H:i');
                } catch (\Throwable $e3) {
                    return null;
                }
            }
            return null;
        }
    }

    /** Determine if Beams pushes are allowed (credentials + feature flag). */
    private function canSendBeams(): bool
    {
        $enabled    = filter_var(env('PUSHER_BEAMS_ENABLED', false), FILTER_VALIDATE_BOOLEAN);
        $instanceId = env('PUSHER_BEAMS_INSTANCE_ID');
        $secretKey  = env('PUSHER_BEAMS_SECRET_KEY');
        return $enabled && !empty($instanceId) && !empty($secretKey);
    }

    /**
     * Centralized helper to send a Beams push notification to a specific user (customer)
     * for any request status-related change.
     */
    private function pushStatusNotification(?RequestModel $requestModel, array $payload): void
    {
        if (!$requestModel) { return; }

        if (!$this->canSendBeams()) {
            Log::info('Beams disabled or credentials missing; skipping push.');
            return;
        }

        // Safeguard: ensure we have customerID
        $customerId = $requestModel->customerID ?? null;
        if (!$customerId) { return; }

        try {
            $beams = new PushNotifications([
                'instanceId' => env('PUSHER_BEAMS_INSTANCE_ID'),
                'secretKey'  => env('PUSHER_BEAMS_SECRET_KEY'),
            ]);

            $interest = 'user_' . (string)$customerId;

            // Default notification fields
            $title = $payload['title'] ?? 'Request Update';
            $body  = $payload['body']  ?? 'Status for your request has changed.';
            $data  = $payload['data']  ?? [];

            // Always include core identifiers
            $data = array_merge([
                'type'       => 'request_status_update',
                'request_id' => $requestModel->requestID,
                'status_id'  => $requestModel->statusID,
            ], $data);

            $beams->publishToInterests([$interest], [
                'fcm' => [
                    'notification' => [
                        'title' => $title,
                        'body'  => $body,
                    ],
                    'data' => $data,
                ],
            ]);
            Log::info("‚úÖ Beams push sent to {$interest} for request {$requestModel->requestID} (status {$requestModel->statusID}).");
        } catch (\Throwable $e) {
            Log::error('‚ùå Beams push failed: ' . $e->getMessage());
        }
    }

    public function store(Request $request)
    {
        Log::info('‚û°Ô∏è Reached store() method');
        Log::info('üìù Incoming payload:', $request->all());

        try {
            $validated = $request->validate([
                'ownerID'       => 'required|exists:users_tbl,userID',
                'customerID'    => 'required|exists:users_tbl,userID',
                'serviceID'     => 'required|exists:services_tbl,serviceID',
                'statusID'      => 'required|exists:status_tbl,statusID',
                'pickupDate'    => 'nullable|string',
                'pickupTime'    => 'nullable|string',
                'deliveryDate'  => 'nullable|string',
                'sackQuantity'  => 'nullable|integer',
                'comment'       => 'nullable|string|max:300',
                'modeID'        => 'required|exists:paymentmethods_tbl,modeID',
                'pickupLocation' => 'nullable|string|max:255',
                'deliveryLocation' => 'nullable|string|max:255',
            ]);

            // Parse dates if provided
            if (!empty($validated['pickupDate'])) {
                $validated['pickupDate'] = \Carbon\Carbon::parse($validated['pickupDate'])->format('Y-m-d');
            }

            if (!empty($validated['deliveryDate'])) {
                $validated['deliveryDate'] = \Carbon\Carbon::createFromFormat('m/d/Y', $validated['deliveryDate'])->format('Y-m-d');
            }

            // Normalize pickupTime if provided
            $normalizedPickupTime = $this->normalizePickupTime($request->input('pickupTime'));

            $validated['courierID'] = 1;

            Log::info('üß™ Final payload to insert:', $validated);

            // Create the request (remove modeID from $validated before saving)
            $modeID = $validated['modeID'];
            unset($validated['modeID']);
            $newRequest = RequestModel::create($validated);
            $newRequest->pickupLocation = $request->input('pickupLocation');
            $newRequest->deliveryLocation = $request->input('deliveryLocation');
            $newRequest->pickupTime = $normalizedPickupTime; // NEW: save pickup time
            $newRequest->save();

            // Always create a payment
            $payment = \App\Models\Payment::create([
                'requestID' => $newRequest->requestID,
                'modeID' => $modeID,
                'paymentStatusID' => 1, // e.g., "Pending"
                'paymentDate' => now(),
                'userID' => $validated['customerID'],
                'amount' => 0,
            ]);

            // Reload with relationships for response
            $newRequest = RequestModel::with(['customer', 'service', 'payment.method'])->find($newRequest->requestID);

            $firstName = $newRequest->customer->firstName ?? '';
            $lastName = $newRequest->customer->lastName ?? '';
            $fullName = trim("$firstName $lastName");

            $serviceName = $newRequest->service->serviceName ?? 'Unknown';
            if ($newRequest->serviceID == 1) {
                $serviceName = 'All Services';
            }

            $paymentName = $newRequest->payment->method->modeName ?? 'Unspecified';
            if ($newRequest->payment && $newRequest->payment->modeID == 1) {
                $paymentName = 'Cash on Delivery';
            } elseif ($newRequest->payment && $newRequest->payment->modeID == 2) {
                $paymentName = 'Gcash';
            }


            // Send notification to the Owner about the new request using Pusher Beams
            // Ensure ownerID is a string for Beams
            $ownerId = $newRequest->ownerID;
            $ownerUserIdString = (string)$ownerId;
            $customerName = $fullName;

            // Initialize Pusher Beams Client (only if enabled and configured)
            if ($this->canSendBeams()) {
                try {
                    $beamsClient = new PushNotifications([
                        'instanceId' => env('PUSHER_BEAMS_INSTANCE_ID'),
                        'secretKey' => env('PUSHER_BEAMS_SECRET_KEY'),
                    ]);

                    // Publish to the interest that the Android app subscribes to: "user_{userID}"
                    $interestName = "user_{$ownerUserIdString}";
                    $beamsClient->publishToInterests(
                        [$interestName],
                        [
                            'fcm' => [
                                'notification' => [
                                    'title' => "New Request from $customerName",
                                    'body'  => "A new request (ID: {$newRequest->requestID}) is awaiting your approval.",
                                ],
                                'data' => [
                                    'type' => 'new_request',
                                    'request_id' => $newRequest->requestID,
                                ]
                            ],
                        ]
                    );
                    Log::info("‚úÖ Pusher Beams: Published to interest $interestName for new request {$newRequest->requestID}.");
                } catch (\Throwable $e) {
                    Log::error('‚ùå Pusher Beams Publish Error (New Request): ' . $e->getMessage());
                }
            } else {
                Log::info('‚ÑπÔ∏è Skipping Beams publish in store(): disabled or not configured.');
            }

            $formatted = [
                'requestID'       => $newRequest->requestID ?? 0,
                'ownerID'         => $newRequest->ownerID ?? 0,
                'customerID'      => $newRequest->customerID ?? 0,
                'customerName'    => $fullName ?: '',
                'serviceID'       => $newRequest->serviceID ?? 0,
                'serviceName'     => $serviceName ?: '',
                'courierID'       => $newRequest->courierID ?? 0,
                'statusID'        => $newRequest->statusID ?? 0,
                'pickupDate'      => $newRequest->pickupDate ?? '',
                'pickupTime'      => $newRequest->pickupTime ?? null, // NEW
                'paymentMethod'   => $paymentName ?: '',
                'paymentAmount'   => ($newRequest->payment ? $newRequest->payment->amount : null), // NEW
                'deliveryDate'    => $newRequest->deliveryDate ?? '',
                'sackQuantity'    => $newRequest->sackQuantity ?? 0,
                'comment'         => $newRequest->comment ?? '',
                'dateUpdated'     => $newRequest->dateUpdated ?? '',
                'schedule'        => $newRequest->pickupDate ?? '',
                'submittedAt'     => $newRequest->dateCreated ?? ($newRequest->created_at ? $newRequest->created_at->toDateString() : ''),
                'pickupLocation'  => $newRequest->pickupLocation ?? '',  // Add this line
                'deliveryLocation' => $newRequest->deliveryLocation ?? '', // Add this line
            ];

            return response()->json([
                'message' => 'Request created successfully',
                'data' => $formatted
            ], 201);
        } catch (\Throwable $e) {
            Log::error('Request creation failed: ' . $e->getMessage());
            Log::error('Trace: ' . $e->getTraceAsString());
            return response()->json([
                'error' => 'Failed to create request',
                'details' => $e->getMessage(),
            ], 500);
        }
    }



    // eto yung pinaste ko about sa edit



    /**
     * Update an existing request (editable only when statusID == 1 "Subject for approval")
     * PUT /api/requests/{id}
     */
    public function update(Request $request, $id)
    {
        Log::info('‚û°Ô∏è Reached update() method for requestID: ' . $id);
        Log::info('üìù Incoming payload for update:', $request->all());

        try {
            // Validate incoming data (similar to store)
            $validated = $request->validate([
                'ownerID'        => 'required|exists:users_tbl,userID',
                'customerID'     => 'required|exists:users_tbl,userID',
                'serviceID'      => 'required|exists:services_tbl,serviceID',
                'statusID'       => 'required|exists:status_tbl,statusID',
                'courierID'      => 'nullable|integer',
                'pickupDate'     => 'nullable|string',
                'pickupTime'     => 'nullable|string',
                'deliveryDate'   => 'nullable|string',
                'sackQuantity'   => 'nullable|integer',
                'comment'        => 'nullable|string|max:300',
                'modeID'         => 'nullable|exists:paymentmethods_tbl,modeID',
                'pickupLocation' => 'nullable|string|max:255',
                'deliveryLocation' => 'nullable|string|max:255',
            ]);

            // Find existing request
            $requestModel = RequestModel::find($id);
            if (!$requestModel) {
                Log::warning('Request not found: ' . $id);
                return response()->json(['message' => 'Request not found'], 404);
            }

            // Only allow editing if status is subject-for-approval (1)
            if ((int)$requestModel->statusID !== 1) {
                Log::warning('Attempt to edit non-editable requestID=' . $id . ' status=' . $requestModel->statusID);
                return response()->json(['message' => 'Request can no longer be edited'], 409);
            }

            // Ensure authenticated user is the request owner/customer
            $user = $request->user();
            if ($user && isset($user->userID) && (int)$user->userID !== (int)$requestModel->customerID) {
                Log::warning('Forbidden update attempt by user ' . ($user->userID ?? 'unknown') . ' on request ' . $id);
                return response()->json(['message' => 'Forbidden'], 403);
            }

            // Parse dates if provided (normalize to Y-m-d)
            if (!empty($validated['pickupDate'])) {
                $validated['pickupDate'] = \Carbon\Carbon::parse($validated['pickupDate'])->format('Y-m-d');
            }
            if (!empty($validated['deliveryDate'])) {
                try {
                    $validated['deliveryDate'] = \Carbon\Carbon::parse($validated['deliveryDate'])->format('Y-m-d');
                } catch (\Exception $ex) {
                    $validated['deliveryDate'] = \Carbon\Carbon::createFromFormat('m/d/Y', $validated['deliveryDate'])->format('Y-m-d');
                }
            }

            // Normalize pickup time (if any)
            $normalizedPickupTime = $this->normalizePickupTime($request->input('pickupTime'));

            // Update allowed fields
            $requestModel->ownerID = $validated['ownerID'] ?? $requestModel->ownerID;
            $requestModel->serviceID = $validated['serviceID'] ?? $requestModel->serviceID;
            $requestModel->courierID = $validated['courierID'] ?? ($requestModel->courierID ?? 1);
            $requestModel->statusID = $validated['statusID'] ?? $requestModel->statusID;
            $requestModel->pickupDate = array_key_exists('pickupDate', $validated) ? $validated['pickupDate'] : $requestModel->pickupDate;
            $requestModel->pickupTime = $normalizedPickupTime !== null ? $normalizedPickupTime : $requestModel->pickupTime; // NEW
            $requestModel->deliveryDate = array_key_exists('deliveryDate', $validated) ? $validated['deliveryDate'] : $requestModel->deliveryDate;
            $requestModel->sackQuantity = $validated['sackQuantity'] ?? $requestModel->sackQuantity;
            $requestModel->comment = $validated['comment'] ?? $requestModel->comment;
            $requestModel->pickupLocation = $validated['pickupLocation'] ?? $requestModel->pickupLocation;
            $requestModel->deliveryLocation = $validated['deliveryLocation'] ?? $requestModel->deliveryLocation;
            $requestModel->dateUpdated = now();

            $requestModel->save();

            // If modeID provided, update payment method for the existing payment record (optional)
            if (!empty($validated['modeID'])) {
                $payment = \App\Models\Payment::where('requestID', $requestModel->requestID)->first();
                if ($payment) {
                    $payment->modeID = $validated['modeID'];
                    $payment->save();
                }
            }

            // Reload with relationships
            $requestModel = RequestModel::with(['customer', 'service', 'payment.method'])->find($requestModel->requestID);

            $firstName = $requestModel->customer->firstName ?? '';
            $lastName  = $requestModel->customer->lastName ?? '';
            $fullName  = trim("$firstName $lastName");

            $serviceName = $requestModel->service->serviceName ?? 'Unknown';
            if ($requestModel->serviceID == 1) {
                $serviceName = 'All Services';
            }

            $paymentName = $requestModel->payment->method->modeName ?? 'Unspecified';
            if ($requestModel->payment && $requestModel->payment->modeID == 1) {
                $paymentName = 'Cash on Delivery';
            } elseif ($requestModel->payment && $requestModel->payment->modeID == 2) {
                $paymentName = 'Gcash';
            }

            $formatted = [
                'requestID'        => $requestModel->requestID ?? 0,
                'ownerID'          => $requestModel->ownerID ?? 0,
                'customerID'       => $requestModel->customerID ?? 0,
                'customerName'     => $fullName ?: '',
                'serviceID'        => $requestModel->serviceID ?? 0,
                'serviceName'      => $serviceName ?: '',
                'courierID'        => $requestModel->courierID ?? 0,
                'statusID'         => $requestModel->statusID ?? 0,
                'pickupDate'       => $requestModel->pickupDate ?? '',
                'pickupTime'       => $requestModel->pickupTime ?? null, // NEW
                'paymentMethod'    => $paymentName ?: '',
                'paymentAmount'    => ($requestModel->payment ? $requestModel->payment->amount : null), // NEW
                'deliveryDate'     => $requestModel->deliveryDate ?? '',
                'sackQuantity'     => $requestModel->sackQuantity ?? 0,
                'comment'          => $requestModel->comment ?? '',
                'dateUpdated'      => $requestModel->dateUpdated ?? '',
                'schedule'         => $requestModel->pickupDate ?? '',
                'submittedAt'      => $requestModel->dateCreated ?? ($requestModel->created_at ? $requestModel->created_at->toDateString() : ''),
                'pickupLocation'   => $requestModel->pickupLocation ?? '',
                'deliveryLocation' => $requestModel->deliveryLocation ?? '',
                // Optional fields - include if present on model
                'feedsConversion'  => $requestModel->feedsConversion ?? false,
                'millingType'      => $requestModel->millingType ?? null,
            ];

            return response()->json([
                'message' => 'Request updated successfully',
                'data' => $formatted
            ], 200);
        } catch (\Throwable $e) {
            Log::error('Request update failed for id ' . $id . ': ' . $e->getMessage());
            Log::error('Trace: ' . $e->getTraceAsString());
            return response()->json([
                'error' => 'Failed to update request',
                'details' => $e->getMessage(),
            ], 500);
        }
    }




    // hanggang dito yung pasted


    public function index(Request $request)
    {
        $ownerID = $request->user()->userID;

        $requests = RequestModel::with(['customer', 'service', 'payment.method'])
            ->where('ownerID', $ownerID)
            ->get();

        foreach ($requests as $req) {
            Log::info('Customer:', $req->customer ? $req->customer->toArray() : 'null');
            Log::info('Service:', $req->service ? $req->service->toArray() : 'null');
        }

        $formatted = $requests->map(function ($req) {
            $firstName = $req->customer->firstName ?? '';
            $lastName = $req->customer->lastName ?? '';
            $fullName = trim("$firstName $lastName");

            $serviceName = $req->service->serviceName ?? 'Unknown';
            if ($req->serviceID == 1) {
                $serviceName = 'All Services';
            }

            $paymentName = $req->payment->method->modeName ?? 'Unspecified';
            if ($req->payment && $req->payment->modeID == 1) {
                $paymentName = 'Cash on Delivery';
            } elseif ($req->payment && $req->payment->modeID == 2) {
                $paymentName = 'Gcash';
            }

            return [
                'requestID'       => $req->requestID,
                'customerName'    => $fullName ?: 'Unknown',
                'sackQuantity'    => $req->sackQuantity,
                'serviceName'     => $serviceName,
                'schedule'        => $req->pickupDate ?? 'Not set',
                'pickupTime'      => $req->pickupTime ?? null, // NEW
                'paymentMethod'   => $paymentName,
                'paymentAmount'   => ($req->payment ? $req->payment->amount : null), // NEW
                'comment'         => $req->comment,
                'submittedAt'     => $req->dateCreated ?? $req->created_at?->toDateString(),
            ];
        });

        return response()->json(['requests' => $formatted]);
    }

    public function ownerRequests(Request $request)
    {
        $user = $request->user();

        $requests = RequestModel::with(['customer', 'service', 'payment.method'])
            ->whereHas('service', function ($query) use ($user) {
                $query->where('ownerID', $user->userID);
            })->get();

        // Format the response to include customerName and other fields
        $formatted = $requests->map(function ($req) {
            $firstName = $req->customer->firstName ?? '';
            $lastName = $req->customer->lastName ?? '';
            $fullName = trim("$firstName $lastName");

            $serviceName = $req->service->serviceName ?? 'Unknown';
            if ($req->serviceID == 1) {
                $serviceName = 'All Services';
            }

            $paymentName = $req->payment->method->modeName ?? 'Unspecified';
            if ($req->payment && $req->payment->modeID == 1) {
                $paymentName = 'Cash on Delivery';
            } elseif ($req->payment && $req->payment->modeID == 2) {
                $paymentName = 'Gcash';
            }

            return [
                'requestID'       => $req->requestID,
                'ownerID'         => $req->ownerID,
                'customerID'      => $req->customerID,
                'customerName'    => $fullName ?: 'Unknown',
                'serviceID'       => $req->serviceID,
                'serviceName'     => $serviceName,
                'courierID'       => $req->courierID,
                'statusID'        => $req->statusID,
                'pickupDate'      => $req->pickupDate,
                'pickupTime'      => $req->pickupTime ?? null, // NEW
                'paymentMethod'   => $paymentName,
                'paymentAmount'   => ($req->payment ? $req->payment->amount : null), // NEW
                'deliveryDate'    => $req->deliveryDate,
                'sackQuantity'    => $req->sackQuantity,
                'comment'         => $req->comment,
                'dateUpdated'     => $req->dateUpdated,
                'schedule'        => $req->pickupDate ?? 'Not set',
                'submittedAt'     => $req->dateCreated ?? $req->created_at?->toDateString(),
                'pickupLocation'  => $req->pickupLocation ?? '',
                'deliveryLocation' => $req->deliveryLocation ?? '',
            ];
        });

        return response()->json([
            'requests' => $formatted
        ]);
    }

    public function accept($id)
    {
        $requestModel = RequestModel::with(['customer', 'service', 'payment.method'])->find($id);
        if (!$requestModel) {
            return response()->json(['message' => 'Request not found'], 404);
        }

        $requestModel->statusID = 10; // accepted
        $requestModel->dateUpdated = now();
        $requestModel->save();

        // Send notification (refactored)
        $this->pushStatusNotification($requestModel, [
            'title' => 'Request Accepted ‚úÖ',
            'body'  => 'Your service request (ID: ' . $requestModel->requestID . ') has been accepted.',
            'data'  => [ 'event' => 'accepted' ],
        ]);

        // ...existing formatting logic...
        $firstName = $requestModel->customer->firstName ?? '';
        $lastName = $requestModel->customer->lastName ?? '';
        $fullName = trim("$firstName $lastName");
        $serviceName = $requestModel->service->serviceName ?? 'Unknown';
        if ($requestModel->serviceID == 1) { $serviceName = 'All Services'; }
        $paymentName = $requestModel->payment->method->modeName ?? 'Unspecified';
        if ($requestModel->payment && $requestModel->payment->modeID == 1) { $paymentName = 'Cash on Delivery'; }
        elseif ($requestModel->payment && $requestModel->payment->modeID == 2) { $paymentName = 'Gcash'; }

        $formatted = [
            'requestID'       => $requestModel->requestID ?? 0,
            'ownerID'         => $requestModel->ownerID ?? 0,
            'customerID'      => $requestModel->customerID ?? 0,
            'customerName'    => $fullName ?: '',
            'serviceID'       => $requestModel->serviceID ?? 0,
            'serviceName'     => $serviceName ?: '',
            'courierID'       => $requestModel->courierID ?? 0,
            'statusID'        => $requestModel->statusID ?? 0,
            'pickupDate'      => $requestModel->pickupDate ?? '',
            'pickupTime'      => $requestModel->pickupTime ?? null, // NEW
            'paymentMethod'   => $paymentName ?: '',
            'paymentAmount'   => ($requestModel->payment ? $requestModel->payment->amount : null), // NEW
            'deliveryDate'    => $requestModel->deliveryDate ?? '',
            'sackQuantity'    => $requestModel->sackQuantity ?? 0,
            'comment'         => $requestModel->comment ?? '',
            'dateUpdated'     => $requestModel->dateUpdated ?? '',
            'schedule'        => $requestModel->pickupDate ?? '',
            'submittedAt'     => $requestModel->dateCreated ?? ($requestModel->created_at ? $requestModel->created_at->toDateString() : ''),
            'pickupLocation'  => $requestModel->pickupLocation ?? '',
            'deliveryLocation'=> $requestModel->deliveryLocation ?? '',
        ];

        return response()->json([
            'message' => 'Request accepted successfully',
            'data'    => $formatted,
        ]);
    }

    public function reject($id)
    {
        $requestModel = RequestModel::with(['customer'])->find($id);
        if (!$requestModel) {
            return response()->json(['message' => 'Request not found'], 404);
        }
        $requestModel->statusID = 9; // rejected
        $requestModel->dateUpdated = now();
        $requestModel->save();

        $this->pushStatusNotification($requestModel, [
            'title' => 'Request Rejected ‚ùå',
            'body'  => 'Your request (ID: ' . $requestModel->requestID . ') was rejected.',
            'data'  => [ 'event' => 'rejected' ],
        ]);

        return response()->json(['message' => 'Request rejected successfully'], 200);
    }

    public function updateRequestStatus($id, $status)
    {
        $requestModel = RequestModel::with(['customer', 'service', 'payment.method'])->find($id);
        if (!$requestModel) { return response()->json(['message' => 'Request not found'], 404); }

        $statusExists = \DB::table('status_tbl')->where('statusID', $status)->exists();
        if (!$statusExists) { return response()->json(['message' => 'Invalid statusID'], 422); }

        $requestModel->statusID = $status;
        $requestModel->dateUpdated = now();
        $requestModel->save();

        $friendly = $this->friendlyStatusLabel($status);
        $this->pushStatusNotification($requestModel, [
            'title' => 'Request Status: ' . $friendly,
            'body'  => 'Your request (ID: ' . $requestModel->requestID . ') is now: ' . $friendly . '.',
            'data'  => [ 'event' => 'status_generic_change' ],
        ]);

        // ...existing formatting logic...
        $firstName = $requestModel->customer->firstName ?? '';
        $lastName = $requestModel->customer->lastName ?? '';
        $fullName = trim("$firstName $lastName");
        $serviceName = $requestModel->service->serviceName ?? 'Unknown';
        if ($requestModel->serviceID == 1) { $serviceName = 'All Services'; }
        $paymentName = $requestModel->payment->method->modeName ?? 'Unspecified';
        if ($requestModel->payment && $requestModel->payment->modeID == 1) { $paymentName = 'Cash on Delivery'; }
        elseif ($requestModel->payment && $requestModel->payment->modeID == 2) { $paymentName = 'Gcash'; }

        $formatted = [
            'requestID'       => $requestModel->requestID ?? 0,
            'ownerID'         => $requestModel->ownerID ?? 0,
            'customerID'      => $requestModel->customerID ?? 0,
            'customerName'    => $fullName ?: '',
            'serviceID'       => $requestModel->serviceID ?? 0,
            'serviceName'     => $serviceName ?: '',
            'courierID'       => $requestModel->courierID ?? 0,
            'statusID'        => $requestModel->statusID ?? 0,
            'pickupDate'      => $requestModel->pickupDate ?? '',
            'pickupTime'      => $requestModel->pickupTime ?? null, // NEW
            'paymentMethod'   => $paymentName ?: '',
            'paymentAmount'   => ($requestModel->payment ? $requestModel->payment->amount : null), // NEW
            'deliveryDate'    => $requestModel->deliveryDate ?? '',
            'sackQuantity'    => $requestModel->sackQuantity ?? 0,
            'comment'         => $requestModel->comment ?? '',
            'dateUpdated'     => $requestModel->dateUpdated ?? '',
            'schedule'        => $requestModel->pickupDate ?? '',
            'submittedAt'     => $requestModel->dateCreated ?? ($requestModel->created_at ? $requestModel->created_at->toDateString() : ''),
            'pickupLocation'  => $requestModel->pickupLocation ?? '',
            'deliveryLocation' => $requestModel->deliveryLocation ?? '',
        ];

        return response()->json([
            'message' => 'Status updated successfully',
            'data'    => $formatted,
        ]);
    }

    public function getCustomerRequests($customerID)
    {
        try {
            $requests = \App\Models\Request::with(['customer', 'service', 'payment.method'])
                ->where('customerID', $customerID)
                ->orderBy('dateCreated', 'desc')
                ->get();

            // Log for debugging
            \Log::info("Fetching requests for customer ID: $customerID, found: " . $requests->count());

            $formatted = $requests->map(function ($req) {
                $firstName = $req->customer->firstName ?? '';
                $lastName = $req->customer->lastName ?? '';
                $fullName = trim("$firstName $lastName");

                $serviceName = $req->service->serviceName ?? 'Unknown';
                if ($req->serviceID == 1) {
                    $serviceName = 'All Services';
                }

                $paymentName = $req->payment->method->modeName ?? 'Unspecified';
                if ($req->payment && $req->payment->modeID == 1) {
                    $paymentName = 'Cash on Delivery';
                } elseif ($req->payment && $req->payment->modeID == 2) {
                    $paymentName = 'Gcash';
                }

                return [
                    'requestID' => $req->requestID,
                    'ownerID' => $req->ownerID,
                    'customerID' => $req->customerID,
                    'customerName' => $fullName ?: 'Unknown',
                    'serviceID' => $req->serviceID,
                    'serviceName' => $serviceName,
                    'courierID' => $req->courierID,
                    'statusID' => $req->statusID,
                    'pickupDate' => $req->pickupDate,
                    'pickupTime' => $req->pickupTime ?? null, // NEW
                    'paymentMethod' => $paymentName,
                    'paymentAmount' => ($req->payment ? $req->payment->amount : null), // NEW
                    'deliveryDate' => $req->deliveryDate,
                    'sackQuantity' => $req->sackQuantity,
                    'comment' => $req->comment,
                    'dateUpdated' => $req->dateUpdated,
                    'schedule' => $req->pickupDate ?? 'Not set',
                    'submittedAt' => $req->dateCreated ?? $req->created_at?->toDateString(),
                    'pickupLocation' => $req->pickupLocation,  // Add this line
                    'deliveryLocation' => $req->deliveryLocation,  // Add this line
                ];
            });

            // Return the formatted requests directly as the expected array
            return response()->json($formatted);
        } catch (\Exception $e) {
            \Log::error("Error fetching customer requests: " . $e->getMessage());
            return response()->json([], 500);
        }
    }


    public function getDeliveryBoyRequests()
    {
        $requests = RequestModel::with(['customer', 'service', 'payment.method'])
            ->where(function ($query) {
                // Include these statuses globally
                $query->whereIn('statusID', [10, 2, 6]);

                // Include status 12 (Milling Done) only for services that need delivery
                $query->orWhere(function ($q) {
                    $q->where('statusID', 12)
                        ->whereIn('serviceID', [1, 3, 5]); // delivery-related services only
                });
            })
            ->get();

        $formatted = $requests->map(function ($req) {
            $firstName = $req->customer->firstName ?? '';
            $lastName = $req->customer->lastName ?? '';
            $fullName = trim("$firstName $lastName");

            $serviceName = $req->service->serviceName ?? 'Unknown';
            if ($req->serviceID == 1) {
                $serviceName = 'All Services';
            }

            $paymentName = $req->payment->method->modeName ?? 'Unspecified';
            if ($req->payment && $req->payment->modeID == 1) {
                $paymentName = 'Cash on Delivery';
            } elseif ($req->payment && $req->payment->modeID == 2) {
                $paymentName = 'Gcash';
            }

            return [
                'requestID'        => $req->requestID,
                'ownerID'          => $req->ownerID,
                'customerID'       => $req->customerID,
                'customerName'     => $fullName,
                'serviceID'        => $req->serviceID,
                'serviceName'      => $serviceName,
                'statusID'         => $req->statusID,
                'pickupDate'       => $req->pickupDate,
                'pickupTime'       => $req->pickupTime ?? null, // NEW
                'deliveryDate'     => $req->deliveryDate,
                'sackQuantity'     => $req->sackQuantity,
                'comment'          => $req->comment,
                'pickupLocation'   => $req->pickupLocation ?? '',
                'deliveryLocation' => $req->deliveryLocation ?? '',
                'paymentMethod'    => $paymentName,
                'paymentAmount'    => ($req->payment ? $req->payment->amount : null), // NEW
                'schedule'         => $req->pickupDate ?? 'Not set',
                'dateUpdated'      => $req->dateUpdated,
            ];
        });

        return response()->json([
            'requests' => $formatted
        ]);
    }


    public function markPickupDone($id, Request $request)
    {
        $user = $request->user();

        if ($user->roleID !== 4) { // assuming 4 = delivery boy
            return response()->json(['error' => 'Unauthorized'], 403);
        }

        $req = RequestModel::findOrFail($id);

        if (!in_array($req->statusID, [10, 2])) {
            return response()->json(['error' => 'Request is not available for pickup'], 400);
        }

        $req->statusID = 4;
        $req->dateUpdated = now();
        $req->save();

        $this->pushStatusNotification($req, [
            'title' => 'Pickup Completed üì¶',
            'body'  => 'Your request (ID: ' . $req->requestID . ') has been picked up.',
            'data'  => [ 'event' => 'pickup_completed' ],
        ]);

        return response()->json([
            'message' => 'Pickup completed successfully',
            'request' => $req
        ]);
    }


    public function initiatePickup($id, Request $request)
    {
        $req = RequestModel::findOrFail($id);

        // Allow initiate only if status is 10 (accepted)
        if ($req->statusID != 10) {
            return response()->json(['error' => 'Request is not available for initiation'], 400);
        }

        $req->statusID = 2; // Pickup in progress
        $req->dateUpdated = now();
        $req->save();

        $this->pushStatusNotification($req, [
            'title' => 'Pickup Started üöö',
            'body'  => 'Pickup for request (ID: ' . $req->requestID . ') is now in progress.',
            'data'  => [ 'event' => 'pickup_started' ],
        ]);

        return response()->json([
            'message'  => 'Pickup initiated successfully',
            'statusID' => $req->statusID,
        ]);
    }

    /**
     * Customer Queue endpoint: returns requests grouped by Pending and Processing for a customer.
     * GET /api/customer/{customerID}/requests/queue
     *
     * Contract:
     * - Inputs: customerID (path)
     * - Output: { pending: RequestDTO[], processing: RequestDTO[] }
     * - RequestDTO fields align with existing formatting and add friendlyStatus.
     */
    public function getCustomerRequestQueue($customerID): JsonResponse
    {
        try {
            // Use real DB statuses for buckets
            $pendingStatuses    = [1];              // Pending Approval
            $processingStatuses = [10, 2, 4, 6, 12]; // Accepted, Pickup In Progress, Pickup Completed, Out for Delivery, Milling Done

            $baseQuery = RequestModel::with(['customer', 'service', 'payment.method'])
                ->where('customerID', $customerID);

            $pending = (clone $baseQuery)
                ->whereIn('statusID', $pendingStatuses)
                ->orderByDesc('dateCreated')
                ->get();

            $processing = (clone $baseQuery)
                ->whereIn('statusID', $processingStatuses)
                ->orderByDesc('dateCreated')
                ->get();

            $mapFn = function ($req) {
                return [
                    'requestID'        => $req->requestID,
                    'ownerID'          => $req->ownerID,
                    'customerID'       => $req->customerID,
                    'customerName'     => trim(($req->customer->firstName ?? '') . ' ' . ($req->customer->lastName ?? '')) ?: 'Unknown',
                    'serviceID'        => $req->serviceID,
                    'serviceName'      => ($req->serviceID == 1) ? 'All Services' : ($req->service->serviceName ?? 'Unknown'),
                    'courierID'        => $req->courierID,
                    'statusID'         => $req->statusID, // preserve original
                    'friendlyStatus'   => $this->friendlyStatusLabel($req->statusID),
                    'pickupDate'       => $req->pickupDate,
                    'pickupTime'       => $req->pickupTime ?? null, // NEW
                    'deliveryDate'     => $req->deliveryDate,
                    'sackQuantity'     => $req->sackQuantity,
                    'comment'          => $req->comment,
                    'pickupLocation'   => $req->pickupLocation ?? '',
                    'deliveryLocation' => $req->deliveryLocation ?? '',
                    'paymentMethod'    => ($req->payment && $req->payment->modeID == 1) ? 'Cash on Delivery' : (($req->payment && $req->payment->modeID == 2) ? 'Gcash' : ($req->payment->method->modeName ?? 'Unspecified')),
                    'paymentAmount'    => ($req->payment ? $req->payment->amount : null), // NEW
                    'schedule'         => $req->pickupDate ?? 'Not set',
                    'dateUpdated'      => $req->dateUpdated,
                    'submittedAt'      => $req->dateCreated ?? ($req->created_at ? $req->created_at->toDateString() : null),
                ];
            };

            $pendingOut    = $pending->map($mapFn)->values();
            $processingOut = $processing->map($mapFn)->values();

            return response()->json([
                'pending'    => $pendingOut,
                'processing' => $processingOut,
            ]);
        } catch (\Throwable $e) {
            Log::error('Error building customer request queue: ' . $e->getMessage());
            return response()->json([
                'pending'    => [],
                'processing' => [],
                'error'      => 'Could not fetch queue',
            ], 500);
        }
    }

    public function setPaymentAmount($id, Request $request)
    {
        Log::info('‚û°Ô∏è setPaymentAmount() for requestID=' . $id);
        try {
            // 1) Validate
            $validated = $request->validate([
                'amount' => 'required|numeric|min:0|max:999999.99',
            ]);
            $amount = (float) $validated['amount'];

            // 2) Load request with relations
            $req = RequestModel::with(['service', 'payment'])->find($id);
            if (!$req) {
                Log::warning('setPaymentAmount: request not found: ' . $id);
                return response()->json(['message' => 'Request not found'], 404);
            }

            // 3) Authorization: only the owner may set amount
            $user = $request->user();
            $serviceOwnerId = optional($req->service)->ownerID ?? $req->ownerID;
            if ($user && isset($user->userID) && (int)$user->userID !== (int)$serviceOwnerId) {
                Log::warning('setPaymentAmount: forbidden by user ' . ($user->userID ?? 'unknown') . ' for request ' . $id);
                return response()->json(['message' => 'Forbidden'], 403);
            }

            // 4) Ensure payment row exists
            $payment = Payment::where('requestID', $req->requestID)->first();
            if (!$payment) {
                Log::info('setPaymentAmount: creating missing payment row for requestID=' . $req->requestID);
                $existing = Payment::where('requestID', $req->requestID)->first();
                $defaultModeId = $existing ? $existing->modeID : 1; // 1 = COD by your convention
                $defaultStatus = $existing ? $existing->paymentStatusID : 1; // 1 = Pending
                $payment = Payment::create([
                    'requestID'       => $req->requestID,
                    'modeID'          => $defaultModeId,
                    'paymentStatusID' => $defaultStatus,
                    'paymentDate'     => now(),
                    'userID'          => $req->customerID,
                    'amount'          => 0,
                ]);
            }

            // 5) Update amount/date
            $payment->amount = $amount;
            $payment->paymentDate = now();
            $payment->save();

            // 6) Optional push to customer
            try {
                $this->pushStatusNotification($req, [
                    'title' => 'Payment Amount Set',
                    'body'  => 'Your milling fee has been set for request ID: ' . $req->requestID . '.',
                    'data'  => [
                        'event'  => 'payment_amount_set',
                        'amount' => (string)$payment->amount,
                    ],
                ]);
            } catch (\Throwable $e) {
                Log::warning('setPaymentAmount: push failed: ' . $e->getMessage());
            }

            return response()->json([
                'message' => 'Payment amount updated successfully',
                'data'    => [
                    'requestID' => $req->requestID,
                    'amount'    => $payment->amount,
                ],
            ], 200);
        } catch (\Illuminate\Validation\ValidationException $ve) {
            Log::warning('setPaymentAmount: validation failed', $ve->errors());
            return response()->json([
                'message' => 'Validation failed',
                'errors'  => $ve->errors(),
            ], 422);
        } catch (\Throwable $e) {
            Log::error('setPaymentAmount failed for requestID=' . $id . ': ' . $e->getMessage());
            Log::error('Trace: ' . $e->getTraceAsString());
            return response()->json([
                'message'   => 'Failed to update payment amount',
                'exception' => get_class($e),
                'error'     => $e->getMessage(),
            ], 500);
        }
    }
}
