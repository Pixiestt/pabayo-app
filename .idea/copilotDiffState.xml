<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/adapter/DeliveryCardAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/adapter/DeliveryCardAdapter.kt" />
              <option name="originalContent" value="package com.example.capstone2.adapter&#10;&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.RequestRepository&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;enum class DeliveryMode { PICKUPS, DELIVERIES }&#10;enum class DeliveryAction { INITIATE, DONE }&#10;&#10;class DeliveryCardAdapter(&#10;    private var items: MutableList&lt;Request&gt;,&#10;    private val mode: DeliveryMode,&#10;    private val onAction: (Request, DeliveryAction) -&gt; Unit,&#10;    private val requestRepository: RequestRepository&#10;) : RecyclerView.Adapter&lt;DeliveryCardAdapter.ViewHolder&gt;() {&#10;&#10;    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        val tvTitle: TextView = itemView.findViewById(R.id.tvTitle)&#10;        val tvSubtitle: TextView = itemView.findViewById(R.id.tvSubtitle)&#10;        val tvSacks: TextView = itemView.findViewById(R.id.tvSacks)&#10;        val tvStatusLabel: TextView = itemView.findViewById(R.id.tvStatusLabel)&#10;        val btnInitiate: Button = itemView.findViewById(R.id.btnInitiate)&#10;        val btnDone: Button = itemView.findViewById(R.id.btnDone)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_delivery_card, parent, false)&#10;        return ViewHolder(v)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val ctx = holder.itemView.context&#10;        val req = items[position]&#10;        holder.tvTitle.text = ctx.getString(R.string.request_id_format, req.requestID)&#10;        holder.tvSubtitle.text = ctx.getString(R.string.customer_format, req.customerName)&#10;        // New: show sacks count&#10;        holder.tvSacks.text = ctx.getString(R.string.sacks_format, req.sackQuantity)&#10;&#10;        // New: show a basic details dialog on card tap&#10;        holder.itemView.setOnClickListener {&#10;            val details = buildString {&#10;                appendLine(ctx.getString(R.string.request_id_format, req.requestID))&#10;                appendLine(ctx.getString(R.string.customer_format, req.customerName))&#10;                appendLine(ctx.getString(R.string.sacks_format, req.sackQuantity))&#10;                appendLine(ctx.getString(R.string.service_format, req.serviceName))&#10;                req.pickupLocation?.takeIf { it.isNotBlank() }?.let {&#10;                    appendLine(ctx.getString(R.string.pickup_location_format, it))&#10;                }&#10;                req.deliveryLocation?.takeIf { it.isNotBlank() }?.let {&#10;                    appendLine(ctx.getString(R.string.delivery_location_format, it))&#10;                }&#10;                req.schedule?.takeIf { it.isNotBlank() }?.let {&#10;                    appendLine(ctx.getString(R.string.schedule_format, it))&#10;                }&#10;            }&#10;            AlertDialog.Builder(ctx)&#10;                .setTitle(R.string.request_details_title)&#10;                .setMessage(details.trim())&#10;                .setPositiveButton(R.string.close, null)&#10;                .show()&#10;        }&#10;&#10;        val ongoingText = if (mode == DeliveryMode.PICKUPS) ctx.getString(R.string.status_pickup_ongoing) else ctx.getString(R.string.status_ongoing_delivery)&#10;        val doneText = if (mode == DeliveryMode.PICKUPS) ctx.getString(R.string.status_pickup_done) else ctx.getString(R.string.status_delivery_done)&#10;        val pendingText = ctx.getString(R.string.pending_label)&#10;        val isDone = req.statusID == 8&#10;&#10;        holder.tvStatusLabel.text = when {&#10;            isDone -&gt; doneText&#10;            else -&gt; req.submittedAt?.let { ctx.getString(R.string.date_requested_format, it) } ?: pendingText&#10;        }&#10;&#10;        // Configure buttons depending on mode&#10;        if (mode == DeliveryMode.PICKUPS) {&#10;            val canInitiate = req.statusID == 10&#10;            val isOngoing = req.statusID == 2&#10;&#10;            holder.btnInitiate.isEnabled = canInitiate&#10;            holder.btnDone.isEnabled = isOngoing&#10;&#10;            holder.btnInitiate.setOnClickListener {&#10;                // Update status to &quot;delivery boy pickup&quot; (2)&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    try {&#10;                        requestRepository.updateRequestStatus(req.requestID, 2)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;DeliveryCardAdapter&quot;, &quot;Failed to update pickup status&quot;, e)&#10;                    }&#10;                }&#10;                holder.tvStatusLabel.text = ongoingText&#10;                holder.btnInitiate.isEnabled = false&#10;                holder.btnDone.isEnabled = true&#10;                onAction(req, DeliveryAction.INITIATE)&#10;            }&#10;&#10;            holder.btnDone.setOnClickListener {&#10;                onAction(req, DeliveryAction.DONE)&#10;                holder.tvStatusLabel.text = doneText&#10;                holder.btnInitiate.isEnabled = false&#10;                holder.btnDone.isEnabled = false&#10;&#10;                // Add this coroutine to update backend status to 4 (pending)&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    try {&#10;                        requestRepository.updateRequestStatus(req.requestID, 4)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;DeliveryCardAdapter&quot;, &quot;Failed to update pickup done status&quot;, e)&#10;                    }&#10;                }&#10;            }&#10;&#10;        } else { // DELIVERIES&#10;            holder.btnInitiate.text = ctx.getString(R.string.action_initiate_delivery)&#10;            holder.btnDone.text = ctx.getString(R.string.action_delivery_done)&#10;&#10;            val statusText = when (req.statusID) {&#10;                12 -&gt; ctx.getString(R.string.status_milling_ready_delivery)&#10;                6 -&gt; ctx.getString(R.string.status_ongoing_delivery)&#10;                13 -&gt; ctx.getString(R.string.status_delivery_done)&#10;                else -&gt; pendingText&#10;            }&#10;            holder.tvStatusLabel.text = statusText&#10;&#10;            // Only enable &quot;Initiate Delivery&quot; if statusID = 12 (Milling done)&#10;            holder.btnInitiate.isEnabled = req.statusID == 12&#10;            // &quot;Delivery Done&quot; is only enabled if statusID = 6 (Rider out for delivery)&#10;            holder.btnDone.isEnabled = req.statusID == 6&#10;&#10;            holder.btnInitiate.setOnClickListener {&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    try {&#10;                        val response = requestRepository.updateRequestStatus(req.requestID, 6) // 6 = Rider out for delivery&#10;                        if (response.isSuccessful) {&#10;                            req.statusID = 6&#10;                            CoroutineScope(Dispatchers.Main).launch {&#10;                                holder.tvStatusLabel.text = ctx.getString(R.string.status_ongoing_delivery)&#10;                                holder.btnInitiate.isEnabled = false&#10;                                holder.btnDone.isEnabled = true&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;DeliveryCardAdapter&quot;, &quot;Error initiating delivery&quot;, e)&#10;                    }&#10;                }&#10;                onAction(req, DeliveryAction.INITIATE)&#10;            }&#10;&#10;            holder.btnDone.setOnClickListener {&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    try {&#10;                        val response = requestRepository.updateRequestStatus(req.requestID, 13) // 13 = Delivered&#10;                        if (response.isSuccessful) {&#10;                            req.statusID = 13&#10;                            CoroutineScope(Dispatchers.Main).launch {&#10;                                holder.tvStatusLabel.text = ctx.getString(R.string.status_delivery_done)&#10;                                holder.btnInitiate.isEnabled = false&#10;                                holder.btnDone.isEnabled = false&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;DeliveryCardAdapter&quot;, &quot;Error marking delivery done&quot;, e)&#10;                    }&#10;                }&#10;                onAction(req, DeliveryAction.DONE)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun submit(newItems: List&lt;Request&gt;) {&#10;        items = newItems.toMutableList()&#10;        notifyDataSetChanged()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.capstone2.adapter&#10;&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.RequestRepository&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;enum class DeliveryMode { PICKUPS, DELIVERIES }&#10;enum class DeliveryAction { INITIATE, DONE }&#10;&#10;class DeliveryCardAdapter(&#10;    private var items: MutableList&lt;Request&gt;,&#10;    private val mode: DeliveryMode,&#10;    private val onAction: (Request, DeliveryAction) -&gt; Unit,&#10;    private val requestRepository: RequestRepository&#10;) : RecyclerView.Adapter&lt;DeliveryCardAdapter.ViewHolder&gt;() {&#10;&#10;    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        val tvTitle: TextView = itemView.findViewById(R.id.tvTitle)&#10;        val tvSubtitle: TextView = itemView.findViewById(R.id.tvSubtitle)&#10;        val tvSacks: TextView = itemView.findViewById(R.id.tvSacks)&#10;        val tvStatusLabel: TextView = itemView.findViewById(R.id.tvStatusLabel)&#10;        val btnInitiate: Button = itemView.findViewById(R.id.btnInitiate)&#10;        val btnDone: Button = itemView.findViewById(R.id.btnDone)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {&#10;        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_delivery_card, parent, false)&#10;        return ViewHolder(v)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ViewHolder, position: Int) {&#10;        val ctx = holder.itemView.context&#10;        val req = items[position]&#10;        holder.tvTitle.text = ctx.getString(R.string.request_id_format, req.requestID)&#10;        holder.tvSubtitle.text = ctx.getString(R.string.customer_format, req.customerName)&#10;        // New: show sacks count&#10;        holder.tvSacks.text = ctx.getString(R.string.sacks_format, req.sackQuantity)&#10;&#10;        // New: show a basic details dialog on card tap&#10;        holder.itemView.setOnClickListener {&#10;            val details = buildString {&#10;                appendLine(ctx.getString(R.string.request_id_format, req.requestID))&#10;                appendLine(ctx.getString(R.string.customer_format, req.customerName))&#10;                appendLine(ctx.getString(R.string.sacks_format, req.sackQuantity))&#10;                appendLine(ctx.getString(R.string.service_format, req.serviceName))&#10;                req.pickupLocation?.takeIf { it.isNotBlank() }?.let {&#10;                    appendLine(ctx.getString(R.string.pickup_location_format, it))&#10;                }&#10;                req.deliveryLocation?.takeIf { it.isNotBlank() }?.let {&#10;                    appendLine(ctx.getString(R.string.delivery_location_format, it))&#10;                }&#10;                req.schedule?.takeIf { it.isNotBlank() }?.let {&#10;                    appendLine(ctx.getString(R.string.schedule_format, it))&#10;                }&#10;            }&#10;            AlertDialog.Builder(ctx)&#10;                .setTitle(R.string.request_details_title)&#10;                .setMessage(details.trim())&#10;                .setPositiveButton(R.string.close, null)&#10;                .show()&#10;        }&#10;&#10;        val ongoingText = if (mode == DeliveryMode.PICKUPS) ctx.getString(R.string.status_pickup_ongoing) else ctx.getString(R.string.status_ongoing_delivery)&#10;        val doneText = if (mode == DeliveryMode.PICKUPS) ctx.getString(R.string.status_pickup_done) else ctx.getString(R.string.status_delivery_done)&#10;        val pendingText = ctx.getString(R.string.pending_label)&#10;        val isDone = req.statusID == 8&#10;&#10;        holder.tvStatusLabel.text = when {&#10;            isDone -&gt; doneText&#10;            else -&gt; req.submittedAt?.let { ctx.getString(R.string.date_requested_format, it) } ?: pendingText&#10;        }&#10;&#10;        // Configure buttons depending on mode&#10;        if (mode == DeliveryMode.PICKUPS) {&#10;            val canInitiate = req.statusID == 10 || req.statusID == 11&#10;            val isOngoing = req.statusID == 2&#10;&#10;            holder.btnInitiate.isEnabled = canInitiate&#10;            holder.btnDone.isEnabled = isOngoing&#10;&#10;            holder.btnInitiate.setOnClickListener {&#10;                // Optimistic UI updates; actual network handled by fragment via callback&#10;                holder.tvStatusLabel.text = ongoingText&#10;                holder.btnInitiate.isEnabled = false&#10;                holder.btnDone.isEnabled = true&#10;                onAction(req, DeliveryAction.INITIATE)&#10;            }&#10;&#10;            holder.btnDone.setOnClickListener {&#10;                // Optimistic UI updates; actual network handled by fragment via callback&#10;                holder.tvStatusLabel.text = doneText&#10;                holder.btnInitiate.isEnabled = false&#10;                holder.btnDone.isEnabled = false&#10;                onAction(req, DeliveryAction.DONE)&#10;            }&#10;&#10;        } else { // DELIVERIES&#10;            holder.btnInitiate.text = ctx.getString(R.string.action_initiate_delivery)&#10;            holder.btnDone.text = ctx.getString(R.string.action_delivery_done)&#10;&#10;            val statusText = when (req.statusID) {&#10;                12 -&gt; ctx.getString(R.string.status_milling_ready_delivery)&#10;                6 -&gt; ctx.getString(R.string.status_ongoing_delivery)&#10;                13 -&gt; ctx.getString(R.string.status_delivery_done)&#10;                else -&gt; pendingText&#10;            }&#10;            holder.tvStatusLabel.text = statusText&#10;&#10;            // Only enable &quot;Initiate Delivery&quot; if statusID = 12 (Milling done)&#10;            holder.btnInitiate.isEnabled = req.statusID == 12&#10;            // &quot;Delivery Done&quot; is only enabled if statusID = 6 (Rider out for delivery)&#10;            holder.btnDone.isEnabled = req.statusID == 6&#10;&#10;            holder.btnInitiate.setOnClickListener {&#10;                // Optimistic UI; network handled by fragment&#10;                holder.tvStatusLabel.text = ctx.getString(R.string.status_ongoing_delivery)&#10;                holder.btnInitiate.isEnabled = false&#10;                holder.btnDone.isEnabled = true&#10;                onAction(req, DeliveryAction.INITIATE)&#10;            }&#10;&#10;            holder.btnDone.setOnClickListener {&#10;                // Optimistic UI; network handled by fragment&#10;                holder.tvStatusLabel.text = ctx.getString(R.string.status_delivery_done)&#10;                holder.btnInitiate.isEnabled = false&#10;                holder.btnDone.isEnabled = false&#10;                onAction(req, DeliveryAction.DONE)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun submit(newItems: List&lt;Request&gt;) {&#10;        items = newItems.toMutableList()&#10;        notifyDataSetChanged()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/delivery/DeliveryFragmentDeliveries.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/delivery/DeliveryFragmentDeliveries.kt" />
              <option name="originalContent" value="package com.example.capstone2.delivery&#10;&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.DeliveryAction&#10;import com.example.capstone2.adapter.DeliveryCardAdapter&#10;import com.example.capstone2.adapter.DeliveryMode&#10;import com.example.capstone2.data.api.ApiService&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import kotlinx.coroutines.launch&#10;&#10;class DeliveryFragmentDeliveries : Fragment(R.layout.fragment_delivery_deliveries) {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var tvNoRequests: TextView&#10;    private lateinit var requestRepository: RequestRepository&#10;    private var deliveryAdapter: DeliveryCardAdapter? = null&#10;    private lateinit var apiService: ApiService&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        recyclerView = view.findViewById(R.id.recyclerViewDeliveryDeliveries)&#10;        tvNoRequests = view.findViewById(R.id.tvNoRequestsDeliveries)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        // Get token from SharedPreferences&#10;        val token = SharedPrefManager.getAuthToken(requireContext())&#10;        if (token.isNullOrEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Missing auth token&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Initialize ApiService + Repository&#10;        apiService = ApiClient.getApiService { token ?: &quot;&quot; }&#10;        requestRepository = RequestRepository(apiService)&#10;&#10;        // Initialize adapter&#10;        deliveryAdapter = DeliveryCardAdapter(&#10;            mutableListOf(),&#10;            DeliveryMode.DELIVERIES,&#10;            { request, action -&gt;&#10;                when (action) {&#10;                    DeliveryAction.INITIATE -&gt; markDeliveryInitiated(request)&#10;                    DeliveryAction.DONE -&gt; markDeliveryDone(request)&#10;                }&#10;            },&#10;            requestRepository&#10;        )&#10;        recyclerView.adapter = deliveryAdapter&#10;&#10;        fetchDeliveries()&#10;    }&#10;&#10;    private fun fetchDeliveries() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                // Only show Milling done (12) or Rider out (6)&#10;                val requests = requestRepository.getDeliveryBoyRequests()&#10;                    .filter { request -&gt;&#10;                        (request.serviceID == 1L || request.serviceID == 3L || request.serviceID == 5L) &amp;&amp;&#10;                                (request.statusID == 12 || request.statusID == 6)&#10;                    }&#10;&#10;&#10;                deliveryAdapter?.submit(requests)&#10;                tvNoRequests.visibility = if (requests.isEmpty()) View.VISIBLE else View.GONE&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error fetching deliveries: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markDeliveryInitiated(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.updateRequestStatus(request.requestID, 6) // Rider out&#10;                if (response.isSuccessful) {&#10;                    Toast.makeText(requireContext(), &quot;Delivery initiated&quot;, Toast.LENGTH_SHORT).show()&#10;                    fetchDeliveries() // refresh list to update button states&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed to initiate delivery&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markDeliveryDone(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.updateRequestStatus(request.requestID, 13) // Delivered&#10;                if (response.isSuccessful) {&#10;                    Toast.makeText(requireContext(), &quot;Delivery completed&quot;, Toast.LENGTH_SHORT).show()&#10;                    // Refetch the updated list&#10;                    fetchDeliveries()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed to mark delivery done&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.delivery&#10;&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.DeliveryAction&#10;import com.example.capstone2.adapter.DeliveryCardAdapter&#10;import com.example.capstone2.adapter.DeliveryMode&#10;import com.example.capstone2.data.api.ApiService&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import kotlinx.coroutines.launch&#10;&#10;class DeliveryFragmentDeliveries : Fragment(R.layout.fragment_delivery_deliveries) {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var tvNoRequests: TextView&#10;    private lateinit var requestRepository: RequestRepository&#10;    private var deliveryAdapter: DeliveryCardAdapter? = null&#10;    private lateinit var apiService: ApiService&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        recyclerView = view.findViewById(R.id.recyclerViewDeliveryDeliveries)&#10;        tvNoRequests = view.findViewById(R.id.tvNoRequestsDeliveries)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        // Get token from SharedPreferences&#10;        val token = SharedPrefManager.getAuthToken(requireContext())&#10;        if (token.isNullOrEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Missing auth token&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Initialize ApiService + Repository&#10;        apiService = ApiClient.getApiService { token }&#10;        requestRepository = RequestRepository(apiService)&#10;&#10;        // Initialize adapter&#10;        deliveryAdapter = DeliveryCardAdapter(&#10;            mutableListOf(),&#10;            DeliveryMode.DELIVERIES,&#10;            { request, action -&gt;&#10;                when (action) {&#10;                    DeliveryAction.INITIATE -&gt; markDeliveryInitiated(request)&#10;                    DeliveryAction.DONE -&gt; markDeliveryDone(request)&#10;                }&#10;            },&#10;            requestRepository&#10;        )&#10;        recyclerView.adapter = deliveryAdapter&#10;&#10;        fetchDeliveries()&#10;    }&#10;&#10;    private fun fetchDeliveries() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                // Show requests ready for or out on delivery: status 12 (Milling done) or 6 (Rider out)&#10;                val requests = requestRepository.getDeliveryBoyRequests()&#10;                    .filter { request -&gt;&#10;                        val deliveryRelatedService = request.serviceID in listOf(1L, 3L, 5L, 7L)&#10;                        val deliveryStatus = request.statusID == 12 || request.statusID == 6&#10;                        (deliveryStatus &amp;&amp; deliveryRelatedService)&#10;                    }&#10;&#10;&#10;                deliveryAdapter?.submit(requests)&#10;                tvNoRequests.visibility = if (requests.isEmpty()) View.VISIBLE else View.GONE&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error fetching deliveries: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                tvNoRequests.visibility = View.VISIBLE&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markDeliveryInitiated(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.updateRequestStatus(request.requestID, 6) // Rider out&#10;                if (response.isSuccessful) {&#10;                    Toast.makeText(requireContext(), &quot;Delivery initiated&quot;, Toast.LENGTH_SHORT).show()&#10;                    fetchDeliveries() // refresh list to update button states&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed to initiate delivery&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markDeliveryDone(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.updateRequestStatus(request.requestID, 13) // Delivered&#10;                if (response.isSuccessful) {&#10;                    Toast.makeText(requireContext(), &quot;Delivery completed&quot;, Toast.LENGTH_SHORT).show()&#10;                    // Refetch the updated list&#10;                    fetchDeliveries()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed to mark delivery done&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/delivery/DeliveryFragmentPickups.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/delivery/DeliveryFragmentPickups.kt" />
              <option name="originalContent" value="package com.example.capstone2.delivery&#10;&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.DeliveryAction&#10;import com.example.capstone2.adapter.DeliveryCardAdapter&#10;import com.example.capstone2.adapter.DeliveryMode&#10;import com.example.capstone2.data.api.ApiService&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import kotlinx.coroutines.launch&#10;&#10;class DeliveryFragmentPickups : Fragment(R.layout.fragment_delivery_pickups) {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var requestRepository: RequestRepository&#10;    private lateinit var tvNoRequests: TextView&#10;    private lateinit var apiService: ApiService&#10;    private var deliveryAdapter: DeliveryCardAdapter? = null&#10;&#10;    private lateinit var repo: RequestRepository&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        recyclerView = view.findViewById(R.id.recyclerViewDeliveryPickups)&#10;        tvNoRequests = view.findViewById(R.id.tvNoRequestsPickups)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        // ✅ Initialize ApiService first&#10;        apiService = ApiClient.apiService // &lt;-- replace with your Retrofit builder&#10;&#10;        // 2️⃣ Initialize repository&#10;        requestRepository = RequestRepository(apiService)&#10;&#10;        // Get token&#10;        val token = SharedPrefManager.getAuthToken(requireContext())&#10;        if (token.isNullOrEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Missing auth token&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // ✅ Create authenticated ApiService + Repository&#10;        val authedApiService = ApiClient.getApiService { token ?: &quot;&quot; }&#10;        requestRepository = RequestRepository(authedApiService)&#10;&#10;        // Initialize Adapter&#10;        deliveryAdapter = DeliveryCardAdapter(&#10;            mutableListOf(),&#10;            DeliveryMode.PICKUPS,&#10;            { request: Request, action: DeliveryAction -&gt;  // Explicit types help Kotlin infer correctly&#10;                when (action) {&#10;                    DeliveryAction.INITIATE -&gt; {&#10;                        // Optionally update UI here&#10;                    }&#10;                    DeliveryAction.DONE -&gt; {&#10;                        markPickupDone(request)&#10;                    }&#10;                }&#10;            },&#10;            requestRepository  // &lt;- pass the repository here&#10;        )&#10;        recyclerView.adapter = deliveryAdapter&#10;&#10;        // Fetch approved pickups (statusID = 2)&#10;        fetchApprovedPickups()&#10;    }&#10;&#10;    private fun fetchApprovedPickups() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val requests = requestRepository.getDeliveryBoyRequests()&#10;                    .filter { request -&gt;&#10;                        // Only include services that involve pickup&#10;                        (request.serviceID == 1L || request.serviceID == 2L || request.serviceID == 5L) &amp;&amp;&#10;                                // Only include requests currently in pickup-related statuses&#10;                                (request.statusID == 10 || request.statusID == 2)&#10;                    }&#10;&#10;                deliveryAdapter?.submit(requests)&#10;                tvNoRequests.visibility = if (requests.isEmpty()) View.VISIBLE else View.GONE&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error fetching requests: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markPickupDone(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.markPickupDone(request.requestID)&#10;                if (response.isSuccessful) {&#10;                    Toast.makeText(requireContext(), &quot;Pickup marked done&quot;, Toast.LENGTH_SHORT).show()&#10;                    fetchApprovedPickups()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed: ${response.code()} ${response.message()}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error marking pickup done: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.delivery&#10;&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.DeliveryAction&#10;import com.example.capstone2.adapter.DeliveryCardAdapter&#10;import com.example.capstone2.adapter.DeliveryMode&#10;import com.example.capstone2.data.api.ApiService&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import kotlinx.coroutines.launch&#10;&#10;class DeliveryFragmentPickups : Fragment(R.layout.fragment_delivery_pickups) {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var requestRepository: RequestRepository&#10;    private lateinit var tvNoRequests: TextView&#10;    private lateinit var apiService: ApiService&#10;    private var deliveryAdapter: DeliveryCardAdapter? = null&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        recyclerView = view.findViewById(R.id.recyclerViewDeliveryPickups)&#10;        tvNoRequests = view.findViewById(R.id.tvNoRequestsPickups)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        // ✅ Initialize ApiService using token&#10;        val token = SharedPrefManager.getAuthToken(requireContext())&#10;        if (token.isNullOrEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Missing auth token&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        apiService = ApiClient.getApiService { token }&#10;        requestRepository = RequestRepository(apiService)&#10;&#10;        // Initialize Adapter - delegate actions to fragment (no direct network inside adapter)&#10;        deliveryAdapter = DeliveryCardAdapter(&#10;            mutableListOf(),&#10;            DeliveryMode.PICKUPS,&#10;            { request: Request, action: DeliveryAction -&gt;&#10;                when (action) {&#10;                    DeliveryAction.INITIATE -&gt; markPickupInitiated(request)&#10;                    DeliveryAction.DONE -&gt; markPickupDone(request)&#10;                }&#10;            },&#10;            requestRepository&#10;        )&#10;        recyclerView.adapter = deliveryAdapter&#10;&#10;        // Fetch pickup-eligible requests&#10;        fetchApprovedPickups()&#10;    }&#10;&#10;    private fun fetchApprovedPickups() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val requests = requestRepository.getDeliveryBoyRequests()&#10;                    .filter { request -&gt;&#10;                        // Let backend decide eligibility; only filter by pickup-related statuses&#10;                        // 10=Request Accepted (ready to initiate pickup), 2=Delivery boy pickup ongoing, 11=Partially accepted (optional)&#10;                        request.statusID == 10 || request.statusID == 2 || request.statusID == 11&#10;                    }&#10;&#10;                deliveryAdapter?.submit(requests)&#10;                tvNoRequests.visibility = if (requests.isEmpty()) View.VISIBLE else View.GONE&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error fetching requests: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                tvNoRequests.visibility = View.VISIBLE&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markPickupInitiated(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.updateRequestStatus(request.requestID, 2) // 2 = Delivery boy pickup&#10;                if (response.isSuccessful) {&#10;                    Toast.makeText(requireContext(), &quot;Pickup initiated&quot;, Toast.LENGTH_SHORT).show()&#10;                    fetchApprovedPickups()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed: ${response.code()} ${response.message()}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error initiating pickup: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markPickupDone(request: Request) {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val response = requestRepository.markPickupDone(request.requestID)&#10;                if (response.isSuccessful) {&#10;                    // Also set status to Pending (4) as per previous behavior&#10;                    try {&#10;                        requestRepository.updateRequestStatus(request.requestID, 4)&#10;                    } catch (_: Exception) { /* ignore */ }&#10;                    Toast.makeText(requireContext(), &quot;Pickup marked done&quot;, Toast.LENGTH_SHORT).show()&#10;                    fetchApprovedPickups()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Failed: ${response.code()} ${response.message()}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(requireContext(), &quot;Error marking pickup done: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:padding=&quot;8dp&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvConversations&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:paddingBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvEmpty&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:text=&quot;No conversations&quot;&#10;        android:visibility=&quot;gone&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>