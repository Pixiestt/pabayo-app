<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/customer/PickupServiceFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/customer/PickupServiceFragment.kt" />
              <option name="originalContent" value="package com.example.capstone2.customer&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.EditText&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import android.app.DatePickerDialog&#10;import android.app.TimePickerDialog&#10;import android.icu.util.Calendar&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import com.example.capstone2.R&#10;import com.example.capstone2.data.models.PickupService&#10;import androidx.core.widget.addTextChangedListener&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.example.capstone2.viewmodel.UserViewModel&#10;import com.example.capstone2.viewmodel.UserViewModelFactory&#10;&#10;class PickupServiceFragment : Fragment() {&#10;    &#10;    private lateinit var radioGroup: RadioGroup&#10;    private lateinit var pickupDetailsContainer: View&#10;    private lateinit var etPickupLocation: EditText&#10;    private lateinit var etPickupDate: EditText&#10;    private lateinit var etPickupTime: EditText&#10;    private lateinit var btnNext: Button&#10;    private lateinit var tvStepProgress: TextView&#10;    private lateinit var cbUseSignupAddress: CheckBox&#10;&#10;    private lateinit var userViewModel: UserViewModel&#10;    private var savedHomeAddress: String = &quot;&quot;&#10;&#10;    private val calendar = Calendar.getInstance()&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.UK)&#10;    private val timeFormat24 = SimpleDateFormat(&quot;HH:mm&quot;, Locale.UK)&#10;    private val TAG = &quot;PickupServiceFragment&quot;&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_pickup_service, container, false)&#10;    }&#10;    &#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        &#10;        // Initialize views&#10;        radioGroup = view.findViewById(R.id.radioGroupPickup)&#10;        pickupDetailsContainer = view.findViewById(R.id.pickupDetailsContainer)&#10;        etPickupLocation = view.findViewById(R.id.etPickupLocation)&#10;        etPickupDate = view.findViewById(R.id.etPickupDate)&#10;        etPickupTime = view.findViewById(R.id.etPickupTime)&#10;        btnNext = view.findViewById(R.id.btnNext)&#10;        tvStepProgress = view.findViewById(R.id.tvStepProgress)&#10;        cbUseSignupAddress = view.findViewById(R.id.cbUseSignupAddress)&#10;&#10;        userViewModel = ViewModelProvider(&#10;            requireActivity(),&#10;            UserViewModelFactory(requireContext())&#10;        )[UserViewModel::class.java]&#10;&#10;        val activity = requireActivity() as RequestWizardActivity&#10;        tvStepProgress.text = &quot;2/4&quot;&#10;&#10;        // Observe user profile to get saved home address&#10;        userViewModel.getProfile().observe(viewLifecycleOwner) { user -&gt;&#10;            if (user != null) {&#10;                // user.homeAddress is non-null in this project model&#10;                savedHomeAddress = user.homeAddress ?: &quot;&quot;&#10;&#10;                // If wizard had the same address previously selected, reflect that in the checkbox&#10;                val wizard = activity.getWizardData()&#10;                if (!savedHomeAddress.isBlank() &amp;&amp; wizard.pickupLocation == savedHomeAddress) {&#10;                    cbUseSignupAddress.isChecked = true&#10;                    etPickupLocation.setText(savedHomeAddress)&#10;                    etPickupLocation.isEnabled = false&#10;                }&#10;&#10;                // If the user already checked the checkbox while profile was loading,&#10;                // apply the saved home address now so the field is populated and locked.&#10;                if (cbUseSignupAddress.isChecked &amp;&amp; savedHomeAddress.isNotBlank()) {&#10;                    etPickupLocation.setText(savedHomeAddress)&#10;                    etPickupLocation.isEnabled = false&#10;                }&#10;            }&#10;        }&#10;&#10;        // Prefill from wizard data if present&#10;        val wizard = activity.getWizardData()&#10;        wizard.pickupService?.let { ps -&gt;&#10;            when (ps) {&#10;                PickupService.PICKUP_FROM_LOCATION -&gt; radioGroup.check(R.id.rbPickupFromLocation)&#10;                PickupService.DROP_OFF_AT_FACILITY -&gt; radioGroup.check(R.id.rbDropOffAtFacility)&#10;            }&#10;        }&#10;&#10;        // If wizard has stored pickup location/date/time, show container and set values&#10;        var hasPrefill = false&#10;        wizard.pickupLocation?.let { loc -&gt;&#10;            etPickupLocation.setText(loc)&#10;            hasPrefill = true&#10;        }&#10;        wizard.pickupDate?.let { pd -&gt;&#10;            // Only prefill if the stored date is today or in the future&#10;            val parsed = try { dateFormat.parse(pd) } catch (_: Exception) { null }&#10;            val isPast = parsed?.time?.let { it &lt; startOfTodayMillis() } ?: true&#10;            if (!isPast) {&#10;                etPickupDate.setText(pd)&#10;                hasPrefill = true&#10;            } else {&#10;                // Clear stale past date from wizard and notify user&#10;                wizard.pickupDate = null&#10;                etPickupDate.setText(&quot;&quot;)&#10;                Toast.makeText(requireContext(), &quot;Previous pickup date was in the past. Please choose a new date.&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;        wizard.pickupTime?.let { pt -&gt;&#10;            etPickupTime.setText(pt)&#10;            hasPrefill = true&#10;        }&#10;        if (hasPrefill) {&#10;            pickupDetailsContainer.visibility = View.VISIBLE&#10;            // ensure date/time fields visible (XML had them gone)&#10;            etPickupDate.visibility = View.VISIBLE&#10;            etPickupTime.visibility = View.VISIBLE&#10;        }&#10;&#10;        // Initially hide or show the container depending on radio selection&#10;        when (radioGroup.checkedRadioButtonId) {&#10;            R.id.rbDropOffAtFacility -&gt; {&#10;                pickupDetailsContainer.visibility = View.GONE&#10;                etPickupDate.visibility = View.GONE&#10;                etPickupTime.visibility = View.GONE&#10;            }&#10;            R.id.rbPickupFromLocation -&gt; {&#10;                pickupDetailsContainer.visibility = View.VISIBLE&#10;                etPickupDate.visibility = View.VISIBLE&#10;                etPickupTime.visibility = View.VISIBLE&#10;            }&#10;            else -&gt; {&#10;                pickupDetailsContainer.visibility = View.GONE&#10;                etPickupDate.visibility = View.GONE&#10;                etPickupTime.visibility = View.GONE&#10;            }&#10;        }&#10;&#10;        setNextEnabled(false)&#10;&#10;        // Checkbox listener: autofill with signup address and disable editing when checked&#10;        cbUseSignupAddress.setOnCheckedChangeListener { _, isChecked -&gt;&#10;            if (isChecked) {&#10;                // If we don't yet have the saved home address, try to read from ViewModel immediately&#10;                if (savedHomeAddress.isBlank()) {&#10;                    // Will be filled by observer when profile loads; clear for now&#10;                    etPickupLocation.setText(&quot;&quot;)&#10;                } else {&#10;                    etPickupLocation.setText(savedHomeAddress)&#10;                }&#10;                etPickupLocation.isEnabled = false&#10;                etPickupLocation.isFocusable = false&#10;                // Immediately reflect selection in wizard data&#10;                activity.getWizardData().pickupLocation = if (savedHomeAddress.isNotBlank()) savedHomeAddress else activity.getWizardData().pickupLocation&#10;            } else {&#10;                // Allow user to edit a custom address&#10;                // If wizard was using the saved home address, clear it so user can provide a custom one&#10;                val wizardData = activity.getWizardData()&#10;                if (wizardData.pickupLocation == savedHomeAddress) {&#10;                    wizardData.pickupLocation = null&#10;                }&#10;                etPickupLocation.isEnabled = true&#10;                etPickupLocation.isFocusableInTouchMode = true&#10;            }&#10;            validateForm()&#10;        }&#10;&#10;        // Set up radio button listeners&#10;        radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            when (checkedId) {&#10;                R.id.rbPickupFromLocation -&gt; {&#10;                    Log.d(TAG, &quot;Selected: Pickup from location&quot;)&#10;                    Toast.makeText(requireContext(), &quot;Pickup from location selected&quot;, Toast.LENGTH_SHORT).show()&#10;                    activity.getWizardData().pickupService = PickupService.PICKUP_FROM_LOCATION&#10;                    pickupDetailsContainer.visibility = View.VISIBLE&#10;                    etPickupDate.visibility = View.VISIBLE&#10;                    etPickupTime.visibility = View.VISIBLE&#10;                    validateForm()&#10;                }&#10;                R.id.rbDropOffAtFacility -&gt; {&#10;                    Log.d(TAG, &quot;Selected: Drop off at facility&quot;)&#10;                    Toast.makeText(requireContext(), &quot;Drop off at facility selected&quot;, Toast.LENGTH_SHORT).show()&#10;                    activity.getWizardData().pickupService = PickupService.DROP_OFF_AT_FACILITY&#10;                    pickupDetailsContainer.visibility = View.GONE&#10;                    etPickupLocation.text.clear()&#10;                    etPickupDate.text.clear()&#10;                    etPickupTime.text.clear()&#10;                    etPickupDate.visibility = View.GONE&#10;                    etPickupTime.visibility = View.GONE&#10;                    // reset checkbox when hiding&#10;                    cbUseSignupAddress.isChecked = false&#10;                    // also clear saved wizard data when hiding&#10;                    val wiz = activity.getWizardData()&#10;                    wiz.pickupLocation = null&#10;                    wiz.pickupDate = null&#10;                    wiz.pickupTime = null&#10;                    validateForm()&#10;                }&#10;                else -&gt; {&#10;                    Log.d(TAG, &quot;No pickup option selected&quot;)&#10;                    setNextEnabled(false)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Re-validate when user types location or date/time&#10;        etPickupLocation.addTextChangedListener { validateForm() }&#10;        etPickupDate.addTextChangedListener { validateForm() }&#10;        etPickupTime.addTextChangedListener { /* time optional, not gating next */ }&#10;&#10;        // Ensure initial state matches any pre-selected radio button in XML&#10;        validateForm()&#10;&#10;        // Set up date picker&#10;        val datePickerListener = DatePickerDialog.OnDateSetListener { _, year, month, day -&gt;&#10;            calendar.set(Calendar.YEAR, year)&#10;            calendar.set(Calendar.MONTH, month)&#10;            calendar.set(Calendar.DAY_OF_MONTH, day)&#10;            etPickupDate.setText(dateFormat.format(calendar.time))&#10;            validateForm()&#10;        }&#10;        &#10;        etPickupDate.setOnClickListener {&#10;            val dialog = DatePickerDialog(&#10;                requireContext(),&#10;                datePickerListener,&#10;                calendar.get(Calendar.YEAR),&#10;                calendar.get(Calendar.MONTH),&#10;                calendar.get(Calendar.DAY_OF_MONTH)&#10;            )&#10;            // Disallow selecting past dates&#10;            dialog.datePicker.minDate = startOfTodayMillis()&#10;            dialog.show()&#10;        }&#10;&#10;        // Set up time picker (optional)&#10;        etPickupTime.setOnClickListener {&#10;            val hour = calendar.get(Calendar.HOUR_OF_DAY)&#10;            val minute = calendar.get(Calendar.MINUTE)&#10;            TimePickerDialog(requireContext(), { _, selHour, selMinute -&gt;&#10;                // Store in 24h HH:mm format to match backend normalization&#10;                val cal = (calendar.clone() as Calendar)&#10;                cal.set(Calendar.HOUR_OF_DAY, selHour)&#10;                cal.set(Calendar.MINUTE, selMinute)&#10;                etPickupTime.setText(timeFormat24.format(cal.time))&#10;            }, hour, minute, true).show()&#10;        }&#10;&#10;        btnNext.setOnClickListener {&#10;            val location = etPickupLocation.text.toString().trim()&#10;            val pickupDate = etPickupDate.text.toString().trim()&#10;            val pickupTime = etPickupTime.text.toString().trim().ifEmpty { null }&#10;&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; location.isEmpty()) {&#10;                etPickupLocation.error = &quot;Please enter your location&quot;&#10;                return@setOnClickListener&#10;            }&#10;            &#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; pickupDate.isEmpty()) {&#10;                etPickupDate.error = &quot;Please select a pickup date&quot;&#10;                return@setOnClickListener&#10;            }&#10;            &#10;            // Extra guard: block past dates if somehow present&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; pickupDate.isNotEmpty()) {&#10;                val parsed = try { dateFormat.parse(pickupDate) } catch (_: Exception) { null }&#10;                val isPast = parsed?.time?.let { it &lt; startOfTodayMillis() } ?: true&#10;                if (isPast) {&#10;                    etPickupDate.error = &quot;Pickup date can’t be in the past&quot;&#10;                    Toast.makeText(requireContext(), &quot;Please choose today or a future date.&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@setOnClickListener&#10;                }&#10;            }&#10;&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation) {&#10;                activity.getWizardData().pickupLocation = location&#10;            }&#10;            &#10;            // Save pickup date only if set (pickup-from-location)&#10;            if (pickupDate.isNotEmpty()) {&#10;                activity.getWizardData().pickupDate = pickupDate&#10;            } else {&#10;                activity.getWizardData().pickupDate = null&#10;            }&#10;            // Save pickup time (optional)&#10;            activity.getWizardData().pickupTime = pickupTime&#10;&#10;            activity.goToNextStep()&#10;        }&#10;    }&#10;    &#10;    private fun validateForm() {&#10;        // If user chose pickup-from-location, require both location and date; time is optional&#10;        if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation) {&#10;            val enabled = etPickupLocation.text.toString().trim().isNotEmpty() &amp;&amp;&#10;                    etPickupDate.text.toString().trim().isNotEmpty()&#10;            setNextEnabled(enabled)&#10;        } else if (radioGroup.checkedRadioButtonId == R.id.rbDropOffAtFacility) {&#10;            // For drop-off option, no extra inputs required – enable Next&#10;            setNextEnabled(true)&#10;        } else {&#10;            // No selection yet&#10;            setNextEnabled(false)&#10;        }&#10;    }&#10;&#10;    private fun setNextEnabled(enabled: Boolean) {&#10;        btnNext.isEnabled = enabled&#10;        btnNext.isClickable = enabled&#10;        // visually indicate disabled state&#10;        btnNext.alpha = if (enabled) 1.0f else 0.5f&#10;        Log.d(TAG, &quot;Next button enabled: $enabled&quot;)&#10;    }&#10;&#10;    private fun startOfTodayMillis(): Long {&#10;        val c = Calendar.getInstance()&#10;        c.set(Calendar.HOUR_OF_DAY, 0)&#10;        c.set(Calendar.MINUTE, 0)&#10;        c.set(Calendar.SECOND, 0)&#10;        c.set(Calendar.MILLISECOND, 0)&#10;        return c.timeInMillis&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.customer&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.CheckBox&#10;import android.widget.EditText&#10;import android.widget.RadioGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import android.app.DatePickerDialog&#10;import android.app.TimePickerDialog&#10;import android.icu.util.Calendar&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import com.example.capstone2.R&#10;import com.example.capstone2.data.models.PickupService&#10;import androidx.core.widget.addTextChangedListener&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.example.capstone2.viewmodel.UserViewModel&#10;import com.example.capstone2.viewmodel.UserViewModelFactory&#10;&#10;class PickupServiceFragment : Fragment() {&#10;    &#10;    private lateinit var radioGroup: RadioGroup&#10;    private lateinit var pickupDetailsContainer: View&#10;    private lateinit var etPickupLocation: EditText&#10;    private lateinit var etPickupDate: EditText&#10;    private lateinit var etPickupTime: EditText&#10;    private lateinit var btnNext: Button&#10;    private lateinit var tvStepProgress: TextView&#10;    private lateinit var cbUseSignupAddress: CheckBox&#10;&#10;    private lateinit var userViewModel: UserViewModel&#10;    private var savedHomeAddress: String = &quot;&quot;&#10;&#10;    private val calendar = Calendar.getInstance()&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.UK)&#10;    private val timeFormat24 = SimpleDateFormat(&quot;HH:mm&quot;, Locale.UK)&#10;    private val TAG = &quot;PickupServiceFragment&quot;&#10;&#10;    // Business hour limits (inclusive). Only allow pickup times between these hours (08:00 - 17:00)&#10;    private val BUSINESS_START_HOUR = 8&#10;    private val BUSINESS_END_HOUR = 17&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_pickup_service, container, false)&#10;    }&#10;    &#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        &#10;        // Initialize views&#10;        radioGroup = view.findViewById(R.id.radioGroupPickup)&#10;        pickupDetailsContainer = view.findViewById(R.id.pickupDetailsContainer)&#10;        etPickupLocation = view.findViewById(R.id.etPickupLocation)&#10;        etPickupDate = view.findViewById(R.id.etPickupDate)&#10;        etPickupTime = view.findViewById(R.id.etPickupTime)&#10;        btnNext = view.findViewById(R.id.btnNext)&#10;        tvStepProgress = view.findViewById(R.id.tvStepProgress)&#10;        cbUseSignupAddress = view.findViewById(R.id.cbUseSignupAddress)&#10;&#10;        userViewModel = ViewModelProvider(&#10;            requireActivity(),&#10;            UserViewModelFactory(requireContext())&#10;        )[UserViewModel::class.java]&#10;&#10;        val activity = requireActivity() as RequestWizardActivity&#10;        tvStepProgress.text = &quot;2/4&quot;&#10;&#10;        // Observe user profile to get saved home address&#10;        userViewModel.getProfile().observe(viewLifecycleOwner) { user -&gt;&#10;            if (user != null) {&#10;                // user.homeAddress is non-null in this project model&#10;                savedHomeAddress = user.homeAddress ?: &quot;&quot;&#10;&#10;                // If wizard had the same address previously selected, reflect that in the checkbox&#10;                val wizard = activity.getWizardData()&#10;                if (!savedHomeAddress.isBlank() &amp;&amp; wizard.pickupLocation == savedHomeAddress) {&#10;                    cbUseSignupAddress.isChecked = true&#10;                    etPickupLocation.setText(savedHomeAddress)&#10;                    etPickupLocation.isEnabled = false&#10;                }&#10;&#10;                // If the user already checked the checkbox while profile was loading,&#10;                // apply the saved home address now so the field is populated and locked.&#10;                if (cbUseSignupAddress.isChecked &amp;&amp; savedHomeAddress.isNotBlank()) {&#10;                    etPickupLocation.setText(savedHomeAddress)&#10;                    etPickupLocation.isEnabled = false&#10;                }&#10;            }&#10;        }&#10;&#10;        // Prefill from wizard data if present&#10;        val wizard = activity.getWizardData()&#10;        wizard.pickupService?.let { ps -&gt;&#10;            when (ps) {&#10;                PickupService.PICKUP_FROM_LOCATION -&gt; radioGroup.check(R.id.rbPickupFromLocation)&#10;                PickupService.DROP_OFF_AT_FACILITY -&gt; radioGroup.check(R.id.rbDropOffAtFacility)&#10;            }&#10;        }&#10;&#10;        // If wizard has stored pickup location/date/time, show container and set values&#10;        var hasPrefill = false&#10;        wizard.pickupLocation?.let { loc -&gt;&#10;            etPickupLocation.setText(loc)&#10;            hasPrefill = true&#10;        }&#10;        wizard.pickupDate?.let { pd -&gt;&#10;            // Only prefill if the stored date is today or in the future&#10;            val parsed = try { dateFormat.parse(pd) } catch (_: Exception) { null }&#10;            val isPast = parsed?.time?.let { it &lt; startOfTodayMillis() } ?: true&#10;            if (!isPast) {&#10;                etPickupDate.setText(pd)&#10;                hasPrefill = true&#10;            } else {&#10;                // Clear stale past date from wizard and notify user&#10;                wizard.pickupDate = null&#10;                etPickupDate.setText(&quot;&quot;)&#10;                Toast.makeText(requireContext(), &quot;Previous pickup date was in the past. Please choose a new date.&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;        // If a time is prefilled but outside business hours, clear it (don't auto-accept invalid times)&#10;        wizard.pickupTime?.let { pt -&gt;&#10;            if (isTimeWithinBusinessHours(pt)) {&#10;                etPickupTime.setText(pt)&#10;                hasPrefill = true&#10;            } else {&#10;                // drop invalid prefills so user notices and chooses a valid time&#10;                wizard.pickupTime = null&#10;                // don't spam user with toast on fragment load, but set hint for clarity&#10;                etPickupTime.hint = &quot;Select a pickup time (08:00-17:00)&quot;&#10;            }&#10;        }&#10;        if (hasPrefill) {&#10;            pickupDetailsContainer.visibility = View.VISIBLE&#10;            // ensure date/time fields visible (XML had them gone)&#10;            etPickupDate.visibility = View.VISIBLE&#10;            etPickupTime.visibility = View.VISIBLE&#10;        }&#10;&#10;        // Initially hide or show the container depending on radio selection&#10;        when (radioGroup.checkedRadioButtonId) {&#10;            R.id.rbDropOffAtFacility -&gt; {&#10;                pickupDetailsContainer.visibility = View.GONE&#10;                etPickupDate.visibility = View.GONE&#10;                etPickupTime.visibility = View.GONE&#10;            }&#10;            R.id.rbPickupFromLocation -&gt; {&#10;                pickupDetailsContainer.visibility = View.VISIBLE&#10;                etPickupDate.visibility = View.VISIBLE&#10;                etPickupTime.visibility = View.VISIBLE&#10;            }&#10;            else -&gt; {&#10;                pickupDetailsContainer.visibility = View.GONE&#10;                etPickupDate.visibility = View.GONE&#10;                etPickupTime.visibility = View.GONE&#10;            }&#10;        }&#10;&#10;        setNextEnabled(false)&#10;&#10;        // Checkbox listener: autofill with signup address and disable editing when checked&#10;        cbUseSignupAddress.setOnCheckedChangeListener { _, isChecked -&gt;&#10;            if (isChecked) {&#10;                // If we don't yet have the saved home address, try to read from ViewModel immediately&#10;                if (savedHomeAddress.isBlank()) {&#10;                    // Will be filled by observer when profile loads; clear for now&#10;                    etPickupLocation.setText(&quot;&quot;)&#10;                } else {&#10;                    etPickupLocation.setText(savedHomeAddress)&#10;                }&#10;                etPickupLocation.isEnabled = false&#10;                etPickupLocation.isFocusable = false&#10;                // Immediately reflect selection in wizard data&#10;                activity.getWizardData().pickupLocation = if (savedHomeAddress.isNotBlank()) savedHomeAddress else activity.getWizardData().pickupLocation&#10;            } else {&#10;                // Allow user to edit a custom address&#10;                // If wizard was using the saved home address, clear it so user can provide a custom one&#10;                val wizardData = activity.getWizardData()&#10;                if (wizardData.pickupLocation == savedHomeAddress) {&#10;                    wizardData.pickupLocation = null&#10;                }&#10;                etPickupLocation.isEnabled = true&#10;                etPickupLocation.isFocusableInTouchMode = true&#10;            }&#10;            validateForm()&#10;        }&#10;&#10;        // Set up radio button listeners&#10;        radioGroup.setOnCheckedChangeListener { _, checkedId -&gt;&#10;            when (checkedId) {&#10;                R.id.rbPickupFromLocation -&gt; {&#10;                    Log.d(TAG, &quot;Selected: Pickup from location&quot;)&#10;                    Toast.makeText(requireContext(), &quot;Pickup from location selected&quot;, Toast.LENGTH_SHORT).show()&#10;                    activity.getWizardData().pickupService = PickupService.PICKUP_FROM_LOCATION&#10;                    pickupDetailsContainer.visibility = View.VISIBLE&#10;                    etPickupDate.visibility = View.VISIBLE&#10;                    etPickupTime.visibility = View.VISIBLE&#10;                    validateForm()&#10;                }&#10;                R.id.rbDropOffAtFacility -&gt; {&#10;                    Log.d(TAG, &quot;Selected: Drop off at facility&quot;)&#10;                    Toast.makeText(requireContext(), &quot;Drop off at facility selected&quot;, Toast.LENGTH_SHORT).show()&#10;                    activity.getWizardData().pickupService = PickupService.DROP_OFF_AT_FACILITY&#10;                    pickupDetailsContainer.visibility = View.GONE&#10;                    etPickupLocation.text.clear()&#10;                    etPickupDate.text.clear()&#10;                    etPickupTime.text.clear()&#10;                    etPickupDate.visibility = View.GONE&#10;                    etPickupTime.visibility = View.GONE&#10;                    // reset checkbox when hiding&#10;                    cbUseSignupAddress.isChecked = false&#10;                    // also clear saved wizard data when hiding&#10;                    val wiz = activity.getWizardData()&#10;                    wiz.pickupLocation = null&#10;                    wiz.pickupDate = null&#10;                    wiz.pickupTime = null&#10;                    validateForm()&#10;                }&#10;                else -&gt; {&#10;                    Log.d(TAG, &quot;No pickup option selected&quot;)&#10;                    setNextEnabled(false)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Re-validate when user types location or date/time&#10;        etPickupLocation.addTextChangedListener { validateForm() }&#10;        etPickupDate.addTextChangedListener { validateForm() }&#10;        etPickupTime.addTextChangedListener { /* time optional, not gating next */ }&#10;&#10;        // Ensure initial state matches any pre-selected radio button in XML&#10;        validateForm()&#10;&#10;        // Set up date picker&#10;        val datePickerListener = DatePickerDialog.OnDateSetListener { _, year, month, day -&gt;&#10;            calendar.set(Calendar.YEAR, year)&#10;            calendar.set(Calendar.MONTH, month)&#10;            calendar.set(Calendar.DAY_OF_MONTH, day)&#10;            etPickupDate.setText(dateFormat.format(calendar.time))&#10;            validateForm()&#10;        }&#10;        &#10;        etPickupDate.setOnClickListener {&#10;            val dialog = DatePickerDialog(&#10;                requireContext(),&#10;                datePickerListener,&#10;                calendar.get(Calendar.YEAR),&#10;                calendar.get(Calendar.MONTH),&#10;                calendar.get(Calendar.DAY_OF_MONTH)&#10;            )&#10;            // Disallow selecting past dates&#10;            dialog.datePicker.minDate = startOfTodayMillis()&#10;            dialog.show()&#10;        }&#10;&#10;        // Set up time picker (optional)&#10;        etPickupTime.setOnClickListener {&#10;            val hour = calendar.get(Calendar.HOUR_OF_DAY)&#10;            val minute = calendar.get(Calendar.MINUTE)&#10;            TimePickerDialog(requireContext(), { _, selHour, selMinute -&gt;&#10;                // Store in 24h HH:mm format to match backend normalization&#10;                val cal = (calendar.clone() as Calendar)&#10;                cal.set(Calendar.HOUR_OF_DAY, selHour)&#10;                cal.set(Calendar.MINUTE, selMinute)&#10;                val selected = timeFormat24.format(cal.time)&#10;                if (!isTimeWithinBusinessHours(selected)) {&#10;                    Toast.makeText(requireContext(), &quot;Pickup time must be between 08:00 and 17:00&quot;, Toast.LENGTH_SHORT).show()&#10;                    // do not set invalid time&#10;                } else {&#10;                    etPickupTime.setText(selected)&#10;                }&#10;            }, hour, minute, true).show()&#10;        }&#10;&#10;        btnNext.setOnClickListener {&#10;            val location = etPickupLocation.text.toString().trim()&#10;            val pickupDate = etPickupDate.text.toString().trim()&#10;            val pickupTime = etPickupTime.text.toString().trim().ifEmpty { null }&#10;&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; location.isEmpty()) {&#10;                etPickupLocation.error = &quot;Please enter your location&quot;&#10;                return@setOnClickListener&#10;            }&#10;            &#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; pickupDate.isEmpty()) {&#10;                etPickupDate.error = &quot;Please select a pickup date&quot;&#10;                return@setOnClickListener&#10;            }&#10;            &#10;            // Extra guard: block past dates if somehow present&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; pickupDate.isNotEmpty()) {&#10;                val parsed = try { dateFormat.parse(pickupDate) } catch (_: Exception) { null }&#10;                val isPast = parsed?.time?.let { it &lt; startOfTodayMillis() } ?: true&#10;                if (isPast) {&#10;                    etPickupDate.error = &quot;Pickup date can’t be in the past&quot;&#10;                    Toast.makeText(requireContext(), &quot;Please choose today or a future date.&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@setOnClickListener&#10;                }&#10;            }&#10;&#10;            // Validate pickup time if provided: only allow 08:00 - 17:00 for pickup service&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation &amp;&amp; pickupTime != null) {&#10;                if (!isTimeWithinBusinessHours(pickupTime)) {&#10;                    etPickupTime.error = &quot;Pickup time must be between 08:00 and 17:00&quot;&#10;                    Toast.makeText(requireContext(), &quot;Pickup time must be between 08:00 and 17:00&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@setOnClickListener&#10;                }&#10;            }&#10;&#10;            if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation) {&#10;                activity.getWizardData().pickupLocation = location&#10;            }&#10;            &#10;            // Save pickup date only if set (pickup-from-location)&#10;            if (pickupDate.isNotEmpty()) {&#10;                activity.getWizardData().pickupDate = pickupDate&#10;            } else {&#10;                activity.getWizardData().pickupDate = null&#10;            }&#10;            // Save pickup time (optional)&#10;            activity.getWizardData().pickupTime = pickupTime&#10;&#10;            activity.goToNextStep()&#10;        }&#10;    }&#10;    &#10;    private fun validateForm() {&#10;        // If user chose pickup-from-location, require both location and date; time is optional&#10;        if (radioGroup.checkedRadioButtonId == R.id.rbPickupFromLocation) {&#10;            val enabled = etPickupLocation.text.toString().trim().isNotEmpty() &amp;&amp;&#10;                    etPickupDate.text.toString().trim().isNotEmpty()&#10;            setNextEnabled(enabled)&#10;        } else if (radioGroup.checkedRadioButtonId == R.id.rbDropOffAtFacility) {&#10;            // For drop-off option, no extra inputs required – enable Next&#10;            setNextEnabled(true)&#10;        } else {&#10;            // No selection yet&#10;            setNextEnabled(false)&#10;        }&#10;    }&#10;&#10;    private fun setNextEnabled(enabled: Boolean) {&#10;        btnNext.isEnabled = enabled&#10;        btnNext.isClickable = enabled&#10;        // visually indicate disabled state&#10;        btnNext.alpha = if (enabled) 1.0f else 0.5f&#10;        Log.d(TAG, &quot;Next button enabled: $enabled&quot;)&#10;    }&#10;&#10;    private fun startOfTodayMillis(): Long {&#10;        val c = Calendar.getInstance()&#10;        c.set(Calendar.HOUR_OF_DAY, 0)&#10;        c.set(Calendar.MINUTE, 0)&#10;        c.set(Calendar.SECOND, 0)&#10;        c.set(Calendar.MILLISECOND, 0)&#10;        return c.timeInMillis&#10;    }&#10;&#10;    // Helper: validate a time string in HH:mm is within business hours (inclusive)&#10;    private fun isTimeWithinBusinessHours(timeStr: String?): Boolean {&#10;        if (timeStr.isNullOrBlank()) return false&#10;        return try {&#10;            val parsed = timeFormat24.parse(timeStr)&#10;            val cal = Calendar.getInstance()&#10;            cal.time = parsed&#10;            val hour = cal.get(Calendar.HOUR_OF_DAY)&#10;            val minute = cal.get(Calendar.MINUTE)&#10;            // allow any minute within the hour range; inclusive of start and end hours&#10;            if (hour &lt; BUSINESS_START_HOUR) return false&#10;            if (hour &gt; BUSINESS_END_HOUR) return false&#10;            // When hour == BUSINESS_END_HOUR (17), allow minutes == 0 only to enforce up-to-17:00 exactly&#10;            if (hour == BUSINESS_END_HOUR &amp;&amp; minute &gt; 0) return false&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:padding=&quot;8dp&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvConversations&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:paddingBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvEmpty&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:text=&quot;No conversations&quot;&#10;        android:visibility=&quot;gone&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>