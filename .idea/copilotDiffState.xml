<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/adapter/TrackAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/adapter/TrackAdapter.kt" />
              <option name="originalContent" value="package com.example.capstone2.adapter&#10;&#10;import android.content.Intent&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.*&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.user.ViewUserProfileActivity&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.util.StatusColorProvider&#10;&#10;class TrackAdapter(&#10;    private var requests: List&lt;Request&gt;,&#10;    private val onButtonClick: (Request, Int) -&gt; Unit,&#10;    /**&#10;     * Callback to fetch a contact number for a given customerId. Should invoke onResult&#10;     * on the main thread with the resulting contact string (e.g. actual number or &quot;Not available&quot;).&#10;     */&#10;    private val fetchContact: (customerId: Long, onResult: (String) -&gt; Unit) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;TrackAdapter.TrackViewHolder&gt;() {&#10;&#10;    inner class TrackViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        val tvRequestId: TextView = itemView.findViewById(R.id.tvRequestId)&#10;        val customerName: TextView = itemView.findViewById(R.id.tvCustomerName)&#10;        val tvSackQty: TextView = itemView.findViewById(R.id.tvSackQty)&#10;        val tvServices: TextView = itemView.findViewById(R.id.tvServices)&#10;        val tvSchedule: TextView = itemView.findViewById(R.id.tvSchedule)&#10;        val tvPickupLocation: TextView = itemView.findViewById(R.id.tvPickupLocation)&#10;        val tvDeliveryLocation: TextView = itemView.findViewById(R.id.tvDeliveryLocation)&#10;        val tvCurrentStatus: TextView = itemView.findViewById(R.id.tvCurrentStatus)&#10;        val tvPaymentAmount: TextView? = itemView.findViewById(R.id.tvPaymentAmount)&#10;        val tvPickupPreparingMessage: TextView? = itemView.findViewById(R.id.tvPickupPreparingMessage)&#10;&#10;        val rgStatusOptions: RadioGroup = itemView.findViewById(R.id.rgStatusOptions)&#10;        val rbDpickup: RadioButton = itemView.findViewById(R.id.rbDpickup)&#10;        val rbCDropoff: RadioButton = itemView.findViewById(R.id.rbCDropoff)&#10;        val rbPending: RadioButton = itemView.findViewById(R.id.rbPending)&#10;        val rbProcessing: RadioButton = itemView.findViewById(R.id.rbProcessing)&#10;        val rbOutForDelivery: RadioButton = itemView.findViewById(R.id.rbOutForDelivery)&#10;        val rbCPickup: RadioButton = itemView.findViewById(R.id.rbCPickup)&#10;        val rbMillingDone: RadioButton = itemView.findViewById(R.id.rbMillingDone)&#10;        val rbDelivered: RadioButton = itemView.findViewById(R.id.rbDelivered)&#10;&#10;        // Action buttons present in the owner item layout&#10;        val btnSubmit: Button = itemView.findViewById(R.id.btnSubmit)&#10;        val btnMore: ImageButton = itemView.findViewById(R.id.btnMore)&#10;        val btnRowMessage: Button? = itemView.findViewById(R.id.btnRowMessage)&#10;    }&#10;&#10;    // Helper to parse formatted currency strings like &quot;â‚±1,234.50&quot; safely&#10;    private fun parseAmountStringSafe(raw: String?): Double? {&#10;        if (raw.isNullOrBlank()) return null&#10;        val cleaned = raw.replace(Regex(&quot;[^0-9.,-]&quot;), &quot;&quot;).replace(&quot;,&quot;, &quot;&quot;)&#10;        return cleaned.toDoubleOrNull()&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TrackViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_track, parent, false)&#10;        return TrackViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: TrackViewHolder, position: Int) {&#10;        val req = requests[position]&#10;        val ctx = holder.itemView.context&#10;&#10;        // Show Request ID at upper-left&#10;        holder.tvRequestId.text = ctx.getString(R.string.request_id_format, req.requestID)&#10;&#10;        holder.customerName.text = req.customerName&#10;        holder.tvSackQty.text = ctx.getString(R.string.sacks_format, req.sackQuantity)&#10;        holder.tvServices.text = ctx.getString(R.string.services_format, req.serviceName)&#10;        holder.tvSchedule.text = ctx.getString(&#10;            R.string.schedule_format_owner,&#10;            req.schedule ?: ctx.getString(R.string.not_set)&#10;        )&#10;&#10;        // Hide locations in item row (shown in More dialog)&#10;        holder.tvPickupLocation.visibility = View.GONE&#10;        holder.tvDeliveryLocation.visibility = View.GONE&#10;&#10;        // Current status text and color&#10;        val currentStatusInt = try { req.statusID.toInt() } catch (_: Exception) { 0 }&#10;        val currentStatusText = getStatusText(currentStatusInt)&#10;        holder.tvCurrentStatus.text = ctx.getString(R.string.status_format, currentStatusText)&#10;&#10;        try {&#10;            val colorInt = StatusColorProvider.getColorFor(currentStatusInt)&#10;            holder.tvCurrentStatus.setTextColor(colorInt)&#10;        } catch (_: Exception) { /* ignore */ }&#10;&#10;        // NEW: Payment amount line for owner row if available&#10;        holder.tvPaymentAmount?.let { tv -&gt;&#10;            val amt = req.paymentAmount&#10;                ?: req.payment?.amount&#10;                ?: parseAmountStringSafe(req.payment?.amountString)&#10;            if (amt != null &amp;&amp; amt &gt;= 0.0) {&#10;                tv.visibility = View.VISIBLE&#10;                tv.text = ctx.getString(R.string.payment_amount_format, amt)&#10;            } else {&#10;                tv.visibility = View.GONE&#10;            }&#10;        }&#10;&#10;        // All radio buttons list&#10;        val allRadioButtons = listOf(&#10;            holder.rbDpickup, holder.rbCDropoff, holder.rbPending, holder.rbProcessing,&#10;            holder.rbOutForDelivery, holder.rbCPickup, holder.rbMillingDone, holder.rbDelivered&#10;        )&#10;&#10;        // Reset UI state&#10;        allRadioButtons.forEach { rb -&gt;&#10;            rb.visibility = View.GONE&#10;            rb.isChecked = false&#10;            rb.isEnabled = true&#10;            rb.isClickable = true&#10;            rb.setOnClickListener(null)&#10;        }&#10;        holder.rgStatusOptions.setOnCheckedChangeListener(null)&#10;        holder.rgStatusOptions.clearCheck()&#10;        holder.rgStatusOptions.visibility = View.GONE&#10;        holder.rgStatusOptions.isEnabled = false&#10;        holder.btnSubmit.visibility = View.GONE&#10;        holder.btnSubmit.isEnabled = false&#10;        holder.btnSubmit.setOnClickListener(null)&#10;        holder.btnRowMessage?.visibility = View.GONE&#10;        holder.btnRowMessage?.setOnClickListener(null)&#10;&#10;        val currentStatus = currentStatusInt&#10;&#10;        val includesPickup = req.serviceID in listOf(1L, 2L, 5L, 6L)&#10;        val includesDelivery = req.serviceID in listOf(1L, 3L, 5L, 7L)&#10;        // 12 (Milling done) should not be terminal for non-delivery services because we need to move to 7 (Waiting for customer to claim)&#10;        val terminalStatuses = setOf(8, 9, 13)&#10;&#10;        // Compute next status strictly following owner-side rules&#10;        val nextStatus: Int? = when {&#10;            currentStatus in terminalStatuses -&gt; null&#10;            // New rule: If there's no delivery and we're at Milling done, next is Waiting for customer to claim (7)&#10;            !includesDelivery &amp;&amp; currentStatus == 12 -&gt; 7&#10;            includesPickup -&gt; when (currentStatus) {&#10;                10 -&gt; null&#10;                4 -&gt; 5&#10;                5 -&gt; 12&#10;                else -&gt; null&#10;            }&#10;            else -&gt; when (currentStatus) {&#10;                10 -&gt; 3&#10;                3 -&gt; 4&#10;                4 -&gt; 5&#10;                5 -&gt; 12&#10;                else -&gt; null&#10;            }&#10;        }&#10;&#10;        // Show or hide pickup preparing message&#10;        holder.tvPickupPreparingMessage?.visibility = if (includesPickup &amp;&amp; currentStatus == 10 &amp;&amp; nextStatus == null) View.VISIBLE else View.GONE&#10;&#10;        val statusToRadioMap = mapOf(&#10;            3 to holder.rbCDropoff,&#10;            4 to holder.rbPending,&#10;            5 to holder.rbProcessing,&#10;            7 to holder.rbCPickup,&#10;            12 to holder.rbMillingDone&#10;        )&#10;&#10;        if (nextStatus != null) {&#10;            val nextRadio = statusToRadioMap[nextStatus]&#10;            nextRadio?.let { rb -&gt;&#10;                rb.visibility = View.VISIBLE&#10;                rb.isChecked = false&#10;                rb.isEnabled = true&#10;&#10;                holder.rgStatusOptions.visibility = View.VISIBLE&#10;                holder.rgStatusOptions.isEnabled = true&#10;                holder.btnSubmit.visibility = View.VISIBLE&#10;                holder.btnSubmit.isEnabled = false&#10;&#10;                rb.setOnClickListener { view -&gt;&#10;                    if (view is RadioButton) {&#10;                        view.isChecked = true&#10;                        holder.rgStatusOptions.check(view.id)&#10;                        holder.btnSubmit.isEnabled = true&#10;                        Log.d(&quot;TrackAdapter&quot;, &quot;Radio clicked for request=${req.requestID}, radioId=${view.id}&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            holder.rgStatusOptions.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                holder.btnSubmit.isEnabled = checkedId != -1&#10;            }&#10;&#10;            val radioIdToStatus = mapOf(&#10;                holder.rbCDropoff.id to 3,&#10;                holder.rbPending.id to 4,&#10;                holder.rbProcessing.id to 5,&#10;                holder.rbCPickup.id to 7,&#10;                holder.rbMillingDone.id to 12&#10;            )&#10;&#10;            holder.btnSubmit.setOnClickListener {&#10;                val checkedId = holder.rgStatusOptions.checkedRadioButtonId&#10;                val selectedStatus = radioIdToStatus[checkedId] ?: nextStatus&#10;                if (selectedStatus != null) {&#10;                    onButtonClick(req, selectedStatus)&#10;                } else {&#10;                    Toast.makeText(holder.itemView.context, R.string.submit, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;&#10;        // Row-level Message button: show only when Waiting for customer to claim (status 7)&#10;        if (currentStatus == 7) {&#10;            holder.btnRowMessage?.visibility = View.VISIBLE&#10;            holder.btnRowMessage?.setOnClickListener {&#10;                val context = holder.itemView.context&#10;                val myId = SharedPrefManager.getUserId(context)&#10;                val otherId = when {&#10;                    myId == null -&gt; req.customerID&#10;                    myId == req.ownerID -&gt; req.customerID&#10;                    else -&gt; req.customerID&#10;                }&#10;                val otherName = req.customerName&#10;                val activity = context as? androidx.fragment.app.FragmentActivity&#10;                if (activity != null) {&#10;                    try {&#10;                        val chatFrag = com.example.capstone2.customer.ChatFragment.newInstance(otherId, null, otherName)&#10;                        activity.supportFragmentManager.beginTransaction()&#10;                            .replace(R.id.flFragment, chatFrag)&#10;                            .addToBackStack(null)&#10;                            .commit()&#10;                    } catch (e: Exception) {&#10;                        Toast.makeText(context, &quot;Unable to open chat: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                } else {&#10;                    Toast.makeText(context, &quot;Cannot open chat from this context&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;&#10;        // More button shows details dialog and fetches contact&#10;        holder.btnMore.setOnClickListener {&#10;            val detailsBuilder = StringBuilder()&#10;&#10;            if (!req.pickupLocation.isNullOrEmpty()) {&#10;                detailsBuilder.append(&quot;Pickup location: ${req.pickupLocation}\n&quot;)&#10;            } else if (includesPickup) {&#10;                detailsBuilder.append(&quot;Pickup location: Not set\n&quot;)&#10;            }&#10;&#10;            if (!req.deliveryLocation.isNullOrEmpty()) {&#10;                detailsBuilder.append(&quot;Delivery location: ${req.deliveryLocation}\n&quot;)&#10;            } else if (includesDelivery) {&#10;                detailsBuilder.append(&quot;Delivery location: Not set\n&quot;)&#10;            }&#10;&#10;            detailsBuilder.append(&quot;Comment: ${if (!req.comment.isNullOrEmpty()) req.comment else &quot;None&quot;}\n&quot;)&#10;&#10;            // Create a custom dialog from layout so we can show contact and action buttons&#10;            val dialog = android.app.Dialog(ctx)&#10;            val dlgView = LayoutInflater.from(ctx).inflate(R.layout.dialog_request_details, null, false)&#10;            dialog.setContentView(dlgView)&#10;            dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)&#10;&#10;            // Find dialog views&#10;            val tvDetailCustomerName: TextView = dlgView.findViewById(R.id.tvDetailCustomerName)&#10;            val tvDetailSackQty: TextView = dlgView.findViewById(R.id.tvDetailSackQty)&#10;            val tvDetailServices: TextView = dlgView.findViewById(R.id.tvDetailServices)&#10;            val tvDetailSchedule: TextView = dlgView.findViewById(R.id.tvDetailSchedule)&#10;            val tvDetailComment: TextView = dlgView.findViewById(R.id.tvDetailComment)&#10;            val tvDetailSubmittedAt: TextView = dlgView.findViewById(R.id.tvDetailSubmittedAt)&#10;            val tvDetailContact: TextView = dlgView.findViewById(R.id.tvDetailContact)&#10;            val tvDetailPaymentAmount: TextView = dlgView.findViewById(R.id.tvDetailPaymentAmount)&#10;            val btnMsg: Button = dlgView.findViewById(R.id.btnMessage)&#10;            val btnViewProfile: Button = dlgView.findViewById(R.id.btnViewProfile)&#10;            val btnClose: Button = dlgView.findViewById(R.id.btnClose)&#10;            val tvDetailProgressLabel: TextView? = dlgView.findViewById(R.id.tvDetailProgressLabel)&#10;            val progressBarRequest: ProgressBar? = dlgView.findViewById(R.id.progressBarRequest)&#10;            tvDetailProgressLabel?.visibility = View.GONE&#10;            progressBarRequest?.visibility = View.GONE&#10;&#10;            // Populate basic fields&#10;            tvDetailCustomerName.text = ctx.getString(R.string.customer_format, req.customerName)&#10;            tvDetailSackQty.text = ctx.getString(R.string.sacks_format, req.sackQuantity)&#10;            tvDetailServices.text = ctx.getString(R.string.services_format, req.serviceName)&#10;            tvDetailSchedule.text = ctx.getString(R.string.schedule_format_owner, req.schedule ?: ctx.getString(R.string.not_set))&#10;            tvDetailComment.text = ctx.getString(R.string.comment_format, req.comment ?: &quot;None&quot;)&#10;            tvDetailSubmittedAt.text = ctx.getString(R.string.submitted_at_format, req.submittedAt ?: &quot;Unknown&quot;)&#10;&#10;            // Payment amount in dialog&#10;            val amt = req.paymentAmount&#10;                ?: req.payment?.amount&#10;                ?: parseAmountStringSafe(req.payment?.amountString)&#10;            if (amt != null &amp;&amp; amt &gt;= 0.0) {&#10;                tvDetailPaymentAmount.visibility = View.VISIBLE&#10;                tvDetailPaymentAmount.text = ctx.getString(R.string.payment_amount_format, amt)&#10;            } else {&#10;                tvDetailPaymentAmount.visibility = View.VISIBLE&#10;                tvDetailPaymentAmount.text = ctx.getString(R.string.payment_amount_not_set)&#10;            }&#10;&#10;            // Initially show either the static contact if present or a loading state and fetch&#10;            if (!req.contactNumber.isNullOrBlank()) {&#10;                tvDetailContact.visibility = View.VISIBLE&#10;                tvDetailContact.text = ctx.getString(R.string.contact_number_format, req.contactNumber)&#10;            } else {&#10;                tvDetailContact.visibility = View.VISIBLE&#10;                tvDetailContact.text = ctx.getString(R.string.contact_number_format, ctx.getString(R.string.contact_number_loading))&#10;                fetchContact(req.customerID) { finalContact -&gt;&#10;                    (ctx as? android.app.Activity)?.runOnUiThread {&#10;                        tvDetailContact.text = ctx.getString(R.string.contact_number_format, finalContact)&#10;                    } ?: run {&#10;                        tvDetailContact.text = ctx.getString(R.string.contact_number_format, finalContact)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Wire View profile button&#10;            btnViewProfile.visibility = View.VISIBLE&#10;            btnViewProfile.setOnClickListener {&#10;                try {&#10;                    val intent = Intent(ctx, ViewUserProfileActivity::class.java)&#10;                    intent.putExtra(&quot;userId&quot;, req.customerID)&#10;                    ctx.startActivity(intent)&#10;                } catch (_: Exception) { /* ignore */ }&#10;            }&#10;&#10;            // Close button&#10;            btnClose.setOnClickListener { dialog.dismiss() }&#10;&#10;            // Show Message button in dialog only when Waiting for customer to claim (status 7)&#10;            if (currentStatus == 7) {&#10;                btnMsg.visibility = View.VISIBLE&#10;                btnMsg.setOnClickListener {&#10;                    val context = dlgView.context&#10;                    val myId = SharedPrefManager.getUserId(context)&#10;                    val otherId = when {&#10;                        myId == null -&gt; req.customerID&#10;                        myId == req.ownerID -&gt; req.customerID&#10;                        else -&gt; req.customerID&#10;                    }&#10;                    val otherName = req.customerName&#10;                    val activity = context as? androidx.fragment.app.FragmentActivity&#10;                    if (activity != null) {&#10;                        try {&#10;                            val chatFrag = com.example.capstone2.customer.ChatFragment.newInstance(otherId, null, otherName)&#10;                            dialog.dismiss()&#10;                            activity.supportFragmentManager.beginTransaction()&#10;                                .replace(R.id.flFragment, chatFrag)&#10;                                .addToBackStack(null)&#10;                                .commit()&#10;                        } catch (e: Exception) {&#10;                            dialog.dismiss()&#10;                            Toast.makeText(context, &quot;Unable to open chat: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    } else {&#10;                        dialog.dismiss()&#10;                        Toast.makeText(context, &quot;Cannot open chat from this context&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            } else {&#10;                btnMsg.visibility = View.GONE&#10;            }&#10;&#10;            dialog.show()&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = requests.size&#10;&#10;    fun updateRequests(newRequests: List&lt;Request&gt;) {&#10;        this.requests = newRequests&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    private fun getStatusText(statusId: Int): String {&#10;        return when (statusId) {&#10;            1 -&gt; &quot;Subject for approval&quot;&#10;            2 -&gt; &quot;Delivery boy pickup&quot;&#10;            3 -&gt; &quot;Waiting for customer drop off&quot;&#10;            4 -&gt; &quot;Pending&quot;&#10;            5 -&gt; &quot;Processing&quot;&#10;            6 -&gt; &quot;Rider out for delivery&quot;&#10;            7 -&gt; &quot;Waiting for customer to claim&quot;&#10;            8 -&gt; &quot;Completed&quot;&#10;            9 -&gt; &quot;Rejected&quot;&#10;            10 -&gt; &quot;Request Accepted&quot;&#10;            11 -&gt; &quot;Partially Accepted&quot;&#10;            12 -&gt; &quot;Milling done&quot;&#10;            13 -&gt; &quot;Delivered&quot;&#10;            else -&gt; &quot;Unknown status&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.adapter&#10;&#10;import android.content.Intent&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.*&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.user.ViewUserProfileActivity&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.util.StatusColorProvider&#10;import com.example.capstone2.util.StatusNameProvider&#10;&#10;class TrackAdapter(&#10;    private var requests: List&lt;Request&gt;,&#10;    private val onButtonClick: (Request, Int) -&gt; Unit,&#10;    /**&#10;     * Callback to fetch a contact number for a given customerId. Should invoke onResult&#10;     * on the main thread with the resulting contact string (e.g. actual number or &quot;Not available&quot;).&#10;     */&#10;    private val fetchContact: (customerId: Long, onResult: (String) -&gt; Unit) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;TrackAdapter.TrackViewHolder&gt;() {&#10;&#10;    inner class TrackViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        val tvRequestId: TextView = itemView.findViewById(R.id.tvRequestId)&#10;        val customerName: TextView = itemView.findViewById(R.id.tvCustomerName)&#10;        val tvSackQty: TextView = itemView.findViewById(R.id.tvSackQty)&#10;        val tvServices: TextView = itemView.findViewById(R.id.tvServices)&#10;        val tvSchedule: TextView = itemView.findViewById(R.id.tvSchedule)&#10;        val tvPickupLocation: TextView = itemView.findViewById(R.id.tvPickupLocation)&#10;        val tvDeliveryLocation: TextView = itemView.findViewById(R.id.tvDeliveryLocation)&#10;        val tvCurrentStatus: TextView = itemView.findViewById(R.id.tvCurrentStatus)&#10;        val tvPaymentAmount: TextView? = itemView.findViewById(R.id.tvPaymentAmount)&#10;        val tvPickupPreparingMessage: TextView? = itemView.findViewById(R.id.tvPickupPreparingMessage)&#10;&#10;        val rgStatusOptions: RadioGroup = itemView.findViewById(R.id.rgStatusOptions)&#10;        val rbDpickup: RadioButton = itemView.findViewById(R.id.rbDpickup)&#10;        val rbCDropoff: RadioButton = itemView.findViewById(R.id.rbCDropoff)&#10;        val rbPending: RadioButton = itemView.findViewById(R.id.rbPending)&#10;        val rbProcessing: RadioButton = itemView.findViewById(R.id.rbProcessing)&#10;        val rbOutForDelivery: RadioButton = itemView.findViewById(R.id.rbOutForDelivery)&#10;        val rbCPickup: RadioButton = itemView.findViewById(R.id.rbCPickup)&#10;        val rbMillingDone: RadioButton = itemView.findViewById(R.id.rbMillingDone)&#10;        val rbDelivered: RadioButton = itemView.findViewById(R.id.rbDelivered)&#10;&#10;        // Action buttons present in the owner item layout&#10;        val btnSubmit: Button = itemView.findViewById(R.id.btnSubmit)&#10;        val btnMore: ImageButton = itemView.findViewById(R.id.btnMore)&#10;        val btnRowMessage: Button? = itemView.findViewById(R.id.btnRowMessage)&#10;    }&#10;&#10;    // Helper to parse formatted currency strings like &quot;â‚±1,234.50&quot; safely&#10;    private fun parseAmountStringSafe(raw: String?): Double? {&#10;        if (raw.isNullOrBlank()) return null&#10;        val cleaned = raw.replace(Regex(&quot;[^0-9.,-]&quot;), &quot;&quot;).replace(&quot;,&quot;, &quot;&quot;)&#10;        return cleaned.toDoubleOrNull()&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TrackViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_track, parent, false)&#10;        return TrackViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: TrackViewHolder, position: Int) {&#10;        val req = requests[position]&#10;        val ctx = holder.itemView.context&#10;&#10;        // Show Request ID at upper-left&#10;        holder.tvRequestId.text = ctx.getString(R.string.request_id_format, req.requestID)&#10;&#10;        holder.customerName.text = req.customerName&#10;        holder.tvSackQty.text = ctx.getString(R.string.sacks_format, req.sackQuantity)&#10;        holder.tvServices.text = ctx.getString(R.string.services_format, req.serviceName)&#10;        holder.tvSchedule.text = ctx.getString(&#10;            R.string.schedule_format_owner,&#10;            req.schedule ?: ctx.getString(R.string.not_set)&#10;        )&#10;&#10;        // Hide locations in item row (shown in More dialog)&#10;        holder.tvPickupLocation.visibility = View.GONE&#10;        holder.tvDeliveryLocation.visibility = View.GONE&#10;&#10;        // Current status text and color&#10;        val currentStatusInt = try { req.statusID.toInt() } catch (_: Exception) { 0 }&#10;        val currentStatusText = StatusNameProvider.getNameFor(currentStatusInt)&#10;        holder.tvCurrentStatus.text = ctx.getString(R.string.status_format, currentStatusText)&#10;&#10;        try {&#10;            val colorInt = StatusColorProvider.getColorFor(currentStatusInt)&#10;            holder.tvCurrentStatus.setTextColor(colorInt)&#10;        } catch (_: Exception) { /* ignore */ }&#10;&#10;        // NEW: Payment amount line for owner row if available&#10;        holder.tvPaymentAmount?.let { tv -&gt;&#10;            val amt = req.paymentAmount&#10;                ?: req.payment?.amount&#10;                ?: parseAmountStringSafe(req.payment?.amountString)&#10;            if (amt != null &amp;&amp; amt &gt;= 0.0) {&#10;                tv.visibility = View.VISIBLE&#10;                tv.text = ctx.getString(R.string.payment_amount_format, amt)&#10;            } else {&#10;                tv.visibility = View.GONE&#10;            }&#10;        }&#10;&#10;        // All radio buttons list&#10;        val allRadioButtons = listOf(&#10;            holder.rbDpickup, holder.rbCDropoff, holder.rbPending, holder.rbProcessing,&#10;            holder.rbOutForDelivery, holder.rbCPickup, holder.rbMillingDone, holder.rbDelivered&#10;        )&#10;&#10;        // Reset UI state&#10;        allRadioButtons.forEach { rb -&gt;&#10;            rb.visibility = View.GONE&#10;            rb.isChecked = false&#10;            rb.isEnabled = true&#10;            rb.isClickable = true&#10;            rb.setOnClickListener(null)&#10;        }&#10;        holder.rgStatusOptions.setOnCheckedChangeListener(null)&#10;        holder.rgStatusOptions.clearCheck()&#10;        holder.rgStatusOptions.visibility = View.GONE&#10;        holder.rgStatusOptions.isEnabled = false&#10;        holder.btnSubmit.visibility = View.GONE&#10;        holder.btnSubmit.isEnabled = false&#10;        holder.btnSubmit.setOnClickListener(null)&#10;        holder.btnRowMessage?.visibility = View.GONE&#10;        holder.btnRowMessage?.setOnClickListener(null)&#10;&#10;        val currentStatus = currentStatusInt&#10;&#10;        val includesPickup = req.serviceID in listOf(1L, 2L, 5L, 6L)&#10;        val includesDelivery = req.serviceID in listOf(1L, 3L, 5L, 7L)&#10;        // 12 (Milling done) should not be terminal for non-delivery services because we need to move to 7 (Waiting for customer to claim)&#10;        val terminalStatuses = setOf(8, 9, 13)&#10;&#10;        // Compute next status strictly following owner-side rules&#10;        val nextStatus: Int? = when {&#10;            currentStatus in terminalStatuses -&gt; null&#10;            // New rule: If there's no delivery and we're at Milling done, next is Waiting for customer to claim (7)&#10;            !includesDelivery &amp;&amp; currentStatus == 12 -&gt; 7&#10;            includesPickup -&gt; when (currentStatus) {&#10;                10 -&gt; null&#10;                4 -&gt; 5&#10;                5 -&gt; 12&#10;                else -&gt; null&#10;            }&#10;            else -&gt; when (currentStatus) {&#10;                10 -&gt; 3&#10;                3 -&gt; 4&#10;                4 -&gt; 5&#10;                5 -&gt; 12&#10;                else -&gt; null&#10;            }&#10;        }&#10;&#10;        // Show or hide pickup preparing message&#10;        holder.tvPickupPreparingMessage?.visibility = if (includesPickup &amp;&amp; currentStatus == 10 &amp;&amp; nextStatus == null) View.VISIBLE else View.GONE&#10;&#10;        val statusToRadioMap = mapOf(&#10;            3 to holder.rbCDropoff,&#10;            4 to holder.rbPending,&#10;            5 to holder.rbProcessing,&#10;            7 to holder.rbCPickup,&#10;            12 to holder.rbMillingDone&#10;        )&#10;&#10;        if (nextStatus != null) {&#10;            val nextRadio = statusToRadioMap[nextStatus]&#10;            nextRadio?.let { rb -&gt;&#10;                rb.visibility = View.VISIBLE&#10;                rb.isChecked = false&#10;                rb.isEnabled = true&#10;&#10;                holder.rgStatusOptions.visibility = View.VISIBLE&#10;                holder.rgStatusOptions.isEnabled = true&#10;                holder.btnSubmit.visibility = View.VISIBLE&#10;                holder.btnSubmit.isEnabled = false&#10;&#10;                rb.setOnClickListener { view -&gt;&#10;                    if (view is RadioButton) {&#10;                        view.isChecked = true&#10;                        holder.rgStatusOptions.check(view.id)&#10;                        holder.btnSubmit.isEnabled = true&#10;                        Log.d(&quot;TrackAdapter&quot;, &quot;Radio clicked for request=${req.requestID}, radioId=${view.id}&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            holder.rgStatusOptions.setOnCheckedChangeListener { _, checkedId -&gt;&#10;                holder.btnSubmit.isEnabled = checkedId != -1&#10;            }&#10;&#10;            val radioIdToStatus = mapOf(&#10;                holder.rbCDropoff.id to 3,&#10;                holder.rbPending.id to 4,&#10;                holder.rbProcessing.id to 5,&#10;                holder.rbCPickup.id to 7,&#10;                holder.rbMillingDone.id to 12&#10;            )&#10;&#10;            holder.btnSubmit.setOnClickListener {&#10;                val checkedId = holder.rgStatusOptions.checkedRadioButtonId&#10;                val selectedStatus = radioIdToStatus[checkedId] ?: nextStatus&#10;                if (selectedStatus != null) {&#10;                    onButtonClick(req, selectedStatus)&#10;                } else {&#10;                    Toast.makeText(holder.itemView.context, R.string.submit, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;&#10;        // Row-level Message button: show only when Waiting for customer to claim (status 7)&#10;        if (currentStatus == 7) {&#10;            holder.btnRowMessage?.visibility = View.VISIBLE&#10;            holder.btnRowMessage?.setOnClickListener {&#10;                val context = holder.itemView.context&#10;                val myId = SharedPrefManager.getUserId(context)&#10;                val otherId = when {&#10;                    myId == null -&gt; req.customerID&#10;                    myId == req.ownerID -&gt; req.customerID&#10;                    else -&gt; req.customerID&#10;                }&#10;                val otherName = req.customerName&#10;                val activity = context as? androidx.fragment.app.FragmentActivity&#10;                if (activity != null) {&#10;                    try {&#10;                        val chatFrag = com.example.capstone2.customer.ChatFragment.newInstance(otherId, null, otherName)&#10;                        activity.supportFragmentManager.beginTransaction()&#10;                            .replace(R.id.flFragment, chatFrag)&#10;                            .addToBackStack(null)&#10;                            .commit()&#10;                    } catch (e: Exception) {&#10;                        Toast.makeText(context, &quot;Unable to open chat: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                } else {&#10;                    Toast.makeText(context, &quot;Cannot open chat from this context&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;&#10;        // More button shows details dialog and fetches contact&#10;        holder.btnMore.setOnClickListener {&#10;            val detailsBuilder = StringBuilder()&#10;&#10;            if (!req.pickupLocation.isNullOrEmpty()) {&#10;                detailsBuilder.append(&quot;Pickup location: ${req.pickupLocation}\n&quot;)&#10;            } else if (includesPickup) {&#10;                detailsBuilder.append(&quot;Pickup location: Not set\n&quot;)&#10;            }&#10;&#10;            if (!req.deliveryLocation.isNullOrEmpty()) {&#10;                detailsBuilder.append(&quot;Delivery location: ${req.deliveryLocation}\n&quot;)&#10;            } else if (includesDelivery) {&#10;                detailsBuilder.append(&quot;Delivery location: Not set\n&quot;)&#10;            }&#10;&#10;            detailsBuilder.append(&quot;Comment: ${if (!req.comment.isNullOrEmpty()) req.comment else &quot;None&quot;}\n&quot;)&#10;&#10;            // Create a custom dialog from layout so we can show contact and action buttons&#10;            val dialog = android.app.Dialog(ctx)&#10;            val dlgView = LayoutInflater.from(ctx).inflate(R.layout.dialog_request_details, null, false)&#10;            dialog.setContentView(dlgView)&#10;            dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)&#10;&#10;            // Find dialog views&#10;            val tvDetailCustomerName: TextView = dlgView.findViewById(R.id.tvDetailCustomerName)&#10;            val tvDetailSackQty: TextView = dlgView.findViewById(R.id.tvDetailSackQty)&#10;            val tvDetailServices: TextView = dlgView.findViewById(R.id.tvDetailServices)&#10;            val tvDetailSchedule: TextView = dlgView.findViewById(R.id.tvDetailSchedule)&#10;            val tvDetailComment: TextView = dlgView.findViewById(R.id.tvDetailComment)&#10;            val tvDetailSubmittedAt: TextView = dlgView.findViewById(R.id.tvDetailSubmittedAt)&#10;            val tvDetailContact: TextView = dlgView.findViewById(R.id.tvDetailContact)&#10;            val tvDetailPaymentAmount: TextView = dlgView.findViewById(R.id.tvDetailPaymentAmount)&#10;            val btnMsg: Button = dlgView.findViewById(R.id.btnMessage)&#10;            val btnViewProfile: Button = dlgView.findViewById(R.id.btnViewProfile)&#10;            val btnClose: Button = dlgView.findViewById(R.id.btnClose)&#10;            val tvDetailProgressLabel: TextView? = dlgView.findViewById(R.id.tvDetailProgressLabel)&#10;            val progressBarRequest: ProgressBar? = dlgView.findViewById(R.id.progressBarRequest)&#10;            tvDetailProgressLabel?.visibility = View.GONE&#10;            progressBarRequest?.visibility = View.GONE&#10;&#10;            // Populate basic fields&#10;            tvDetailCustomerName.text = ctx.getString(R.string.customer_format, req.customerName)&#10;            tvDetailSackQty.text = ctx.getString(R.string.sacks_format, req.sackQuantity)&#10;            tvDetailServices.text = ctx.getString(R.string.services_format, req.serviceName)&#10;            tvDetailSchedule.text = ctx.getString(R.string.schedule_format_owner, req.schedule ?: ctx.getString(R.string.not_set))&#10;            tvDetailComment.text = ctx.getString(R.string.comment_format, req.comment ?: &quot;None&quot;)&#10;            tvDetailSubmittedAt.text = ctx.getString(R.string.submitted_at_format, req.submittedAt ?: &quot;Unknown&quot;)&#10;&#10;            // Payment amount in dialog&#10;            val amt = req.paymentAmount&#10;                ?: req.payment?.amount&#10;                ?: parseAmountStringSafe(req.payment?.amountString)&#10;            if (amt != null &amp;&amp; amt &gt;= 0.0) {&#10;                tvDetailPaymentAmount.visibility = View.VISIBLE&#10;                tvDetailPaymentAmount.text = ctx.getString(R.string.payment_amount_format, amt)&#10;            } else {&#10;                tvDetailPaymentAmount.visibility = View.VISIBLE&#10;                tvDetailPaymentAmount.text = ctx.getString(R.string.payment_amount_not_set)&#10;            }&#10;&#10;            // Initially show either the static contact if present or a loading state and fetch&#10;            if (!req.contactNumber.isNullOrBlank()) {&#10;                tvDetailContact.visibility = View.VISIBLE&#10;                tvDetailContact.text = ctx.getString(R.string.contact_number_format, req.contactNumber)&#10;            } else {&#10;                tvDetailContact.visibility = View.VISIBLE&#10;                tvDetailContact.text = ctx.getString(R.string.contact_number_format, ctx.getString(R.string.contact_number_loading))&#10;                fetchContact(req.customerID) { finalContact -&gt;&#10;                    (ctx as? android.app.Activity)?.runOnUiThread {&#10;                        tvDetailContact.text = ctx.getString(R.string.contact_number_format, finalContact)&#10;                    } ?: run {&#10;                        tvDetailContact.text = ctx.getString(R.string.contact_number_format, finalContact)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Wire View profile button&#10;            btnViewProfile.visibility = View.VISIBLE&#10;            btnViewProfile.setOnClickListener {&#10;                try {&#10;                    val intent = Intent(ctx, ViewUserProfileActivity::class.java)&#10;                    intent.putExtra(&quot;userId&quot;, req.customerID)&#10;                    ctx.startActivity(intent)&#10;                } catch (_: Exception) { /* ignore */ }&#10;            }&#10;&#10;            // Close button&#10;            btnClose.setOnClickListener { dialog.dismiss() }&#10;&#10;            // Show Message button in dialog only when Waiting for customer to claim (status 7)&#10;            if (currentStatus == 7) {&#10;                btnMsg.visibility = View.VISIBLE&#10;                btnMsg.setOnClickListener {&#10;                    val context = dlgView.context&#10;                    val myId = SharedPrefManager.getUserId(context)&#10;                    val otherId = when {&#10;                        myId == null -&gt; req.customerID&#10;                        myId == req.ownerID -&gt; req.customerID&#10;                        else -&gt; req.customerID&#10;                    }&#10;                    val otherName = req.customerName&#10;                    val activity = context as? androidx.fragment.app.FragmentActivity&#10;                    if (activity != null) {&#10;                        try {&#10;                            val chatFrag = com.example.capstone2.customer.ChatFragment.newInstance(otherId, null, otherName)&#10;                            dialog.dismiss()&#10;                            activity.supportFragmentManager.beginTransaction()&#10;                                .replace(R.id.flFragment, chatFrag)&#10;                                .addToBackStack(null)&#10;                                .commit()&#10;                        } catch (e: Exception) {&#10;                            dialog.dismiss()&#10;                            Toast.makeText(context, &quot;Unable to open chat: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    } else {&#10;                        dialog.dismiss()&#10;                        Toast.makeText(context, &quot;Cannot open chat from this context&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            } else {&#10;                btnMsg.visibility = View.GONE&#10;            }&#10;&#10;            dialog.show()&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = requests.size&#10;&#10;    fun updateRequests(newRequests: List&lt;Request&gt;) {&#10;        this.requests = newRequests&#10;        notifyDataSetChanged()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/service/NotificationService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/service/NotificationService.kt" />
              <option name="originalContent" value="package com.example.capstone2.service&#10;&#10;import android.content.Context&#10;import com.example.capstone2.data.models.CreateRequest&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.NotificationRepository&#10;import com.example.capstone2.util.NotificationUtils&#10;import com.example.capstone2.repository.SharedPrefManager&#10;&#10;/**&#10; * Service for handling app notifications&#10; */&#10;class NotificationService(&#10;    private val context: Context,&#10;    private val notificationRepository: NotificationRepository&#10;) {&#10;    // Minor use to avoid 'never used' warnings while keeping the repository available for future network saves&#10;    init {&#10;        @Suppress(&quot;UNUSED_VARIABLE&quot;)&#10;        val _repoRef = notificationRepository&#10;    }&#10;&#10;    /**&#10;     * Send a notification when a customer creates a new request&#10;     */&#10;    fun notifyOwnerNewRequest(request: CreateRequest) {&#10;        // Show local notification to owner&#10;        val title = &quot;New Request&quot;&#10;        val message = &quot;New service request received for ${'$'}{request.sackQuantity} sacks&quot;&#10;&#10;        // Only show local notification if the developer flag is enabled. Default: false&#10;        if (shouldShowLocalNotifications()) {&#10;            NotificationUtils.showNotification(&#10;                context,&#10;                generateNotificationId(),&#10;                title,&#10;                message&#10;            )&#10;        }&#10;&#10;        // Also save to server (simulated since we don't have an endpoint)&#10;        // This would typically be handled by a server push notification&#10;    }&#10;&#10;    /**&#10;     * Send a notification when an owner accepts a request&#10;     */&#10;    fun notifyCustomerRequestAccepted(request: Request) {&#10;        val title = &quot;Request Accepted&quot;&#10;        val message = &quot;Your request #${'$'}{request.requestID} has been accepted&quot;&#10;&#10;        if (shouldShowLocalNotifications()) {&#10;            NotificationUtils.showNotification(&#10;                context,&#10;                generateNotificationId(),&#10;                title,&#10;                message&#10;            )&#10;        }&#10;&#10;        // Also save to server (simulated since we don't have an endpoint)&#10;    }&#10;&#10;    /**&#10;     * Send a notification when an owner updates a request status&#10;     */&#10;    fun notifyCustomerStatusUpdate(request: Request, newStatusID: Int) {&#10;        val statusText = getStatusText(newStatusID)&#10;&#10;        val title = &quot;Request Status Updated&quot;&#10;        val message = &quot;Your request #${'$'}{request.requestID} status changed to: $statusText&quot;&#10;&#10;        if (shouldShowLocalNotifications()) {&#10;            NotificationUtils.showNotification(&#10;                context,&#10;                generateNotificationId(),&#10;                title,&#10;                message&#10;            )&#10;        }&#10;&#10;        // Also save to server (simulated since we don't have an endpoint)&#10;    }&#10;&#10;    /**&#10;     * Generate a unique notification ID&#10;     */&#10;    private fun generateNotificationId(): Int {&#10;        return (System.currentTimeMillis() % 10000).toInt()&#10;    }&#10;&#10;    /**&#10;     * Get text description for status ID&#10;     */&#10;    private fun getStatusText(statusId: Int): String {&#10;        return when (statusId) {&#10;            1 -&gt; &quot;Subject for approval&quot;&#10;            2 -&gt; &quot;Delivery boy pickup&quot;&#10;            3 -&gt; &quot;Waiting for customer drop off&quot;&#10;            4 -&gt; &quot;Pending&quot;&#10;            5 -&gt; &quot;Processing&quot;&#10;            6 -&gt; &quot;Rider out for delivery&quot;&#10;            7 -&gt; &quot;Waiting for customer pickup&quot;&#10;            8 -&gt; &quot;Completed&quot;&#10;            9 -&gt; &quot;Rejected&quot;&#10;            10 -&gt; &quot;Request Accepted&quot;&#10;            11 -&gt; &quot;Partially Accepted&quot;&#10;            12 -&gt; &quot;Milling done&quot;&#10;            else -&gt; &quot;Unknown status&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check a shared preference flag to determine whether to show local notifications.&#10;     * This prevents duplicate notifications when server push notifications (Pusher Beams) are used.&#10;     * Default is false.&#10;     */&#10;    private fun shouldShowLocalNotifications(): Boolean {&#10;        return SharedPrefManager.isForceLocalNotificationsEnabled(context)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.service&#10;&#10;import android.content.Context&#10;import com.example.capstone2.data.models.CreateRequest&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.NotificationRepository&#10;import com.example.capstone2.util.NotificationUtils&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.util.StatusNameProvider&#10;&#10;/**&#10; * Service for handling app notifications&#10; */&#10;class NotificationService(&#10;    private val context: Context,&#10;    private val notificationRepository: NotificationRepository&#10;) {&#10;    // Minor use to avoid 'never used' warnings while keeping the repository available for future network saves&#10;    init {&#10;        @Suppress(&quot;UNUSED_VARIABLE&quot;)&#10;        val _repoRef = notificationRepository&#10;    }&#10;&#10;    /**&#10;     * Send a notification when a customer creates a new request&#10;     */&#10;    fun notifyOwnerNewRequest(request: CreateRequest) {&#10;        // Show local notification to owner&#10;        val title = &quot;New Request&quot;&#10;        val message = &quot;New service request received for ${request.sackQuantity} sacks&quot;&#10;&#10;        // Only show local notification if the developer flag is enabled. Default: false&#10;        if (shouldShowLocalNotifications()) {&#10;            NotificationUtils.showNotification(&#10;                context,&#10;                generateNotificationId(),&#10;                title,&#10;                message&#10;            )&#10;        }&#10;&#10;        // Also save to server (simulated since we don't have an endpoint)&#10;        // This would typically be handled by a server push notification&#10;    }&#10;&#10;    /**&#10;     * Send a notification when an owner accepts a request&#10;     */&#10;    fun notifyCustomerRequestAccepted(request: Request) {&#10;        val title = &quot;Request Accepted&quot;&#10;        val message = &quot;Your request #${request.requestID} has been accepted&quot;&#10;&#10;        if (shouldShowLocalNotifications()) {&#10;            NotificationUtils.showNotification(&#10;                context,&#10;                generateNotificationId(),&#10;                title,&#10;                message&#10;            )&#10;        }&#10;&#10;        // Also save to server (simulated since we don't have an endpoint)&#10;    }&#10;&#10;    /**&#10;     * Send a notification when an owner updates a request status&#10;     */&#10;    fun notifyCustomerStatusUpdate(request: Request, newStatusID: Int) {&#10;        val statusText = StatusNameProvider.getNameFor(newStatusID)&#10;&#10;        val title = &quot;Request Status Updated&quot;&#10;        val message = &quot;Your request #${request.requestID} status changed to: $statusText&quot;&#10;&#10;        if (shouldShowLocalNotifications()) {&#10;            NotificationUtils.showNotification(&#10;                context,&#10;                generateNotificationId(),&#10;                title,&#10;                message&#10;            )&#10;        }&#10;&#10;        // Also save to server (simulated since we don't have an endpoint)&#10;    }&#10;&#10;    /**&#10;     * Generate a unique notification ID&#10;     */&#10;    private fun generateNotificationId(): Int {&#10;        return (System.currentTimeMillis() % 10000).toInt()&#10;    }&#10;&#10;    /**&#10;     * Check a shared preference flag to determine whether to show local notifications.&#10;     * This prevents duplicate notifications when server push notifications (Pusher Beams) are used.&#10;     * Default is false.&#10;     */&#10;    private fun shouldShowLocalNotifications(): Boolean {&#10;        return SharedPrefManager.isForceLocalNotificationsEnabled(context)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/util/StatusNameProvider.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/util/StatusNameProvider.kt" />
              <option name="updatedContent" value="package com.example.capstone2.util&#10;&#10;/**&#10; * Centralized provider for statusId -&gt; human-readable name.&#10; * Keep this in sync with server-side friendlyStatusLabel().&#10; */&#10;object StatusNameProvider {&#10;    fun getNameFor(statusId: Int): String = when (statusId) {&#10;        1 -&gt; &quot;Subject for approval&quot;&#10;        2 -&gt; &quot;Delivery boy pickup&quot;&#10;        3 -&gt; &quot;Waiting for customer drop off&quot;&#10;        4 -&gt; &quot;Pending&quot;&#10;        5 -&gt; &quot;Processing&quot;&#10;        6 -&gt; &quot;Rider out for delivery&quot;&#10;        7 -&gt; &quot;Waiting for customer to claim&quot;&#10;        8 -&gt; &quot;Completed&quot;&#10;        9 -&gt; &quot;Rejected&quot;&#10;        10 -&gt; &quot;Request Accepted&quot;&#10;        11 -&gt; &quot;Partially Accepted&quot;&#10;        12 -&gt; &quot;Milling done&quot;&#10;        13 -&gt; &quot;Delivered&quot;&#10;        else -&gt; &quot;Unknown status #$statusId&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/viewmodel/OwnerRequestViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/viewmodel/OwnerRequestViewModel.kt" />
              <option name="originalContent" value="package com.example.capstone2.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.service.NotificationServiceFactory&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;class OwnerRequestViewModel(&#10;    private val repository: RequestRepository,&#10;    application: Application&#10;) : AndroidViewModel(application) {&#10;&#10;    private val _ownerRequests = MutableLiveData&lt;List&lt;Request&gt;&gt;()&#10;    val ownerRequests: LiveData&lt;List&lt;Request&gt;&gt; = _ownerRequests&#10;    &#10;    // Track loading state&#10;    private val _isLoading = MutableLiveData&lt;Boolean&gt;()&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    fun fetchOwnerRequests() {&#10;        _isLoading.value = true&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Fetching owner requests&quot;)&#10;                val response = repository.getOwnerRequests()&#10;                &#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val requests = response.body()!!.requests&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Fetched ${requests.size} requests successfully&quot;)&#10;                    // Enrich with payment amounts when missing&#10;                    val enriched = try {&#10;                        repository.enrichPaymentAmounts(requests)&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;OwnerRequestViewModel&quot;, &quot;enrichPaymentAmounts failed: ${e.message}&quot;)&#10;                        requests&#10;                    }&#10;                    _ownerRequests.value = enriched&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to fetch requests: ${response.code()} ${response.message()}&quot;)&#10;                    _ownerRequests.value = emptyList()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error fetching requests&quot;, e)&#10;                _ownerRequests.value = emptyList()&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun acceptRequest(request: Request, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Accepting request ID: ${request.requestID}&quot;)&#10;                val response = repository.acceptRequest(request.requestID)&#10;                &#10;                if (response.isSuccessful) {&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Successfully accepted request&quot;)&#10;                    &#10;                    // Update the status of the request in the list&#10;                    val updatedList = _ownerRequests.value?.map { existingRequest -&gt;&#10;                        if (existingRequest.requestID == request.requestID) {&#10;                            existingRequest.copy(statusID = 10)  // Set status to Accepted (10)&#10;                        } else {&#10;                            existingRequest&#10;                        }&#10;                    }&#10;                    &#10;                    // Update the LiveData with the modified list&#10;                    updatedList?.let {&#10;                        _ownerRequests.value = it&#10;                    }&#10;                    &#10;                    // Send notification to customer&#10;                    val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                    notificationService.notifyCustomerRequestAccepted(request)&#10;                    &#10;                    onSuccess()&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to accept request: ${response.code()} ${response.message()}&quot;)&#10;                    onError(&quot;Failed to accept request. Please try again.&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error accepting request&quot;, e)&#10;                onError(&quot;Error: ${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun rejectRequest(request: Request, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Rejecting request ID: ${request.requestID}&quot;)&#10;                val response = repository.rejectRequest(request.requestID)&#10;                &#10;                if (response.isSuccessful) {&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Successfully rejected request&quot;)&#10;                    &#10;                    // Remove the rejected request from the list or update its status&#10;                    val updatedList = _ownerRequests.value?.filter { existingRequest -&gt;&#10;                        existingRequest.requestID != request.requestID&#10;                    }&#10;                    &#10;                    // Update the LiveData with the modified list&#10;                    updatedList?.let {&#10;                        _ownerRequests.value = it&#10;                    }&#10;                    &#10;                    // Send status update notification (rejected)&#10;                    val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                    notificationService.notifyCustomerStatusUpdate(request, 9) // 9 = Rejected&#10;                    &#10;                    onSuccess()&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to reject request: ${response.code()} ${response.message()}&quot;)&#10;                    onError(&quot;Failed to reject request. Please try again.&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error rejecting request&quot;, e)&#10;                onError(&quot;Error: ${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateStatus(requestID: Long, newStatusID: Int, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Updating request ID: $requestID to status: $newStatusID&quot;)&#10;                val response = repository.updateRequestStatus(requestID, newStatusID)&#10;                &#10;                if (response.isSuccessful) {&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Successfully updated request status&quot;)&#10;                    &#10;                    // Update the status of the request in the list&#10;                    val updatedList = _ownerRequests.value?.map { existingRequest -&gt;&#10;                        if (existingRequest.requestID == requestID) {&#10;                            existingRequest.copy(statusID = newStatusID)&#10;                        } else {&#10;                            existingRequest&#10;                        }&#10;                    }&#10;                    &#10;                    // Update the LiveData with the modified list&#10;                    updatedList?.let {&#10;                        _ownerRequests.value = it&#10;                    }&#10;                    &#10;                    // Find the request in our list&#10;                    val request = _ownerRequests.value?.find { it.requestID == requestID }&#10;                    &#10;                    // Send notification to customer about status update&#10;                    request?.let {&#10;                        val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                        notificationService.notifyCustomerStatusUpdate(it, newStatusID)&#10;                    }&#10;                    &#10;                    onSuccess()&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to update status: ${response.code()} ${response.message()}&quot;)&#10;                    onError(&quot;Failed to update status&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error updating request status&quot;, e)&#10;                onError(&quot;Error: ${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // NEW: Set payment amount then update status in one flow&#10;    fun setPaymentAmountThenUpdateStatus(&#10;        requestID: Long,&#10;        amount: Double,&#10;        newStatusID: Int,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Setting amount=$amount for request=$requestID then updating status to $newStatusID&quot;)&#10;                val setResp = repository.setPaymentAmount(requestID, amount)&#10;                if (!setResp.isSuccessful) {&#10;                    val msg = buildServerErrorMessage(setResp, fallback = &quot;Failed to set payment amount (${setResp.code()})&quot;)&#10;                    onError(msg)&#10;                    return@launch&#10;                }&#10;&#10;                // Optimistically update local list with the new amount so UI reflects immediately&#10;                _ownerRequests.value = _ownerRequests.value?.map { existing -&gt;&#10;                    if (existing.requestID == requestID) existing.copy(paymentAmount = amount) else existing&#10;                }&#10;&#10;                // Now update status&#10;                val updResp = repository.updateRequestStatus(requestID, newStatusID)&#10;                if (updResp.isSuccessful) {&#10;                    // Update cached list&#10;                    val updatedList = _ownerRequests.value?.map { existingRequest -&gt;&#10;                        if (existingRequest.requestID == requestID) existingRequest.copy(statusID = newStatusID) else existingRequest&#10;                    }&#10;                    updatedList?.let { _ownerRequests.value = it }&#10;&#10;                    // Notify&#10;                    val request = _ownerRequests.value?.find { it.requestID == requestID }&#10;                    request?.let {&#10;                        val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                        notificationService.notifyCustomerStatusUpdate(it, newStatusID)&#10;                    }&#10;                    onSuccess()&#10;                } else {&#10;                    val msg = buildServerErrorMessage(updResp, fallback = &quot;Failed to update status after setting amount (${updResp.code()})&quot;)&#10;                    onError(msg)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error setting amount then updating status&quot;, e)&#10;                onError(&quot;${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Build a concise message from server error body if available&#10;    private fun buildServerErrorMessage(resp: retrofit2.Response&lt;*&gt;, fallback: String): String {&#10;        return try {&#10;            val err = resp.errorBody()?.string()?.trim()&#10;            if (!err.isNullOrEmpty()) {&#10;                // Try to extract a top-level &quot;message&quot; if it's JSON&#10;                val msg = try {&#10;                    val obj = com.google.gson.JsonParser.parseString(err).asJsonObject&#10;                    when {&#10;                        obj.has(&quot;message&quot;) -&gt; obj.get(&quot;message&quot;).asString&#10;                        obj.has(&quot;error&quot;) -&gt; obj.get(&quot;error&quot;).asString&#10;                        else -&gt; null&#10;                    }&#10;                } catch (_: Exception) { null }&#10;                msg?.takeIf { it.isNotBlank() } ?: (&quot;${fallback}: ${err.take(200)}&quot;)&#10;            } else fallback&#10;        } catch (_: Exception) {&#10;            fallback&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get text description for status ID&#10;     */&#10;    private fun getStatusText(statusId: Int): String {&#10;        return when (statusId) {&#10;            1 -&gt; &quot;Subject for approval&quot;&#10;            2 -&gt; &quot;Delivery boy pickup&quot;&#10;            3 -&gt; &quot;Waiting for customer drop off&quot;&#10;            4 -&gt; &quot;Pending&quot;&#10;            5 -&gt; &quot;Processing&quot;&#10;            6 -&gt; &quot;Rider out for delivery&quot;&#10;            7 -&gt; &quot;Waiting for customer pickup&quot;&#10;            8 -&gt; &quot;Completed&quot;&#10;            9 -&gt; &quot;Rejected&quot;&#10;            10 -&gt; &quot;Request Accepted&quot;&#10;            11 -&gt; &quot;Partially Accepted&quot;&#10;            12 -&gt; &quot;Milling done&quot;&#10;            13 -&gt; &quot;Delivered&quot;&#10;            else -&gt; &quot;Unknown status&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.capstone2.data.models.Request&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.service.NotificationServiceFactory&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;class OwnerRequestViewModel(&#10;    private val repository: RequestRepository,&#10;    application: Application&#10;) : AndroidViewModel(application) {&#10;&#10;    private val _ownerRequests = MutableLiveData&lt;List&lt;Request&gt;&gt;()&#10;    val ownerRequests: LiveData&lt;List&lt;Request&gt;&gt; = _ownerRequests&#10;    &#10;    // Track loading state&#10;    private val _isLoading = MutableLiveData&lt;Boolean&gt;()&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    fun fetchOwnerRequests() {&#10;        _isLoading.value = true&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Fetching owner requests&quot;)&#10;                val response = repository.getOwnerRequests()&#10;                &#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val requests = response.body()!!.requests&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Fetched ${requests.size} requests successfully&quot;)&#10;                    // Enrich with payment amounts when missing&#10;                    val enriched = try {&#10;                        repository.enrichPaymentAmounts(requests)&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;OwnerRequestViewModel&quot;, &quot;enrichPaymentAmounts failed: ${e.message}&quot;)&#10;                        requests&#10;                    }&#10;                    _ownerRequests.value = enriched&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to fetch requests: ${response.code()} ${response.message()}&quot;)&#10;                    _ownerRequests.value = emptyList()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error fetching requests&quot;, e)&#10;                _ownerRequests.value = emptyList()&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun acceptRequest(request: Request, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Accepting request ID: ${request.requestID}&quot;)&#10;                val response = repository.acceptRequest(request.requestID)&#10;                &#10;                if (response.isSuccessful) {&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Successfully accepted request&quot;)&#10;                    &#10;                    // Update the status of the request in the list&#10;                    val updatedList = _ownerRequests.value?.map { existingRequest -&gt;&#10;                        if (existingRequest.requestID == request.requestID) {&#10;                            existingRequest.copy(statusID = 10)  // Set status to Accepted (10)&#10;                        } else {&#10;                            existingRequest&#10;                        }&#10;                    }&#10;                    &#10;                    // Update the LiveData with the modified list&#10;                    updatedList?.let {&#10;                        _ownerRequests.value = it&#10;                    }&#10;                    &#10;                    // Send notification to customer&#10;                    val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                    notificationService.notifyCustomerRequestAccepted(request)&#10;                    &#10;                    onSuccess()&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to accept request: ${response.code()} ${response.message()}&quot;)&#10;                    onError(&quot;Failed to accept request. Please try again.&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error accepting request&quot;, e)&#10;                onError(&quot;Error: ${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun rejectRequest(request: Request, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Rejecting request ID: ${request.requestID}&quot;)&#10;                val response = repository.rejectRequest(request.requestID)&#10;                &#10;                if (response.isSuccessful) {&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Successfully rejected request&quot;)&#10;                    &#10;                    // Remove the rejected request from the list or update its status&#10;                    val updatedList = _ownerRequests.value?.filter { existingRequest -&gt;&#10;                        existingRequest.requestID != request.requestID&#10;                    }&#10;                    &#10;                    // Update the LiveData with the modified list&#10;                    updatedList?.let {&#10;                        _ownerRequests.value = it&#10;                    }&#10;                    &#10;                    // Send status update notification (rejected)&#10;                    val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                    notificationService.notifyCustomerStatusUpdate(request, 9) // 9 = Rejected&#10;                    &#10;                    onSuccess()&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to reject request: ${response.code()} ${response.message()}&quot;)&#10;                    onError(&quot;Failed to reject request. Please try again.&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error rejecting request&quot;, e)&#10;                onError(&quot;Error: ${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateStatus(requestID: Long, newStatusID: Int, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Updating request ID: $requestID to status: $newStatusID&quot;)&#10;                val response = repository.updateRequestStatus(requestID, newStatusID)&#10;                &#10;                if (response.isSuccessful) {&#10;                    Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Successfully updated request status&quot;)&#10;                    &#10;                    // Update the status of the request in the list&#10;                    val updatedList = _ownerRequests.value?.map { existingRequest -&gt;&#10;                        if (existingRequest.requestID == requestID) {&#10;                            existingRequest.copy(statusID = newStatusID)&#10;                        } else {&#10;                            existingRequest&#10;                        }&#10;                    }&#10;                    &#10;                    // Update the LiveData with the modified list&#10;                    updatedList?.let {&#10;                        _ownerRequests.value = it&#10;                    }&#10;                    &#10;                    // Find the request in our list&#10;                    val request = _ownerRequests.value?.find { it.requestID == requestID }&#10;                    &#10;                    // Send notification to customer about status update&#10;                    request?.let {&#10;                        val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                        notificationService.notifyCustomerStatusUpdate(it, newStatusID)&#10;                    }&#10;                    &#10;                    onSuccess()&#10;                } else {&#10;                    Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Failed to update status: ${response.code()} ${response.message()}&quot;)&#10;                    onError(&quot;Failed to update status&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error updating request status&quot;, e)&#10;                onError(&quot;Error: ${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // NEW: Set payment amount then update status in one flow&#10;    fun setPaymentAmountThenUpdateStatus(&#10;        requestID: Long,&#10;        amount: Double,&#10;        newStatusID: Int,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;OwnerRequestViewModel&quot;, &quot;Setting amount=$amount for request=$requestID then updating status to $newStatusID&quot;)&#10;                val setResp = repository.setPaymentAmount(requestID, amount)&#10;                if (!setResp.isSuccessful) {&#10;                    val msg = buildServerErrorMessage(setResp, fallback = &quot;Failed to set payment amount (${setResp.code()})&quot;)&#10;                    onError(msg)&#10;                    return@launch&#10;                }&#10;&#10;                // Optimistically update local list with the new amount so UI reflects immediately&#10;                _ownerRequests.value = _ownerRequests.value?.map { existing -&gt;&#10;                    if (existing.requestID == requestID) existing.copy(paymentAmount = amount) else existing&#10;                }&#10;&#10;                // Now update status&#10;                val updResp = repository.updateRequestStatus(requestID, newStatusID)&#10;                if (updResp.isSuccessful) {&#10;                    // Update cached list&#10;                    val updatedList = _ownerRequests.value?.map { existingRequest -&gt;&#10;                        if (existingRequest.requestID == requestID) existingRequest.copy(statusID = newStatusID) else existingRequest&#10;                    }&#10;                    updatedList?.let { _ownerRequests.value = it }&#10;&#10;                    // Notify&#10;                    val request = _ownerRequests.value?.find { it.requestID == requestID }&#10;                    request?.let {&#10;                        val notificationService = NotificationServiceFactory.getInstance(getApplication())&#10;                        notificationService.notifyCustomerStatusUpdate(it, newStatusID)&#10;                    }&#10;                    onSuccess()&#10;                } else {&#10;                    val msg = buildServerErrorMessage(updResp, fallback = &quot;Failed to update status after setting amount (${updResp.code()})&quot;)&#10;                    onError(msg)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;OwnerRequestViewModel&quot;, &quot;Error setting amount then updating status&quot;, e)&#10;                onError(&quot;${e.localizedMessage}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Build a concise message from server error body if available&#10;    private fun buildServerErrorMessage(resp: retrofit2.Response&lt;*&gt;, fallback: String): String {&#10;        return try {&#10;            val err = resp.errorBody()?.string()?.trim()&#10;            if (!err.isNullOrEmpty()) {&#10;                // Try to extract a top-level &quot;message&quot; if it's JSON&#10;                val msg = try {&#10;                    val obj = com.google.gson.JsonParser.parseString(err).asJsonObject&#10;                    when {&#10;                        obj.has(&quot;message&quot;) -&gt; obj.get(&quot;message&quot;).asString&#10;                        obj.has(&quot;error&quot;) -&gt; obj.get(&quot;error&quot;).asString&#10;                        else -&gt; null&#10;                    }&#10;                } catch (_: Exception) { null }&#10;                msg?.takeIf { it.isNotBlank() } ?: (&quot;${fallback}: ${err.take(200)}&quot;)&#10;            } else fallback&#10;        } catch (_: Exception) {&#10;            fallback&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:padding=&quot;8dp&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvConversations&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:paddingBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvEmpty&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:text=&quot;No conversations&quot;&#10;        android:visibility=&quot;gone&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>