<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/owner/OwnerFragmentHistory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/owner/OwnerFragmentHistory.kt" />
              <option name="originalContent" value="package com.example.capstone2.owner&#10;&#10;import android.content.ContentValues&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.Environment&#10;import android.provider.MediaStore&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.OwnerHistoryAdapter&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.viewmodel.OwnerHistoryViewModel&#10;import com.example.capstone2.viewmodel.OwnerHistoryViewModelFactory&#10;import com.example.capstone2.data.models.Request&#10;import android.Manifest&#10;import android.graphics.Canvas&#10;import android.graphics.Paint&#10;import android.graphics.Typeface&#10;import android.graphics.pdf.PdfDocument&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.OutputStream&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;// Material date range picker + java.time for robust date handling&#10;import com.google.android.material.datepicker.MaterialDatePicker&#10;import java.time.Instant&#10;import java.time.ZoneOffset&#10;&#10;class OwnerFragmentHistory : Fragment(R.layout.owner_fragment_history) {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var historyAdapter: OwnerHistoryAdapter&#10;    private lateinit var historyViewModel: OwnerHistoryViewModel&#10;    private lateinit var tvNoHistory: TextView&#10;&#10;    // Filter action buttons&#10;    private lateinit var btnFilter: Button&#10;    private lateinit var btnClear: Button&#10;    private lateinit var btnExportPdf: Button&#10;&#10;    // Filter state (selected range + queries)&#10;    private var selectedStartDate: Date? = null&#10;    private var selectedEndDate: Date? = null&#10;    private var selectedNameQuery: String? = null&#10;    private var selectedIdQuery: String? = null&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.UK)&#10;&#10;    // Local copy for filtering&#10;    private var allCompletedRequests: List&lt;Request&gt; = emptyList()&#10;&#10;    // Permission handling for export&#10;    private val REQ_WRITE_EXTERNAL_STORAGE = 201&#10;    private var pendingExportAfterPermission = false&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        recyclerView = view.findViewById(R.id.recyclerViewOwnerHistory)&#10;        tvNoHistory = view.findViewById(R.id.tvNoHistory)&#10;&#10;        // Buttons&#10;        btnFilter = view.findViewById(R.id.btnFilterHistoryOwner)&#10;        btnClear = view.findViewById(R.id.btnClearFilterOwner)&#10;        btnExportPdf = view.findViewById(R.id.btnExportPdfOwner)&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        historyAdapter = OwnerHistoryAdapter(emptyList())&#10;        recyclerView.adapter = historyAdapter&#10;&#10;        // Get token from shared preferences&#10;        val token = SharedPrefManager.getAuthToken(requireContext())&#10;&#10;        if (token.isNullOrEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Missing auth token&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Setup ViewModel&#10;        val authedApiService = ApiClient.getApiService { token }&#10;        val repository = RequestRepository(authedApiService)&#10;        val viewModelFactory = OwnerHistoryViewModelFactory(repository)&#10;        historyViewModel = ViewModelProvider(this, viewModelFactory)[OwnerHistoryViewModel::class.java]&#10;&#10;        // Observe completed requests&#10;        historyViewModel.completedRequests.observe(viewLifecycleOwner) { requests -&gt;&#10;            Log.d(&quot;OwnerHistory&quot;, &quot;Received ${requests.size} completed requests in fragment&quot;)&#10;&#10;            if (requests.isNotEmpty()) {&#10;                allCompletedRequests = requests&#10;                applyFilters() // respect any existing filters&#10;                recyclerView.visibility = View.VISIBLE&#10;                tvNoHistory.visibility = View.GONE&#10;            } else {&#10;                allCompletedRequests = emptyList()&#10;                recyclerView.visibility = View.GONE&#10;                tvNoHistory.visibility = View.VISIBLE&#10;                Toast.makeText(requireContext(), getString(R.string.no_completed_requests), Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        // Fetch owner's completed requests&#10;        fetchCompletedRequests()&#10;&#10;        // Filter button opens a filter options menu&#10;        btnFilter.setOnClickListener {&#10;            showFilterMenu()&#10;        }&#10;&#10;        btnClear.setOnClickListener {&#10;            selectedStartDate = null&#10;            selectedEndDate = null&#10;            selectedNameQuery = null&#10;            selectedIdQuery = null&#10;            historyAdapter.updateRequests(allCompletedRequests)&#10;            if (allCompletedRequests.isEmpty()) {&#10;                recyclerView.visibility = View.GONE&#10;                tvNoHistory.visibility = View.VISIBLE&#10;            } else {&#10;                recyclerView.visibility = View.VISIBLE&#10;                tvNoHistory.visibility = View.GONE&#10;            }&#10;        }&#10;&#10;        // Export button&#10;        btnExportPdf.setOnClickListener {&#10;            maybeExportPdf()&#10;        }&#10;    }&#10;&#10;    private fun showFilterMenu() {&#10;        val options = arrayOf(&#10;            getString(R.string.filter_by_date_range),&#10;            getString(R.string.filter_by_customer_name),&#10;            getString(R.string.filter_by_request_id)&#10;        )&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(getString(R.string.action_filter))&#10;            .setItems(options) { _, which -&gt;&#10;                when (which) {&#10;                    0 -&gt; openDateRangePicker()&#10;                    1 -&gt; promptForCustomerName()&#10;                    2 -&gt; promptForRequestId()&#10;                }&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun openDateRangePicker() {&#10;        val picker = MaterialDatePicker.Builder.dateRangePicker()&#10;            .setTitleText(getString(R.string.filter_by_date_range))&#10;            .build()&#10;&#10;        picker.addOnPositiveButtonClickListener { selection -&gt;&#10;            if (selection != null) {&#10;                val startMillis = selection.first&#10;                val endMillis = selection.second&#10;                if (startMillis != null &amp;&amp; endMillis != null) {&#10;                    // Normalize to start of day UTC to align with yyyy-MM-dd parsing&#10;                    selectedStartDate = Date.from(&#10;                        Instant.ofEpochMilli(startMillis).atZone(ZoneOffset.UTC)&#10;                            .toLocalDate().atStartOfDay().toInstant(ZoneOffset.UTC)&#10;                    )&#10;                    selectedEndDate = Date.from(&#10;                        Instant.ofEpochMilli(endMillis).atZone(ZoneOffset.UTC)&#10;                            .toLocalDate().atStartOfDay().toInstant(ZoneOffset.UTC)&#10;                    )&#10;                    applyFilters()&#10;                }&#10;            }&#10;        }&#10;        picker.show(parentFragmentManager, &quot;owner_history_date_range&quot;)&#10;    }&#10;&#10;    private fun promptForCustomerName() {&#10;        val input = EditText(requireContext()).apply {&#10;            hint = getString(R.string.enter_customer_name)&#10;            inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_FLAG_CAP_WORDS&#10;            setText(selectedNameQuery ?: &quot;&quot;)&#10;        }&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(getString(R.string.filter_by_customer_name))&#10;            .setView(input)&#10;            .setPositiveButton(R.string.apply) { _, _ -&gt;&#10;                selectedNameQuery = input.text.toString().trim().ifBlank { null }&#10;                applyFilters()&#10;            }&#10;            .setNegativeButton(R.string.cancel, null)&#10;            .setNeutralButton(R.string.action_clear) { _, _ -&gt;&#10;                selectedNameQuery = null&#10;                applyFilters()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun promptForRequestId() {&#10;        val input = EditText(requireContext()).apply {&#10;            hint = getString(R.string.enter_request_id)&#10;            inputType = InputType.TYPE_CLASS_NUMBER&#10;            setText(selectedIdQuery ?: &quot;&quot;)&#10;        }&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(getString(R.string.filter_by_request_id))&#10;            .setView(input)&#10;            .setPositiveButton(R.string.apply) { _, _ -&gt;&#10;                selectedIdQuery = input.text.toString().trim().ifBlank { null }&#10;                applyFilters()&#10;            }&#10;            .setNegativeButton(R.string.cancel, null)&#10;            .setNeutralButton(R.string.action_clear) { _, _ -&gt;&#10;                selectedIdQuery = null&#10;                applyFilters()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun fetchCompletedRequests() {&#10;        historyViewModel.fetchCompletedRequests()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        fetchCompletedRequests()&#10;    }&#10;&#10;    private fun parseDateFromRequest(request: Request): Date? {&#10;        val candidates = listOf(request.submittedAt, request.pickupDate, request.deliveryDate, request.dateUpdated, request.schedule)&#10;        for (c in candidates) {&#10;            if (!c.isNullOrBlank()) {&#10;                val s = if (c.length &gt;= 10) c.substring(0, 10) else c&#10;                try {&#10;                    return dateFormat.parse(s)&#10;                } catch (_: Exception) {&#10;                    // ignore&#10;                }&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    private fun applyFilters() {&#10;        val startDate = selectedStartDate&#10;        val endDate = selectedEndDate&#10;        val nameQuery = selectedNameQuery&#10;        val idQuery = selectedIdQuery&#10;&#10;        if (startDate == null &amp;&amp; endDate == null &amp;&amp; nameQuery == null &amp;&amp; idQuery == null) {&#10;            historyAdapter.updateRequests(allCompletedRequests)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val filtered = allCompletedRequests.filter { req -&gt;&#10;                val d = parseDateFromRequest(req)&#10;                val afterStart = startDate?.let { date -&gt; d?.let { !it.before(date) } ?: false } ?: true&#10;                val beforeEnd = endDate?.let { date -&gt; d?.let { !it.after(date) } ?: false } ?: true&#10;                val nameOk = nameQuery?.let { q -&gt; req.customerName.contains(q, ignoreCase = true) } ?: true&#10;                val idOk = idQuery?.let { q -&gt; req.requestID.toString().contains(q, ignoreCase = true) } ?: true&#10;                afterStart &amp;&amp; beforeEnd &amp;&amp; nameOk &amp;&amp; idOk&#10;            }&#10;&#10;            historyAdapter.updateRequests(filtered)&#10;&#10;            recyclerView.visibility = if (filtered.isEmpty()) View.GONE else View.VISIBLE&#10;            tvNoHistory.visibility = if (filtered.isEmpty()) View.VISIBLE else View.GONE&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;OwnerHistory&quot;, &quot;Error applying filters&quot;, e)&#10;            Toast.makeText(requireContext(), &quot;Invalid filters&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun maybeExportPdf() {&#10;        val currentList = historyAdapter.getRequests()&#10;        if (currentList.isEmpty()) {&#10;            Toast.makeText(requireContext(), getString(R.string.export_pdf_empty), Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) {&#10;            val hasPermission = ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED&#10;            if (!hasPermission) {&#10;                pendingExportAfterPermission = true&#10;                requestPermissions(arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), REQ_WRITE_EXTERNAL_STORAGE)&#10;                Toast.makeText(requireContext(), getString(R.string.storage_permission_required), Toast.LENGTH_SHORT).show()&#10;                return&#10;            }&#10;        }&#10;        exportPdf(currentList)&#10;    }&#10;&#10;    private fun exportPdf(requests: List&lt;Request&gt;) {&#10;        try {&#10;            val sdfFile = SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault())&#10;            val fileName = &quot;owner_history_${sdfFile.format(Date())}.pdf&quot;&#10;&#10;            // Build PDF document&#10;            val doc = PdfDocument()&#10;            val pageWidth = 595 // A4 width in points (approx)&#10;            val pageHeight = 842 // A4 height in points (approx)&#10;&#10;            val titlePaint = Paint().apply {&#10;                isAntiAlias = true&#10;                textSize = 18f&#10;                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;            }&#10;            val headerPaint = Paint().apply {&#10;                isAntiAlias = true&#10;                textSize = 12f&#10;                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;            }&#10;            val textPaint = Paint().apply {&#10;                isAntiAlias = true&#10;                textSize = 11f&#10;            }&#10;            val linePaint = Paint().apply {&#10;                strokeWidth = 1f&#10;            }&#10;&#10;            // Layout metrics&#10;            val leftMargin = 36f&#10;            val rightMargin = 36f&#10;            val topMargin = 48f&#10;            val bottomMargin = 48f&#10;            val contentWidth = pageWidth - leftMargin - rightMargin&#10;&#10;            // Column widths as percentages of content width. Sum ~= 1.0f&#10;            val colPercents = floatArrayOf(&#10;                0.08f, // ID&#10;                0.24f, // Customer (wider)&#10;                0.33f, // Service (widest)&#10;                0.13f, // Date (slightly smaller)&#10;                0.07f, // Sacks (narrow)&#10;                0.15f  // Amount&#10;            )&#10;            val colWidths = colPercents.map { it * contentWidth }&#10;            val colLefts = FloatArray(colWidths.size)&#10;            var acc = leftMargin&#10;            for (i in colWidths.indices) {&#10;                colLefts[i] = acc&#10;                acc += colWidths[i]&#10;            }&#10;&#10;            fun ellipsizeToWidth(text: String, paint: Paint, maxWidth: Float): String {&#10;                if (maxWidth &lt;= 0f) return &quot;&quot;&#10;                if (paint.measureText(text) &lt;= maxWidth) return text&#10;                val ellipsis = &quot;…&quot;&#10;                val ellWidth = paint.measureText(ellipsis)&#10;                val limit = maxWidth - ellWidth&#10;                if (limit &lt;= 0f) return ellipsis&#10;                var low = 0&#10;                var high = text.length&#10;                var best = 0&#10;                while (low &lt;= high) {&#10;                    val mid = (low + high) / 2&#10;                    val w = paint.measureText(text, 0, mid)&#10;                    if (w &lt;= limit) {&#10;                        best = mid&#10;                        low = mid + 1&#10;                    } else high = mid - 1&#10;                }&#10;                return if (best &lt;= 0) ellipsis else text.substring(0, best) + ellipsis&#10;            }&#10;&#10;            fun drawTextInColumn(canvas: Canvas, raw: String, colIndex: Int, alignRight: Boolean, paint: Paint, baselineY: Float) {&#10;                val colLeft = colLefts[colIndex]&#10;                val colWidth = colWidths[colIndex]&#10;                val text = ellipsizeToWidth(raw, paint, colWidth - 4f)&#10;                val x = if (alignRight) colLeft + colWidth - paint.measureText(text) - 2f else colLeft + 2f&#10;                canvas.drawText(text, x, baselineY, paint)&#10;            }&#10;&#10;            var pageNumber = 1&#10;            var y = 0f&#10;            lateinit var currentPage: PdfDocument.Page&#10;            lateinit var canvas: Canvas&#10;&#10;            fun startNewPage() {&#10;                val pageInfo = PdfDocument.PageInfo.Builder(pageWidth, pageHeight, pageNumber).create()&#10;                currentPage = doc.startPage(pageInfo)&#10;                canvas = currentPage.canvas&#10;                y = topMargin&#10;                // Title&#10;                canvas.drawText(&quot;Capstone – Owner Transaction History&quot;, leftMargin, y, titlePaint)&#10;                y += 26f&#10;                // Header&#10;                val headers = arrayOf(&quot;ID&quot;, &quot;Customer&quot;, &quot;Service&quot;, &quot;Date&quot;, &quot;Sacks&quot;, &quot;Amount&quot;)&#10;                for (i in headers.indices) {&#10;                    val rightAlign = (i &gt;= 4)&#10;                    drawTextInColumn(canvas, headers[i], i, rightAlign, headerPaint, y)&#10;                }&#10;                y += 6f&#10;                canvas.drawLine(leftMargin, y, pageWidth - rightMargin, y, linePaint)&#10;                y += 12f&#10;            }&#10;&#10;            startNewPage()&#10;&#10;            for (req in requests) {&#10;                if (y &gt; pageHeight - bottomMargin) {&#10;                    doc.finishPage(currentPage)&#10;                    pageNumber++&#10;                    startNewPage()&#10;                }&#10;                val idStr = req.requestID.toString()&#10;                val custStr = req.customerName&#10;                val svcStr = req.serviceName&#10;                val dateStr = req.dateUpdated?.let { if (it.length &gt;= 10) it.substring(0,10) else it }&#10;                    ?: req.deliveryDate?.let { if (it.length &gt;= 10) it.substring(0,10) else it }&#10;                    ?: req.submittedAt?.let { if (it.length &gt;= 10) it.substring(0,10) else it }&#10;                    ?: &quot;&quot;&#10;                val sacksStr = req.sackQuantity.toString()&#10;                val amt: Double? = req.paymentAmount ?: req.payment?.amount ?: req.payment?.amountString?.toDoubleOrNull()&#10;                val amtStr = if (amt != null) &quot;₱&quot; + String.format(Locale.getDefault(), &quot;%.2f&quot;, amt) else &quot;-&quot;&#10;&#10;                // Draw row&#10;                drawTextInColumn(canvas, idStr, 0, false, textPaint, y)&#10;                drawTextInColumn(canvas, custStr, 1, false, textPaint, y)&#10;                drawTextInColumn(canvas, svcStr, 2, false, textPaint, y)&#10;                drawTextInColumn(canvas, dateStr, 3, false, textPaint, y)&#10;                drawTextInColumn(canvas, sacksStr, 4, true, textPaint, y)&#10;                drawTextInColumn(canvas, amtStr, 5, true, textPaint, y)&#10;&#10;                y += 20f // slightly more vertical spacing per row&#10;            }&#10;&#10;            // Close last page&#10;            doc.finishPage(currentPage)&#10;&#10;            // Save to storage&#10;            val outputStream: OutputStream?&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                val resolver = requireContext().contentResolver&#10;                val contentValues = ContentValues().apply {&#10;                    put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)&#10;                    put(MediaStore.MediaColumns.MIME_TYPE, &quot;application/pdf&quot;)&#10;                    put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS + &quot;/Capstone&quot;)&#10;                }&#10;                val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)&#10;                val savedUri = resolver.insert(collection, contentValues)&#10;                outputStream = savedUri?.let { resolver.openOutputStream(it) }&#10;            } else {&#10;                val downloads = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)&#10;                val dir = File(downloads, &quot;Capstone&quot;).apply { if (!exists()) mkdirs() }&#10;                val outFile = File(dir, fileName)&#10;                outputStream = FileOutputStream(outFile)&#10;            }&#10;&#10;            outputStream.use { os -&gt;&#10;                if (os == null) throw IllegalStateException(&quot;No output stream available&quot;)&#10;                doc.writeTo(os)&#10;            }&#10;            doc.close()&#10;&#10;            val shownName = fileName&#10;            Toast.makeText(requireContext(), getString(R.string.export_pdf_success, shownName), Toast.LENGTH_LONG).show()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;OwnerHistory&quot;, &quot;Failed to export PDF&quot;, e)&#10;            Toast.makeText(requireContext(), getString(R.string.export_pdf_error), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == REQ_WRITE_EXTERNAL_STORAGE) {&#10;            val granted = grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED&#10;            if (granted &amp;&amp; pendingExportAfterPermission) {&#10;                pendingExportAfterPermission = false&#10;                val list = historyAdapter.getRequests()&#10;                if (list.isNotEmpty()) exportPdf(list)&#10;            } else {&#10;                pendingExportAfterPermission = false&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.owner&#10;&#10;import android.content.ContentValues&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.Environment&#10;import android.provider.MediaStore&#10;import android.text.InputType&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.OwnerHistoryAdapter&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.RequestRepository&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.viewmodel.OwnerHistoryViewModel&#10;import com.example.capstone2.viewmodel.OwnerHistoryViewModelFactory&#10;import com.example.capstone2.data.models.Request&#10;import android.Manifest&#10;import android.graphics.Canvas&#10;import android.graphics.Paint&#10;import android.graphics.Typeface&#10;import android.graphics.pdf.PdfDocument&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.OutputStream&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;// Material date range picker + java.time for robust date handling&#10;import com.google.android.material.datepicker.MaterialDatePicker&#10;import java.time.Instant&#10;import java.time.ZoneOffset&#10;&#10;class OwnerFragmentHistory : Fragment(R.layout.owner_fragment_history) {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var historyAdapter: OwnerHistoryAdapter&#10;    private lateinit var historyViewModel: OwnerHistoryViewModel&#10;    private lateinit var tvNoHistory: TextView&#10;&#10;    // Filter action buttons&#10;    private lateinit var btnFilter: Button&#10;    private lateinit var btnClear: Button&#10;    private lateinit var btnExportPdf: Button&#10;&#10;    // Filter state (selected range + queries)&#10;    private var selectedStartDate: Date? = null&#10;    private var selectedEndDate: Date? = null&#10;    private var selectedNameQuery: String? = null&#10;    private var selectedIdQuery: String? = null&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.UK)&#10;&#10;    // Local copy for filtering&#10;    private var allCompletedRequests: List&lt;Request&gt; = emptyList()&#10;&#10;    // Permission handling for export&#10;    private val REQ_WRITE_EXTERNAL_STORAGE = 201&#10;    private var pendingExportAfterPermission = false&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        recyclerView = view.findViewById(R.id.recyclerViewOwnerHistory)&#10;        tvNoHistory = view.findViewById(R.id.tvNoHistory)&#10;&#10;        // Buttons&#10;        btnFilter = view.findViewById(R.id.btnFilterHistoryOwner)&#10;        btnClear = view.findViewById(R.id.btnClearFilterOwner)&#10;        btnExportPdf = view.findViewById(R.id.btnExportPdfOwner)&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        historyAdapter = OwnerHistoryAdapter(emptyList())&#10;        recyclerView.adapter = historyAdapter&#10;&#10;        // Get token from shared preferences&#10;        val token = SharedPrefManager.getAuthToken(requireContext())&#10;&#10;        if (token.isNullOrEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Missing auth token&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Setup ViewModel&#10;        val authedApiService = ApiClient.getApiService { token }&#10;        val repository = RequestRepository(authedApiService)&#10;        val viewModelFactory = OwnerHistoryViewModelFactory(repository)&#10;        historyViewModel = ViewModelProvider(this, viewModelFactory)[OwnerHistoryViewModel::class.java]&#10;&#10;        // Observe completed requests&#10;        historyViewModel.completedRequests.observe(viewLifecycleOwner) { requests -&gt;&#10;            Log.d(&quot;OwnerHistory&quot;, &quot;Received ${requests.size} completed requests in fragment&quot;)&#10;&#10;            if (requests.isNotEmpty()) {&#10;                allCompletedRequests = requests&#10;                applyFilters() // respect any existing filters&#10;                recyclerView.visibility = View.VISIBLE&#10;                tvNoHistory.visibility = View.GONE&#10;            } else {&#10;                allCompletedRequests = emptyList()&#10;                recyclerView.visibility = View.GONE&#10;                tvNoHistory.visibility = View.VISIBLE&#10;                Toast.makeText(requireContext(), getString(R.string.no_completed_requests), Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        // Fetch owner's completed requests&#10;        fetchCompletedRequests()&#10;&#10;        // Filter button opens a filter options menu&#10;        btnFilter.setOnClickListener {&#10;            showFilterMenu()&#10;        }&#10;&#10;        btnClear.setOnClickListener {&#10;            selectedStartDate = null&#10;            selectedEndDate = null&#10;            selectedNameQuery = null&#10;            selectedIdQuery = null&#10;            historyAdapter.updateRequests(allCompletedRequests)&#10;            if (allCompletedRequests.isEmpty()) {&#10;                recyclerView.visibility = View.GONE&#10;                tvNoHistory.visibility = View.VISIBLE&#10;            } else {&#10;                recyclerView.visibility = View.VISIBLE&#10;                tvNoHistory.visibility = View.GONE&#10;            }&#10;        }&#10;&#10;        // Export button&#10;        btnExportPdf.setOnClickListener {&#10;            maybeExportPdf()&#10;        }&#10;    }&#10;&#10;    private fun showFilterMenu() {&#10;        val options = arrayOf(&#10;            getString(R.string.filter_by_date_range),&#10;            getString(R.string.filter_by_customer_name),&#10;            getString(R.string.filter_by_request_id)&#10;        )&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(getString(R.string.action_filter))&#10;            .setItems(options) { _, which -&gt;&#10;                when (which) {&#10;                    0 -&gt; openDateRangePicker()&#10;                    1 -&gt; promptForCustomerName()&#10;                    2 -&gt; promptForRequestId()&#10;                }&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun openDateRangePicker() {&#10;        val picker = MaterialDatePicker.Builder.dateRangePicker()&#10;            .setTitleText(getString(R.string.filter_by_date_range))&#10;            .build()&#10;&#10;        picker.addOnPositiveButtonClickListener { selection -&gt;&#10;            if (selection != null) {&#10;                val startMillis = selection.first&#10;                val endMillis = selection.second&#10;                if (startMillis != null &amp;&amp; endMillis != null) {&#10;                    // Normalize to start of day UTC to align with yyyy-MM-dd parsing&#10;                    selectedStartDate = Date.from(&#10;                        Instant.ofEpochMilli(startMillis).atZone(ZoneOffset.UTC)&#10;                            .toLocalDate().atStartOfDay().toInstant(ZoneOffset.UTC)&#10;                    )&#10;                    selectedEndDate = Date.from(&#10;                        Instant.ofEpochMilli(endMillis).atZone(ZoneOffset.UTC)&#10;                            .toLocalDate().atStartOfDay().toInstant(ZoneOffset.UTC)&#10;                    )&#10;                    applyFilters()&#10;                }&#10;            }&#10;        }&#10;        picker.show(parentFragmentManager, &quot;owner_history_date_range&quot;)&#10;    }&#10;&#10;    private fun promptForCustomerName() {&#10;        val input = EditText(requireContext()).apply {&#10;            hint = getString(R.string.enter_customer_name)&#10;            inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_FLAG_CAP_WORDS&#10;            setText(selectedNameQuery ?: &quot;&quot;)&#10;        }&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(getString(R.string.filter_by_customer_name))&#10;            .setView(input)&#10;            .setPositiveButton(R.string.apply) { _, _ -&gt;&#10;                selectedNameQuery = input.text.toString().trim().ifBlank { null }&#10;                applyFilters()&#10;            }&#10;            .setNegativeButton(R.string.cancel, null)&#10;            .setNeutralButton(R.string.action_clear) { _, _ -&gt;&#10;                selectedNameQuery = null&#10;                applyFilters()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun promptForRequestId() {&#10;        val input = EditText(requireContext()).apply {&#10;            hint = getString(R.string.enter_request_id)&#10;            inputType = InputType.TYPE_CLASS_NUMBER&#10;            setText(selectedIdQuery ?: &quot;&quot;)&#10;        }&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(getString(R.string.filter_by_request_id))&#10;            .setView(input)&#10;            .setPositiveButton(R.string.apply) { _, _ -&gt;&#10;                selectedIdQuery = input.text.toString().trim().ifBlank { null }&#10;                applyFilters()&#10;            }&#10;            .setNegativeButton(R.string.cancel, null)&#10;            .setNeutralButton(R.string.action_clear) { _, _ -&gt;&#10;                selectedIdQuery = null&#10;                applyFilters()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun fetchCompletedRequests() {&#10;        historyViewModel.fetchCompletedRequests()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        fetchCompletedRequests()&#10;    }&#10;&#10;    private fun parseDateFromRequest(request: Request): Date? {&#10;        val candidates = listOf(request.submittedAt, request.pickupDate, request.deliveryDate, request.dateUpdated, request.schedule)&#10;        for (c in candidates) {&#10;            if (!c.isNullOrBlank()) {&#10;                val s = if (c.length &gt;= 10) c.substring(0, 10) else c&#10;                try {&#10;                    return dateFormat.parse(s)&#10;                } catch (_: Exception) {&#10;                    // ignore&#10;                }&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    private fun applyFilters() {&#10;        val startDate = selectedStartDate&#10;        val endDate = selectedEndDate&#10;        val nameQuery = selectedNameQuery&#10;        val idQuery = selectedIdQuery&#10;&#10;        if (startDate == null &amp;&amp; endDate == null &amp;&amp; nameQuery == null &amp;&amp; idQuery == null) {&#10;            historyAdapter.updateRequests(allCompletedRequests)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val filtered = allCompletedRequests.filter { req -&gt;&#10;                val d = parseDateFromRequest(req)&#10;                val afterStart = startDate?.let { date -&gt; d?.let { !it.before(date) } ?: false } ?: true&#10;                val beforeEnd = endDate?.let { date -&gt; d?.let { !it.after(date) } ?: false } ?: true&#10;                val nameOk = nameQuery?.let { q -&gt; req.customerName.contains(q, ignoreCase = true) } ?: true&#10;                val idOk = idQuery?.let { q -&gt; req.requestID.toString().contains(q, ignoreCase = true) } ?: true&#10;                afterStart &amp;&amp; beforeEnd &amp;&amp; nameOk &amp;&amp; idOk&#10;            }&#10;&#10;            historyAdapter.updateRequests(filtered)&#10;&#10;            recyclerView.visibility = if (filtered.isEmpty()) View.GONE else View.VISIBLE&#10;            tvNoHistory.visibility = if (filtered.isEmpty()) View.VISIBLE else View.GONE&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;OwnerHistory&quot;, &quot;Error applying filters&quot;, e)&#10;            Toast.makeText(requireContext(), &quot;Invalid filters&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun maybeExportPdf() {&#10;        val currentList = historyAdapter.getRequests()&#10;        if (currentList.isEmpty()) {&#10;            Toast.makeText(requireContext(), getString(R.string.export_pdf_empty), Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) {&#10;            val hasPermission = ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED&#10;            if (!hasPermission) {&#10;                pendingExportAfterPermission = true&#10;                requestPermissions(arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), REQ_WRITE_EXTERNAL_STORAGE)&#10;                Toast.makeText(requireContext(), getString(R.string.storage_permission_required), Toast.LENGTH_SHORT).show()&#10;                return&#10;            }&#10;        }&#10;        exportPdf(currentList)&#10;    }&#10;&#10;    private fun exportPdf(requests: List&lt;Request&gt;) {&#10;        try {&#10;            val sdfFile = SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault())&#10;            val fileName = &quot;owner_history_${sdfFile.format(Date())}.pdf&quot;&#10;&#10;            // Build PDF document&#10;            val doc = PdfDocument()&#10;            val pageWidth = 595 // A4 width in points (approx)&#10;            val pageHeight = 842 // A4 height in points (approx)&#10;&#10;            val titlePaint = Paint().apply {&#10;                isAntiAlias = true&#10;                textSize = 18f&#10;                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;            }&#10;            val headerPaint = Paint().apply {&#10;                isAntiAlias = true&#10;                textSize = 12f&#10;                typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;            }&#10;            val textPaint = Paint().apply {&#10;                isAntiAlias = true&#10;                textSize = 11f&#10;            }&#10;            val linePaint = Paint().apply {&#10;                strokeWidth = 1f&#10;            }&#10;&#10;            // Layout metrics&#10;            val leftMargin = 36f&#10;            val rightMargin = 36f&#10;            val topMargin = 48f&#10;            val bottomMargin = 48f&#10;            val contentWidth = pageWidth - leftMargin - rightMargin&#10;&#10;            // Column widths as percentages of content width. Sum ~= 1.0f&#10;            val colPercents = floatArrayOf(&#10;                0.08f, // ID&#10;                0.24f, // Customer (wider)&#10;                0.33f, // Service (widest)&#10;                0.13f, // Date (slightly smaller)&#10;                0.07f, // Sacks (narrow)&#10;                0.15f  // Amount&#10;            )&#10;            val colWidths = colPercents.map { it * contentWidth }&#10;            val colLefts = FloatArray(colWidths.size)&#10;            var acc = leftMargin&#10;            for (i in colWidths.indices) {&#10;                colLefts[i] = acc&#10;                acc += colWidths[i]&#10;            }&#10;&#10;            fun ellipsizeToWidth(text: String, paint: Paint, maxWidth: Float): String {&#10;                if (maxWidth &lt;= 0f) return &quot;&quot;&#10;                if (paint.measureText(text) &lt;= maxWidth) return text&#10;                val ellipsis = &quot;…&quot;&#10;                val ellWidth = paint.measureText(ellipsis)&#10;                val limit = maxWidth - ellWidth&#10;                if (limit &lt;= 0f) return ellipsis&#10;                var low = 0&#10;                var high = text.length&#10;                var best = 0&#10;                while (low &lt;= high) {&#10;                    val mid = (low + high) / 2&#10;                    val w = paint.measureText(text, 0, mid)&#10;                    if (w &lt;= limit) {&#10;                        best = mid&#10;                        low = mid + 1&#10;                    } else high = mid - 1&#10;                }&#10;                return if (best &lt;= 0) ellipsis else text.substring(0, best) + ellipsis&#10;            }&#10;&#10;            fun drawTextInColumn(canvas: Canvas, raw: String, colIndex: Int, alignRight: Boolean, paint: Paint, baselineY: Float) {&#10;                val colLeft = colLefts[colIndex]&#10;                val colWidth = colWidths[colIndex]&#10;                val text = ellipsizeToWidth(raw, paint, colWidth - 4f)&#10;                val x = if (alignRight) colLeft + colWidth - paint.measureText(text) - 2f else colLeft + 2f&#10;                canvas.drawText(text, x, baselineY, paint)&#10;            }&#10;&#10;            var pageNumber = 1&#10;            var y = 0f&#10;            lateinit var currentPage: PdfDocument.Page&#10;            lateinit var canvas: Canvas&#10;&#10;            fun startNewPage() {&#10;                val pageInfo = PdfDocument.PageInfo.Builder(pageWidth, pageHeight, pageNumber).create()&#10;                currentPage = doc.startPage(pageInfo)&#10;                canvas = currentPage.canvas&#10;                y = topMargin&#10;                // Title&#10;                canvas.drawText(&quot;Capstone – Owner Transaction History&quot;, leftMargin, y, titlePaint)&#10;                y += 26f&#10;                // Header&#10;                val headers = arrayOf(&quot;ID&quot;, &quot;Customer&quot;, &quot;Service&quot;, &quot;Date&quot;, &quot;Sacks&quot;, &quot;Amount&quot;)&#10;                for (i in headers.indices) {&#10;                    val rightAlign = (i &gt;= 4)&#10;                    drawTextInColumn(canvas, headers[i], i, rightAlign, headerPaint, y)&#10;                }&#10;                y += 6f&#10;                canvas.drawLine(leftMargin, y, pageWidth - rightMargin, y, linePaint)&#10;                y += 12f&#10;            }&#10;&#10;            startNewPage()&#10;&#10;            // Track running total of amounts&#10;            var totalAmount = 0.0&#10;&#10;            for (req in requests) {&#10;                if (y &gt; pageHeight - bottomMargin) {&#10;                    doc.finishPage(currentPage)&#10;                    pageNumber++&#10;                    startNewPage()&#10;                }&#10;                val idStr = req.requestID.toString()&#10;                val custStr = req.customerName&#10;                val svcStr = req.serviceName&#10;                val dateStr = req.dateUpdated?.let { if (it.length &gt;= 10) it.substring(0,10) else it }&#10;                    ?: req.deliveryDate?.let { if (it.length &gt;= 10) it.substring(0,10) else it }&#10;                    ?: req.submittedAt?.let { if (it.length &gt;= 10) it.substring(0,10) else it }&#10;                    ?: &quot;&quot;&#10;                val sacksStr = req.sackQuantity.toString()&#10;                val amt: Double? = req.paymentAmount ?: req.payment?.amount ?: req.payment?.amountString?.toDoubleOrNull()&#10;                val amtStr = if (amt != null) &quot;₱&quot; + String.format(Locale.getDefault(), &quot;%.2f&quot;, amt) else &quot;-&quot;&#10;&#10;                // Accumulate total if amount is present&#10;                if (amt != null) totalAmount += amt&#10;&#10;                // Draw row&#10;                drawTextInColumn(canvas, idStr, 0, false, textPaint, y)&#10;                drawTextInColumn(canvas, custStr, 1, false, textPaint, y)&#10;                drawTextInColumn(canvas, svcStr, 2, false, textPaint, y)&#10;                drawTextInColumn(canvas, dateStr, 3, false, textPaint, y)&#10;                drawTextInColumn(canvas, sacksStr, 4, true, textPaint, y)&#10;                drawTextInColumn(canvas, amtStr, 5, true, textPaint, y)&#10;&#10;                y += 20f // slightly more vertical spacing per row&#10;            }&#10;&#10;            // Ensure there's space for total section; if not, start a new page&#10;            val spaceNeededForTotal = 28f&#10;            if (y + spaceNeededForTotal &gt; pageHeight - bottomMargin) {&#10;                doc.finishPage(currentPage)&#10;                pageNumber++&#10;                startNewPage()&#10;            }&#10;&#10;            // Draw separator and TOTAL row&#10;            canvas.drawLine(leftMargin, y, pageWidth - rightMargin, y, linePaint)&#10;            y += 14f&#10;            drawTextInColumn(canvas, &quot;TOTAL&quot;, 4, true, headerPaint, y)&#10;            val totalStr = &quot;₱&quot; + String.format(Locale.getDefault(), &quot;%.2f&quot;, totalAmount)&#10;            drawTextInColumn(canvas, totalStr, 5, true, headerPaint, y)&#10;            y += 6f&#10;&#10;            // Close last page&#10;            doc.finishPage(currentPage)&#10;&#10;            // Save to storage&#10;            val outputStream: OutputStream?&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                val resolver = requireContext().contentResolver&#10;                val contentValues = ContentValues().apply {&#10;                    put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)&#10;                    put(MediaStore.MediaColumns.MIME_TYPE, &quot;application/pdf&quot;)&#10;                    put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS + &quot;/Capstone&quot;)&#10;                }&#10;                val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)&#10;                val savedUri = resolver.insert(collection, contentValues)&#10;                outputStream = savedUri?.let { resolver.openOutputStream(it) }&#10;            } else {&#10;                val downloads = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)&#10;                val dir = File(downloads, &quot;Capstone&quot;).apply { if (!exists()) mkdirs() }&#10;                val outFile = File(dir, fileName)&#10;                outputStream = FileOutputStream(outFile)&#10;            }&#10;&#10;            outputStream.use { os -&gt;&#10;                if (os == null) throw IllegalStateException(&quot;No output stream available&quot;)&#10;                doc.writeTo(os)&#10;            }&#10;            doc.close()&#10;&#10;            val shownName = fileName&#10;            Toast.makeText(requireContext(), getString(R.string.export_pdf_success, shownName), Toast.LENGTH_LONG).show()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;OwnerHistory&quot;, &quot;Failed to export PDF&quot;, e)&#10;            Toast.makeText(requireContext(), getString(R.string.export_pdf_error), Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == REQ_WRITE_EXTERNAL_STORAGE) {&#10;            val granted = grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED&#10;            if (granted &amp;&amp; pendingExportAfterPermission) {&#10;                pendingExportAfterPermission = false&#10;                val list = historyAdapter.getRequests()&#10;                if (list.isNotEmpty()) exportPdf(list)&#10;            } else {&#10;                pendingExportAfterPermission = false&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:padding=&quot;8dp&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvConversations&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:paddingBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvEmpty&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:text=&quot;No conversations&quot;&#10;        android:visibility=&quot;gone&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>