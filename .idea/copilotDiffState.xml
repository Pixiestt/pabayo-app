<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/adapter/ConversationsAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/adapter/ConversationsAdapter.kt" />
              <option name="originalContent" value="package com.example.capstone2.adapter&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10; import androidx.core.graphics.toColorInt&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.data.models.Conversation&#10;&#10;class ConversationsAdapter(private val onClick: (Conversation) -&gt; Unit) : ListAdapter&lt;Conversation, ConversationsAdapter.VH&gt;(Diff()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {&#10;        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_conversation, parent, false)&#10;        return VH(v, onClick)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: VH, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    class VH(itemView: View, val onClick: (Conversation) -&gt; Unit) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvPartner: TextView? = itemView.findViewById(R.id.tvPartner)&#10;        private val tvLast: TextView? = itemView.findViewById(R.id.tvLastMessage)&#10;        private val tvTime: TextView? = itemView.findViewById(R.id.tvTime)&#10;        private val tvUnread: TextView? = itemView.findViewById(R.id.tvUnread)&#10;&#10;        fun bind(c: Conversation) {&#10;            tvPartner?.text = c.partnerName ?: &quot;User ${c.partnerID}&quot;&#10;            tvLast?.text = c.lastMessage ?: &quot;&quot;&#10;            tvTime?.text = c.lastMessageAt ?: &quot;&quot;&#10;            if (c.unreadCount &gt; 0) {&#10;                tvUnread?.visibility = View.VISIBLE&#10;                tvUnread?.text = c.unreadCount.toString()&#10;                // make preview text darker when there are unread messages&#10;                tvLast?.setTextColor(&quot;#212121&quot;.toColorInt())&#10;            } else {&#10;                tvUnread?.visibility = View.GONE&#10;                tvLast?.setTextColor(&quot;#757575&quot;.toColorInt())&#10;            }&#10;&#10;            itemView.setOnClickListener { onClick(c) }&#10;        }&#10;    }&#10;&#10;    class Diff : DiffUtil.ItemCallback&lt;Conversation&gt;() {&#10;        override fun areItemsTheSame(oldItem: Conversation, newItem: Conversation): Boolean = oldItem.conversationID == newItem.conversationID&#10;        override fun areContentsTheSame(oldItem: Conversation, newItem: Conversation): Boolean = oldItem == newItem&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.adapter&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.core.graphics.toColorInt&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.data.models.Conversation&#10;&#10;class ConversationsAdapter(private val onClick: (Conversation) -&gt; Unit) : ListAdapter&lt;Conversation, ConversationsAdapter.VH&gt;(Diff()) {&#10;&#10;    // Ensure adapter never shows duplicate partner rows: dedupe by partnerID preserving order&#10;    override fun submitList(list: List&lt;Conversation&gt;?) {&#10;        if (list == null) {&#10;            super.submitList(null)&#10;            return&#10;        }&#10;        val seen = mutableSetOf&lt;Long&gt;()&#10;        val deduped = mutableListOf&lt;Conversation&gt;()&#10;        for (c in list) {&#10;            if (seen.add(c.partnerID)) deduped.add(c)&#10;        }&#10;        super.submitList(deduped)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {&#10;        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_conversation, parent, false)&#10;        return VH(v, onClick)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: VH, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    class VH(itemView: View, val onClick: (Conversation) -&gt; Unit) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvPartner: TextView? = itemView.findViewById(R.id.tvPartner)&#10;        private val tvLast: TextView? = itemView.findViewById(R.id.tvLastMessage)&#10;        private val tvTime: TextView? = itemView.findViewById(R.id.tvTime)&#10;        private val tvUnread: TextView? = itemView.findViewById(R.id.tvUnread)&#10;&#10;        fun bind(c: Conversation) {&#10;            // Normal partner display&#10;            tvPartner?.text = c.partnerName ?: &quot;User ${c.partnerID}&quot;&#10;            // Preview text should be just the last message&#10;            tvLast?.text = c.lastMessage ?: &quot;&quot;&#10;&#10;            // Try to parse common timestamp formats and format to a short human-friendly form&#10;            var displayTime = c.lastMessageAt ?: &quot;&quot;&#10;            try {&#10;                val s = c.lastMessageAt&#10;                if (!s.isNullOrBlank()) {&#10;                    try {&#10;                        val fmtIn = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;                        val ldt = java.time.LocalDateTime.parse(s, fmtIn)&#10;                        val fmtOut = java.time.format.DateTimeFormatter.ofPattern(&quot;HH:mm&quot;)&#10;                        displayTime = ldt.format(fmtOut)&#10;                    } catch (_: Exception) {&#10;                        // fallback: try ISO&#10;                        try {&#10;                            val instant = java.time.Instant.parse(s)&#10;                            val zdt = instant.atZone(java.time.ZoneId.systemDefault())&#10;                            val fmtOut2 = java.time.format.DateTimeFormatter.ofPattern(&quot;HH:mm&quot;)&#10;                            displayTime = zdt.format(fmtOut2)&#10;                        } catch (_: Exception) {&#10;                            // leave raw&#10;                            displayTime = s&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;                displayTime = c.lastMessageAt ?: &quot;&quot;&#10;            }&#10;&#10;            tvTime?.text = displayTime&#10;&#10;            // By default make preview text readable/darker; when unread show a stronger emphasis&#10;            tvLast?.setTextColor(&quot;#212121&quot;.toColorInt())&#10;            if (c.unreadCount &gt; 0) {&#10;                tvUnread?.visibility = View.VISIBLE&#10;                tvUnread?.text = c.unreadCount.toString()&#10;                // emphasize preview text when there are unread messages&#10;                tvLast?.setTextColor(&quot;#000000&quot;.toColorInt())&#10;            } else {&#10;                tvUnread?.visibility = View.GONE&#10;            }&#10;&#10;            itemView.setOnClickListener { onClick(c) }&#10;        }&#10;    }&#10;&#10;    class Diff : DiffUtil.ItemCallback&lt;Conversation&gt;() {&#10;        override fun areItemsTheSame(oldItem: Conversation, newItem: Conversation): Boolean = oldItem.conversationID == newItem.conversationID&#10;        override fun areContentsTheSame(oldItem: Conversation, newItem: Conversation): Boolean = oldItem == newItem&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/customer/ChatFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/customer/ChatFragment.kt" />
              <option name="originalContent" value="package com.example.capstone2.customer&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.ChatAdapter&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.viewmodel.ChatViewModel&#10;import com.example.capstone2.viewmodel.ChatViewModelFactory&#10;&#10;class ChatFragment : Fragment() {&#10;&#10;    private lateinit var rvMessages: RecyclerView&#10;    private lateinit var etMessage: EditText&#10;    private lateinit var btnSend: ImageButton&#10;    private lateinit var adapter: ChatAdapter&#10;    private lateinit var viewModel: ChatViewModel&#10;    private lateinit var tvChatTitle: TextView&#10;&#10;    private var otherUserId: Long = -1L&#10;    private var conversationID: String? = null&#10;    private var currentUserId: Long = -1L&#10;    private var otherName: String? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        arguments?.let {&#10;            if (it.containsKey(&quot;otherUserID&quot;)) otherUserId = it.getLong(&quot;otherUserID&quot;, -1L)&#10;            if (it.containsKey(&quot;conversationID&quot;)) conversationID = it.getString(&quot;conversationID&quot;)&#10;            if (it.containsKey(&quot;otherName&quot;)) otherName = it.getString(&quot;otherName&quot;)&#10;        }&#10;&#10;        currentUserId = SharedPrefManager.getUserId(requireContext()) ?: -1L&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val v = inflater.inflate(R.layout.fragment_chat, container, false)&#10;        tvChatTitle = v.findViewById(R.id.tvChatTitle)&#10;        rvMessages = v.findViewById(R.id.rvMessages)&#10;        etMessage = v.findViewById(R.id.etMessage)&#10;        btnSend = v.findViewById(R.id.btnSend)&#10;&#10;        otherName?.let { tvChatTitle.text = it; tvChatTitle.visibility = View.VISIBLE }&#10;&#10;        adapter = ChatAdapter(currentUserId)&#10;        rvMessages.setHasFixedSize(true)&#10;        rvMessages.layoutManager = LinearLayoutManager(requireContext()).apply { stackFromEnd = true }&#10;        rvMessages.adapter = adapter&#10;        rvMessages.isNestedScrollingEnabled = true&#10;        rvMessages.clipToPadding = false&#10;        try { rvMessages.elevation = 8f * resources.displayMetrics.density } catch (_: Exception) {}&#10;&#10;        // Adjust RecyclerView bottom padding so last message is visible above the input (post to ensure measurements are ready)&#10;        try {&#10;            v.post {&#10;                try {&#10;                    val input = v.findViewById&lt;View?&gt;(R.id.layoutInput)&#10;                    val inputH = input?.height ?: (56 * resources.displayMetrics.density).toInt()&#10;                    val extra = (8 * resources.displayMetrics.density).toInt()&#10;                    rvMessages.setPadding(rvMessages.paddingLeft, rvMessages.paddingTop, rvMessages.paddingRight, inputH + extra)&#10;                } catch (_: Exception) {}&#10;            }&#10;        } catch (_: Exception) {}&#10;&#10;        val factory = ChatViewModelFactory(requireContext(), currentUserId)&#10;        viewModel = ViewModelProvider(this, factory).get(ChatViewModel::class.java)&#10;&#10;        viewModel.messages.observe(viewLifecycleOwner) { list -&gt;&#10;            val snapshot = list?.toList() ?: emptyList()&#10;            val enriched = snapshot.map { msg -&gt;&#10;                if (msg.senderName != null) return@map msg&#10;                val inferredName = when (msg.senderID) {&#10;                    currentUserId -&gt; SharedPrefManager.getUserFullName(requireContext()) ?: &quot;You&quot;&#10;                    otherUserId -&gt; otherName&#10;                    else -&gt; null&#10;                }&#10;                if (inferredName != null) msg.copy(senderName = inferredName) else msg&#10;            }&#10;            adapter.submitList(enriched)&#10;            rvMessages.visibility = View.VISIBLE&#10;            try { rvMessages.bringToFront() } catch (_: Exception) {}&#10;            rvMessages.post { if (enriched.isNotEmpty()) try { rvMessages.scrollToPosition(enriched.size - 1) } catch (_: Exception) {} }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { err -&gt; err?.let { Toast.makeText(requireContext(), it, Toast.LENGTH_SHORT).show() } }&#10;&#10;        if (conversationID != null) {&#10;            Toast.makeText(requireContext(), &quot;Loading conversation...&quot;, Toast.LENGTH_SHORT).show()&#10;            viewModel.loadConversation(conversationID = conversationID)&#10;        } else if (otherUserId != -1L) {&#10;            Toast.makeText(requireContext(), &quot;Loading conversation...&quot;, Toast.LENGTH_SHORT).show()&#10;            viewModel.loadConversation(otherUserID = otherUserId)&#10;        }&#10;&#10;        btnSend.setOnClickListener {&#10;            val text = etMessage.text.toString().trim()&#10;            if (text.isEmpty()) return@setOnClickListener&#10;            if (otherUserId == -1L) {&#10;                Toast.makeText(requireContext(), &quot;No recipient specified&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;            viewModel.sendMessage(receiverID = otherUserId, text = text, conversationID = conversationID)&#10;            etMessage.setText(&quot;&quot;)&#10;        }&#10;&#10;        return v&#10;    }&#10;&#10;    companion object {&#10;        @JvmStatic&#10;        fun newInstance(otherUserID: Long, conversationID: String? = null, otherName: String? = null) = ChatFragment().apply {&#10;            arguments = Bundle().apply {&#10;                putLong(&quot;otherUserID&quot;, otherUserID)&#10;                conversationID?.let { putString(&quot;conversationID&quot;, it) }&#10;                otherName?.let { putString(&quot;otherName&quot;, it) }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.customer&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.ChatAdapter&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.viewmodel.ChatViewModel&#10;import com.example.capstone2.viewmodel.ChatViewModelFactory&#10;import android.util.Log&#10;&#10;class ChatFragment : Fragment() {&#10;    private lateinit var rvMessages: RecyclerView&#10;    private lateinit var etMessage: EditText&#10;    private lateinit var btnSend: ImageButton&#10;    private lateinit var adapter: ChatAdapter&#10;    private lateinit var viewModel: ChatViewModel&#10;    private lateinit var tvChatTitle: TextView&#10;&#10;    private var otherUserId: Long = -1L&#10;    private var conversationID: String? = null&#10;    private var currentUserId: Long = -1L&#10;    private var otherName: String? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        arguments?.let {&#10;            if (it.containsKey(&quot;otherUserID&quot;)) otherUserId = it.getLong(&quot;otherUserID&quot;, -1L)&#10;            if (it.containsKey(&quot;conversationID&quot;)) conversationID = it.getString(&quot;conversationID&quot;)&#10;            if (it.containsKey(&quot;otherName&quot;)) otherName = it.getString(&quot;otherName&quot;)&#10;        }&#10;&#10;        currentUserId = SharedPrefManager.getUserId(requireContext()) ?: -1L&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val v = inflater.inflate(R.layout.fragment_chat, container, false)&#10;        tvChatTitle = v.findViewById(R.id.tvChatTitle)&#10;        rvMessages = v.findViewById(R.id.rvMessages)&#10;        etMessage = v.findViewById(R.id.etMessage)&#10;        btnSend = v.findViewById(R.id.btnSend)&#10;&#10;        otherName?.let { tvChatTitle.text = it; tvChatTitle.visibility = View.VISIBLE }&#10;&#10;        adapter = ChatAdapter(currentUserId)&#10;        rvMessages.setHasFixedSize(true)&#10;        rvMessages.layoutManager = LinearLayoutManager(requireContext()).apply { stackFromEnd = true }&#10;        rvMessages.adapter = adapter&#10;        rvMessages.isNestedScrollingEnabled = true&#10;        rvMessages.clipToPadding = false&#10;        try { rvMessages.elevation = 8f * resources.displayMetrics.density } catch (_: Exception) {}&#10;&#10;        // Adjust RecyclerView bottom padding so last message is visible above the input (post to ensure measurements are ready)&#10;        try {&#10;            v.post {&#10;                try {&#10;                    val input = v.findViewById&lt;View?&gt;(R.id.layoutInput)&#10;                    val inputH = input?.height ?: (56 * resources.displayMetrics.density).toInt()&#10;                    val extra = (8 * resources.displayMetrics.density).toInt()&#10;                    rvMessages.setPadding(rvMessages.paddingLeft, rvMessages.paddingTop, rvMessages.paddingRight, inputH + extra)&#10;                } catch (_: Exception) {}&#10;            }&#10;        } catch (_: Exception) {}&#10;&#10;        val factory = ChatViewModelFactory(requireContext(), currentUserId)&#10;        viewModel = ViewModelProvider(this, factory).get(ChatViewModel::class.java)&#10;&#10;        viewModel.messages.observe(viewLifecycleOwner) { list -&gt;&#10;            val snapshot = list?.toList() ?: emptyList()&#10;            val enriched = snapshot.map { msg -&gt;&#10;                if (msg.senderName != null) return@map msg&#10;                val inferredName = when (msg.senderID) {&#10;                    currentUserId -&gt; SharedPrefManager.getUserFullName(requireContext()) ?: &quot;You&quot;&#10;                    otherUserId -&gt; otherName&#10;                    else -&gt; null&#10;                }&#10;                if (inferredName != null) msg.copy(senderName = inferredName) else msg&#10;            }&#10;            // Robust ordering: prefer sorting by parsed timestamps when there are multiple parseable times.&#10;            fun parseTimeToMillis(t: String?): Long? {&#10;                if (t == null) return null&#10;                try { val asLong = t.toLongOrNull(); if (asLong != null) return if (asLong &lt; 1000000000000L) asLong * 1000L else asLong } catch (_: Exception) {}&#10;                try { return java.time.Instant.parse(t).toEpochMilli() } catch (_: Exception) {}&#10;                try {&#10;                    val fmt = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;                    val ldt = java.time.LocalDateTime.parse(t, fmt)&#10;                    return ldt.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()&#10;                } catch (_: Exception) {}&#10;                return null&#10;            }&#10;&#10;            val parsedList = enriched.map { it to try { parseTimeToMillis(it.timestamp) } catch (_: Exception) { null } }&#10;            val parsedCount = parsedList.count { it.second != null }&#10;            val sorted = when {&#10;                parsedCount &gt;= 2 -&gt; {&#10;                    // Sort by time ascending (oldest first)&#10;                    parsedList.sortedBy { it.second ?: Long.MIN_VALUE }.map { it.first }&#10;                }&#10;                else -&gt; {&#10;                    // Not enough parseable times: apply heuristics on raw timestamp strings.&#10;                    val rawTimestamps = enriched.mapNotNull { it.timestamp }&#10;                    fun isLikelyIso(ts: String?): Boolean {&#10;                        if (ts == null) return false&#10;                        return ts.length &gt;= 16 &amp;&amp; ts[4] == '-' &amp;&amp; ts[7] == '-' &amp;&amp; ts[10] == ' '&#10;                    }&#10;&#10;                    // If first and last raw timestamps look like the common yyyy-MM-dd HH:mm:ss format, compare lexicographically.&#10;                    val firstRaw = enriched.firstOrNull()?.timestamp&#10;                    val lastRaw = enriched.lastOrNull()?.timestamp&#10;                    val lexReverse = if (firstRaw != null &amp;&amp; lastRaw != null &amp;&amp; isLikelyIso(firstRaw) &amp;&amp; isLikelyIso(lastRaw)) {&#10;                        firstRaw &gt; lastRaw&#10;                    } else {&#10;                        // Fallback heuristic: sample pairs across the list and count decreasing pairs (newest-first). If majority decreasing, reverse.&#10;                        var dec = 0; var inc = 0&#10;                        val sample = rawTimestamps.take(6)&#10;                        for (i in 0 until sample.size - 1) {&#10;                            val a = sample[i]; val b = sample[i+1]&#10;                            if (a &gt; b) dec++ else if (a &lt; b) inc++&#10;                        }&#10;                        dec &gt; inc &amp;&amp; dec &gt; 0&#10;                    }&#10;&#10;                    if (lexReverse) {&#10;                        if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;Heuristic: reversing list because timestamps appear newest-first&quot;)&#10;                        enriched.reversed()&#10;                    } else enriched&#10;                }&#10;            }&#10;            adapter.submitList(sorted)&#10;            // Broadcast the newest message preview so the Conversations list can update its preview if needed&#10;             try {&#10;                 val lastMsg = sorted.lastOrNull()&#10;                 if (lastMsg != null) {&#10;                     // Determine partner id in case fragment was opened by conversationID (otherUserId may be -1)&#10;                     val partnerIdToSave = try {&#10;                         if (otherUserId != -1L) otherUserId&#10;                         else {&#10;                             val sid = lastMsg.senderID ?: -1L&#10;                             val rid = lastMsg.receiverID ?: -1L&#10;                             if (sid == currentUserId) rid else sid&#10;                         }&#10;                     } catch (_: Exception) { otherUserId }&#10;&#10;                     // Persist preview for offline/slow-server situations&#10;                     try {&#10;                         com.example.capstone2.repository.SharedPrefManager.saveConversationPreview(requireContext(), partnerIdToSave, lastMsg.conversationID, lastMsg.message, lastMsg.timestamp)&#10;                     } catch (_: Exception) {}&#10;&#10;                     val itPreview = android.content.Intent(&quot;com.example.capstone2.NEW_MESSAGE_PREVIEW&quot;)&#10;                     itPreview.putExtra(&quot;partnerID&quot;, partnerIdToSave)&#10;                     itPreview.putExtra(&quot;conversationID&quot;, lastMsg.conversationID)&#10;                     itPreview.putExtra(&quot;lastMessage&quot;, lastMsg.message)&#10;                     itPreview.putExtra(&quot;lastMessageAt&quot;, lastMsg.timestamp)&#10;                     requireActivity().sendBroadcast(itPreview)&#10;                 }&#10;             } catch (_: Exception) {}&#10;             rvMessages.visibility = View.VISIBLE&#10;            try { rvMessages.bringToFront() } catch (_: Exception) {}&#10;            rvMessages.post { if (sorted.isNotEmpty()) try { rvMessages.scrollToPosition(sorted.size - 1) } catch (_: Exception) {} }&#10;        }&#10;&#10;        viewModel.error.observe(viewLifecycleOwner) { err -&gt; err?.let { Toast.makeText(requireContext(), it, Toast.LENGTH_SHORT).show() } }&#10;&#10;        if (conversationID != null) {&#10;            Toast.makeText(requireContext(), &quot;Loading conversation...&quot;, Toast.LENGTH_SHORT).show()&#10;            viewModel.loadConversation(conversationID = conversationID)&#10;        } else if (otherUserId != -1L) {&#10;            Toast.makeText(requireContext(), &quot;Loading conversation...&quot;, Toast.LENGTH_SHORT).show()&#10;            viewModel.loadConversation(otherUserID = otherUserId)&#10;        }&#10;&#10;        btnSend.setOnClickListener {&#10;            val text = etMessage.text.toString().trim()&#10;            if (text.isEmpty()) return@setOnClickListener&#10;            if (otherUserId == -1L) {&#10;                Toast.makeText(requireContext(), &quot;No recipient specified&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;            viewModel.sendMessage(receiverID = otherUserId, text = text, conversationID = conversationID)&#10;            etMessage.setText(&quot;&quot;)&#10;        }&#10;&#10;        return v&#10;    }&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ChatFragment&quot;&#10;        @JvmStatic&#10;        fun newInstance(otherUserID: Long, conversationID: String? = null, otherName: String? = null) = ChatFragment().apply {&#10;            arguments = Bundle().apply {&#10;                putLong(&quot;otherUserID&quot;, otherUserID)&#10;                conversationID?.let { putString(&quot;conversationID&quot;, it) }&#10;                otherName?.let { putString(&quot;otherName&quot;, it) }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/messages/MessagesFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/messages/MessagesFragment.kt" />
              <option name="originalContent" value="package com.example.capstone2.messages&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.ConversationsAdapter&#10;import com.example.capstone2.data.models.Conversation&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.customer.ChatFragment&#10;import com.google.gson.Gson&#10;import com.google.gson.JsonElement&#10;import com.google.gson.JsonParser&#10;import com.google.gson.reflect.TypeToken&#10;import kotlinx.coroutines.launch&#10;import android.util.Log&#10;&#10;class MessagesFragment : Fragment() {&#10;&#10;    private var rv: RecyclerView? = null&#10;    private var tvEmpty: TextView? = null&#10;    private lateinit var adapter: ConversationsAdapter&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MessagesFragment&quot;&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val v = inflater.inflate(R.layout.fragment_messages_list, container, false)&#10;        rv = v.findViewById(R.id.rvConversations)&#10;        tvEmpty = v.findViewById(R.id.tvEmpty)&#10;&#10;        adapter = ConversationsAdapter { conv -&gt;&#10;            // Open chat fragment for selected conversation using otherUserID (server will compute canonical conversationID)&#10;            val chat = ChatFragment.newInstance(conv.partnerID, null, conv.partnerName)&#10;            requireActivity().supportFragmentManager.beginTransaction()&#10;                .replace(R.id.flFragment, chat)&#10;                .addToBackStack(null)&#10;                .commit()&#10;        }&#10;&#10;        rv?.layoutManager = LinearLayoutManager(requireContext())&#10;        rv?.adapter = adapter&#10;&#10;        loadConversations()&#10;&#10;        return v&#10;    }&#10;&#10;    private fun loadConversations() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val api = ApiClient.getApiService { SharedPrefManager.getAuthToken(requireContext()) }&#10;                val resp = api.getConversations()&#10;                if (resp.isSuccessful) {&#10;                    val bodyStr = try { resp.body()?.string() } catch (_: Exception) { null }&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;conversations raw: ${bodyStr?.take(2000)}&quot;)&#10;                    if (bodyStr.isNullOrBlank()) {&#10;                        this@MessagesFragment.showEmpty()&#10;                        return@launch&#10;                    }&#10;                    try {&#10;                        val gson = Gson()&#10;                        val je: JsonElement = JsonParser.parseString(bodyStr)&#10;&#10;                        // try find array under common keys&#10;                        fun findArray(elem: JsonElement): JsonElement? {&#10;                            if (elem.isJsonArray) return elem&#10;                            if (elem.isJsonObject) {&#10;                                val obj = elem.asJsonObject&#10;                                val keys = listOf(&quot;conversations&quot;, &quot;data&quot;, &quot;items&quot;, &quot;results&quot;)&#10;                                for (k in keys) {&#10;                                    if (obj.has(k)) {&#10;                                        val child = obj.get(k)&#10;                                        if (child.isJsonArray) return child&#10;                                    }&#10;                                }&#10;                                // search properties for array&#10;                                val it = obj.entrySet().iterator()&#10;                                while (it.hasNext()) {&#10;                                    val entry = it.next()&#10;                                    val found = findArray(entry.value)&#10;                                    if (found != null) return found&#10;                                }&#10;                            }&#10;                            return null&#10;                        }&#10;&#10;                        val arr = findArray(je)&#10;                        val listType = object : TypeToken&lt;List&lt;Conversation&gt;&gt;() {}.type&#10;                        val conversations: List&lt;Conversation&gt; = if (arr != null) gson.fromJson(arr, listType) else gson.fromJson(bodyStr, listType)&#10;&#10;                        // Enrich conversations with inferred partner names when missing&#10;                        val enriched = mutableListOf&lt;Conversation&gt;()&#10;                        // Determine a JsonArray to inspect (prefer `arr` if found)&#10;                        val jsonArr = when {&#10;                            arr != null &amp;&amp; arr.isJsonArray -&gt; arr.asJsonArray&#10;                            je.isJsonArray -&gt; je.asJsonArray&#10;                            else -&gt; null&#10;                        }&#10;&#10;                        if (jsonArr != null) {&#10;                            for (i in 0 until jsonArr.size()) {&#10;                                val elem = jsonArr[i]&#10;                                try {&#10;                                    val conv = gson.fromJson(elem, Conversation::class.java)&#10;                                    if (conv != null) {&#10;                                        var name = conv.partnerName&#10;                                        if (name.isNullOrBlank() &amp;&amp; elem.isJsonObject) {&#10;                                            val obj = elem.asJsonObject&#10;                                            // Common candidate keys for partner name (many variants)&#10;                                            val keys = listOf(&#10;                                                &quot;partnerName&quot;, &quot;partner_name&quot;, &quot;partner&quot;, &quot;partnerFullName&quot;,&#10;                                                &quot;partner_full_name&quot;, &quot;name&quot;, &quot;displayName&quot;, &quot;display_name&quot;,&#10;                                                &quot;fullName&quot;, &quot;full_name&quot;, &quot;firstName&quot;, &quot;first_name&quot;, &quot;first_name&quot;&#10;                                            )&#10;                                            for (k in keys) {&#10;                                                if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                                    try { name = obj.get(k).asString; break } catch (_: Exception) {}&#10;                                                }&#10;                                            }&#10;                                            // Check nested 'partner' or 'user' objects&#10;                                            if (name.isNullOrBlank()) {&#10;                                                val nestedKeys = listOf(&quot;partner&quot;, &quot;user&quot;, &quot;customer&quot;, &quot;owner&quot;, &quot;sender&quot;, &quot;receiver&quot;, &quot;profile&quot;, &quot;participant&quot;)&#10;                                                for (nk in nestedKeys) {&#10;                                                    if (obj.has(nk) &amp;&amp; obj.get(nk).isJsonObject) {&#10;                                                        val p = obj.getAsJsonObject(nk)&#10;                                                        val pk = listOf(&quot;fullName&quot;, &quot;full_name&quot;, &quot;name&quot;, &quot;displayName&quot;, &quot;display_name&quot;, &quot;firstName&quot;, &quot;first_name&quot;, &quot;first_name&quot;)&#10;                                                        for (k in pk) {&#10;                                                            if (p.has(k) &amp;&amp; !p.get(k).isJsonNull) {&#10;                                                                try { name = p.get(k).asString; break } catch (_: Exception) {}&#10;                                                            }&#10;                                                        }&#10;                                                        // Try first+last name snake or camel&#10;                                                        if (name.isNullOrBlank()) {&#10;                                                            val firstKeys = listOf(&quot;firstName&quot;, &quot;first_name&quot;, &quot;firstname&quot;)&#10;                                                            val lastKeys = listOf(&quot;lastName&quot;, &quot;last_name&quot;, &quot;lastname&quot;)&#10;                                                            var f: String? = null&#10;                                                            var l: String? = null&#10;                                                            for (fk in firstKeys) if (p.has(fk) &amp;&amp; !p.get(fk).isJsonNull) try { f = p.get(fk).asString } catch (_: Exception) {}&#10;                                                            for (lk in lastKeys) if (p.has(lk) &amp;&amp; !p.get(lk).isJsonNull) try { l = p.get(lk).asString } catch (_: Exception) {}&#10;                                                            if (!f.isNullOrBlank() || !l.isNullOrBlank()) {&#10;                                                                name = listOfNotNull(f?.trim(), l?.trim()).joinToString(&quot; &quot;).trim()&#10;                                                            }&#10;                                                        }&#10;                                                        if (!name.isNullOrBlank()) break&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;&#10;                                        if (!name.isNullOrBlank() &amp;&amp; name != conv.partnerName) {&#10;                                            enriched.add(conv.copy(partnerName = name))&#10;                                        } else {&#10;                                            enriched.add(conv)&#10;                                        }&#10;                                    }&#10;                                } catch (_: Exception) {&#10;                                    // ignore parse error for this element&#10;                                }&#10;                            }&#10;                        } else {&#10;                            enriched.addAll(conversations)&#10;                        }&#10;&#10;                        if (enriched.isEmpty()) {&#10;                            this@MessagesFragment.showEmpty()&#10;                        } else {&#10;                            tvEmpty?.visibility = View.GONE&#10;                            // Submit initial list (with any inferred names)&#10;                            adapter.submitList(enriched)&#10;&#10;                            // Fetch missing partner names from API if any&#10;                            val missingIds = enriched.filter { it.partnerName.isNullOrBlank() }.map { it.partnerID }.distinct()&#10;                            if (missingIds.isNotEmpty()) {&#10;                                // Simple in-memory cache for fetched user names&#10;                                val userNameCache = mutableMapOf&lt;Long, String&gt;()&#10;&#10;                                // Helper: try several endpoints to fetch a display name for a user id&#10;                                suspend fun fetchDisplayNameForId(id: Long): String? {&#10;                                    try {&#10;                                        // First try typed endpoint if available&#10;                                        try {&#10;                                            val uresp = api.getUser(id)&#10;                                            if (uresp.isSuccessful) {&#10;                                                val user = uresp.body()&#10;                                                if (user != null) {&#10;                                                    val display = listOfNotNull(user.firstName.takeIf { it.isNotBlank() }, user.lastName.takeIf { it.isNotBlank() }).joinToString(&quot; &quot;).ifBlank { user.emailAddress }&#10;                                                    if (display.isNotBlank()) return display&#10;                                                }&#10;                                            }&#10;                                        } catch (_: Exception) {&#10;                                            // typed endpoint may not exist or fail; continue to raw attempts&#10;                                        }&#10;&#10;                                        // Candidate raw endpoints relative to base URL — try them in order&#10;                                        val candidates = listOf(&#10;                                            &quot;api/user/$id&quot;,&#10;                                            &quot;api/users/$id&quot;,&#10;                                            &quot;api/customers/$id&quot;,&#10;                                            &quot;api/customer/$id&quot;,&#10;                                            &quot;api/owners/$id&quot;,&#10;                                            &quot;api/owner/$id&quot;,&#10;                                            &quot;api/profile/$id&quot;,&#10;                                            &quot;api/users/$id/profile&quot;,&#10;                                            &quot;api/customers/$id/profile&quot;&#10;                                        )&#10;&#10;                                        for (path in candidates) {&#10;                                            try {&#10;                                                if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;trying raw profile path: $path for id=$id&quot;)&#10;                                                val r = api.getRaw(path)&#10;                                                if (!r.isSuccessful) {&#10;                                                    if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;raw path $path returned HTTP ${r.code()}&quot;)&#10;                                                    continue&#10;                                                }&#10;                                                val raw = try { r.body()?.string() } catch (_: Exception) { null }&#10;                                                if (raw.isNullOrBlank()) continue&#10;                                                if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;raw profile response for $path: ${raw.take(2000)}&quot;)&#10;&#10;                                                try {&#10;                                                    val je2 = JsonParser.parseString(raw)&#10;                                                    fun extractName(elem: JsonElement?): String? {&#10;                                                        if (elem == null) return null&#10;                                                        if (elem.isJsonObject) {&#10;                                                            val obj2 = elem.asJsonObject&#10;                                                            val keys2 = listOf(&quot;name&quot;,&quot;displayName&quot;,&quot;display_name&quot;,&quot;fullName&quot;,&quot;full_name&quot;,&quot;firstName&quot;,&quot;first_name&quot;,&quot;firstname&quot;)&#10;                                                            for (k2 in keys2) {&#10;                                                                if (obj2.has(k2) &amp;&amp; !obj2.get(k2).isJsonNull) {&#10;                                                                    try { val s = obj2.get(k2).asString; if (!s.isNullOrBlank()) return s } catch (_: Exception) {}&#10;                                                                }&#10;                                                            }&#10;                                                            val firstKeys2 = listOf(&quot;firstName&quot;,&quot;first_name&quot;,&quot;firstname&quot;)&#10;                                                            val lastKeys2 = listOf(&quot;lastName&quot;,&quot;last_name&quot;,&quot;lastname&quot;)&#10;                                                            var f2: String? = null; var l2: String? = null&#10;                                                            for (fk2 in firstKeys2) if (obj2.has(fk2) &amp;&amp; !obj2.get(fk2).isJsonNull) try { f2 = obj2.get(fk2).asString } catch (_: Exception) {}&#10;                                                            for (lk2 in lastKeys2) if (obj2.has(lk2) &amp;&amp; !obj2.get(lk2).isJsonNull) try { l2 = obj2.get(lk2).asString } catch (_: Exception) {}&#10;                                                            if (!f2.isNullOrBlank() || !l2.isNullOrBlank()) return listOfNotNull(f2?.trim(), l2?.trim()).joinToString(&quot; &quot;).trim()&#10;                                                            val nested2 = listOf(&quot;user&quot;,&quot;partner&quot;,&quot;customer&quot;,&quot;owner&quot;,&quot;profile&quot;,&quot;data&quot;)&#10;                                                            for (nk2 in nested2) {&#10;                                                                if (obj2.has(nk2) &amp;&amp; obj2.get(nk2).isJsonObject) {&#10;                                                                    val maybe = extractName(obj2.get(nk2))&#10;                                                                    if (!maybe.isNullOrBlank()) return maybe&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                        if (elem.isJsonArray) {&#10;                                                            val arr2 = elem.asJsonArray&#10;                                                            if (arr2.size() &gt; 0) {&#10;                                                                val first = arr2[0]&#10;                                                                return extractName(first)&#10;                                                            }&#10;                                                        }&#10;                                                        return null&#10;                                                    }&#10;&#10;                                                    val found = extractName(je2)&#10;                                                    if (!found.isNullOrBlank()) return found&#10;                                                } catch (_: Exception) {&#10;                                                    // parsing failed, try next&#10;                                                }&#10;                                            } catch (_: Exception) {&#10;                                                // raw GET failed, try next&#10;                                            }&#10;                                        }&#10;                                    } catch (_: Exception) {&#10;                                        // overall failure, return null&#10;                                    }&#10;                                    return null&#10;                                }&#10;&#10;                                for (id in missingIds) {&#10;                                    try {&#10;                                        if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;fetching partner profile for userId=$id&quot;)&#10;                                        val display = fetchDisplayNameForId(id)&#10;                                        if (!display.isNullOrBlank()) {&#10;                                            if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;fetched user $id display='$display'&quot;)&#10;                                            userNameCache[id] = display&#10;                                        } else {&#10;                                            if (Log.isLoggable(TAG, Log.DEBUG)) Log.d(TAG, &quot;no profile name found for id=$id&quot;)&#10;                                        }&#10;                                    } catch (_: Exception) {&#10;                                        Log.w(TAG, &quot;getUser($id) failed&quot;)&#10;                                        // ignore individual fetch errors&#10;                                    }&#10;                                }&#10;&#10;                                if (userNameCache.isNotEmpty()) {&#10;                                    val updated = enriched.map { c -&gt;&#10;                                        if (c.partnerName.isNullOrBlank() &amp;&amp; userNameCache.containsKey(c.partnerID)) c.copy(partnerName = userNameCache[c.partnerID]) else c&#10;                                    }&#10;                                    adapter.submitList(updated)&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;parse convs&quot;, e)&#10;                        this@MessagesFragment.showEmpty()&#10;                    }&#10;                } else {&#10;                    this@MessagesFragment.showEmpty()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;loadConversations&quot;, e)&#10;                this@MessagesFragment.showEmpty()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showEmpty() {&#10;        adapter.submitList(emptyList())&#10;        tvEmpty?.visibility = View.VISIBLE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.messages&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.capstone2.R&#10;import com.example.capstone2.adapter.ConversationsAdapter&#10;import com.example.capstone2.data.models.Conversation&#10;import com.example.capstone2.network.ApiClient&#10;import com.example.capstone2.repository.SharedPrefManager&#10;import com.example.capstone2.customer.ChatFragment&#10;import com.google.gson.Gson&#10;import com.google.gson.JsonElement&#10;import com.google.gson.JsonParser&#10;import com.google.gson.reflect.TypeToken&#10;import kotlinx.coroutines.launch&#10;import android.util.Log&#10;import java.io.File&#10;import android.content.ClipData&#10;import android.content.ClipboardManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.widget.ScrollView&#10;import android.content.pm.ApplicationInfo&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;&#10;class MessagesFragment : Fragment() {&#10;&#10;    private var rv: RecyclerView? = null&#10;    private var tvEmpty: TextView? = null&#10;    private lateinit var adapter: ConversationsAdapter&#10;    private var previewReceiver: BroadcastReceiver? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MessagesFragment&quot;&#10;    }&#10;&#10;    // Runtime check for whether the app is debuggable (avoids referencing BuildConfig)&#10;    private fun isDebug(): Boolean {&#10;        return try {&#10;            (requireContext().applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0&#10;        } catch (_: Exception) { false }&#10;    }&#10;&#10;    // Reusable timestamp parser for this fragment&#10;    private fun parseTimeToMillis(t: String?): Long? {&#10;        if (t == null) return null&#10;        try { val asLong = t.toLongOrNull(); if (asLong != null) return if (asLong &lt; 1000000000000L) asLong * 1000L else asLong } catch (_: Exception) {}&#10;        try { return java.time.Instant.parse(t).toEpochMilli() } catch (_: Exception) {}&#10;        try {&#10;            val fmt = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;            val ldt = java.time.LocalDateTime.parse(t, fmt)&#10;            return ldt.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()&#10;        } catch (_: Exception) {}&#10;        return null&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val v = inflater.inflate(R.layout.fragment_messages_list, container, false)&#10;        rv = v.findViewById(R.id.rvConversations)&#10;        tvEmpty = v.findViewById(R.id.tvEmpty)&#10;&#10;        adapter = ConversationsAdapter { conv -&gt;&#10;            // Open chat fragment for selected conversation using otherUserID (server will compute canonical conversationID)&#10;            val chat = ChatFragment.newInstance(conv.partnerID, null, conv.partnerName)&#10;            requireActivity().supportFragmentManager.beginTransaction()&#10;                .replace(R.id.flFragment, chat)&#10;                .addToBackStack(null)&#10;                .commit()&#10;        }&#10;&#10;        rv?.layoutManager = LinearLayoutManager(requireContext())&#10;        rv?.adapter = adapter&#10;&#10;        // Register receiver to update conversation preview when chat receives/sends a new message&#10;        try {&#10;            previewReceiver = object : BroadcastReceiver() {&#10;                override fun onReceive(context: Context?, intent: Intent?) {&#10;                    try {&#10;                        if (intent == null) return&#10;                        val partnerId = intent.getLongExtra(&quot;partnerID&quot;, -1L)&#10;                        if (partnerId == -1L) return&#10;                        val convId = intent.getStringExtra(&quot;conversationID&quot;)&#10;                        val lastMsg = intent.getStringExtra(&quot;lastMessage&quot;)&#10;                        var lastAt = intent.getStringExtra(&quot;lastMessageAt&quot;)&#10;                        if (lastAt.isNullOrBlank()) {&#10;                            try {&#10;                                val fmt = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;                                lastAt = java.time.LocalDateTime.now().format(fmt)&#10;                            } catch (_: Exception) { lastAt = null }&#10;                        }&#10;                        // Update adapter list: replace or insert, then sort newest-first&#10;                        val current = adapter.currentList.toMutableList()&#10;                        var replaced = false&#10;                        for (i in current.indices) {&#10;                            if (current[i].partnerID == partnerId) {&#10;                                val c = current[i]&#10;                                val updated = c.copy(conversationID = convId ?: c.conversationID, lastMessage = lastMsg ?: c.lastMessage, lastMessageAt = lastAt ?: c.lastMessageAt)&#10;                                current[i] = updated&#10;                                replaced = true&#10;                                break&#10;                            }&#10;                        }&#10;                        if (!replaced) {&#10;                            // create a minimal conversation entry when missing&#10;                            val newConv = Conversation(conversationID = convId ?: &quot;&quot;, partnerID = partnerId, partnerName = null, lastMessage = lastMsg ?: &quot;&quot;, lastMessageAt = lastAt, unreadCount = 0)&#10;                            current.add(newConv)&#10;                        }&#10;                        // Sort newest-first by parsed timestamp&#10;                        try {&#10;                            val sorted = current.sortedWith(compareByDescending&lt;Conversation&gt; { c -&gt; parseTimeToMillis(c.lastMessageAt) ?: Long.MIN_VALUE })&#10;                            adapter.submitList(sorted)&#10;                        } catch (_: Exception) {&#10;                            adapter.submitList(current)&#10;                        }&#10;                    } catch (_: Exception) { }&#10;                }&#10;            }&#10;            requireContext().registerReceiver(previewReceiver, IntentFilter(&quot;com.example.capstone2.NEW_MESSAGE_PREVIEW&quot;))&#10;        } catch (_: Exception) { }&#10;&#10;        loadConversations()&#10;&#10;        return v&#10;    }&#10;&#10;    private fun loadConversations() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val api = ApiClient.getApiService { SharedPrefManager.getAuthToken(requireContext()) }&#10;                val resp = api.getConversations()&#10;                if (resp.isSuccessful) {&#10;                    val bodyStr = try { resp.body()?.string() } catch (_: Exception) { null }&#10;&#10;                    // Save raw response to external app-specific storage so you can pull it without adb&#10;                    try {&#10;                        val outDir = requireContext().getExternalFilesDir(null)&#10;                        if (outDir != null &amp;&amp; !bodyStr.isNullOrBlank()) {&#10;                            val outFile = File(outDir, &quot;conversations_raw_${System.currentTimeMillis()}.json&quot;)&#10;                            outFile.writeText(bodyStr)&#10;                            Toast.makeText(requireContext(), &quot;Saved conversations JSON to: ${outFile.absolutePath}&quot;, Toast.LENGTH_LONG).show()&#10;                            // debug logging removed&#10; // ...existing code...&#10;                    // debug logging removed&#10;                    if (bodyStr.isNullOrBlank()) {&#10;                        this@MessagesFragment.showEmpty()&#10;                        return@launch&#10;                    }&#10;                    try {&#10;                        val gson = Gson()&#10;                        val je: JsonElement = JsonParser.parseString(bodyStr)&#10;&#10;                        // try find array under common keys&#10;                        fun findArray(elem: JsonElement): JsonElement? {&#10;                            if (elem.isJsonArray) return elem&#10;                            if (elem.isJsonObject) {&#10;                                val obj = elem.asJsonObject&#10;                                val keys = listOf(&quot;conversations&quot;, &quot;data&quot;, &quot;items&quot;, &quot;results&quot;)&#10;                                for (k in keys) {&#10;                                    if (obj.has(k)) {&#10;                                        val child = obj.get(k)&#10;                                        if (child.isJsonArray) return child&#10;                                    }&#10;                                }&#10;                                // search properties for array&#10;                                val it = obj.entrySet().iterator()&#10;                                while (it.hasNext()) {&#10;                                    val entry = it.next()&#10;                                    val found = findArray(entry.value)&#10;                                    if (found != null) return found&#10;                                }&#10;                            }&#10;                            return null&#10;                        }&#10;&#10;                        val arr = findArray(je)&#10;                        val listType = object : TypeToken&lt;List&lt;Conversation&gt;&gt;() {}.type&#10;                        val conversations: List&lt;Conversation&gt; = if (arr != null) gson.fromJson(arr, listType) else gson.fromJson(bodyStr, listType)&#10;&#10;                        // Enrich conversations with inferred partner names when missing&#10;                        val enriched = mutableListOf&lt;Conversation&gt;()&#10;                        // Determine a JsonArray to inspect (prefer `arr` if found)&#10;                        val jsonArr = when {&#10;                            arr != null &amp;&amp; arr.isJsonArray -&gt; arr.asJsonArray&#10;                            je.isJsonArray -&gt; je.asJsonArray&#10;                            else -&gt; null&#10;                        }&#10;&#10;                        // Helper: extract latest message text and timestamp from a JsonElement conversation candidate&#10;                        fun extractLatestMessage(elem: JsonElement?): Pair&lt;String?, String?&gt; {&#10;                            if (elem == null) return Pair(null, null)&#10;                            try {&#10;                                if (!elem.isJsonObject) return Pair(null, null)&#10;                                val obj = elem.asJsonObject&#10;&#10;                                // Quick string fields that often contain preview&#10;                                val quickKeys = listOf(&quot;lastMessage&quot;, &quot;last_message&quot;, &quot;latestMessage&quot;, &quot;latest_message&quot;, &quot;preview&quot;, &quot;last&quot;)&#10;                                val timeKeysSibling = listOf(&quot;lastMessageAt&quot;, &quot;last_message_at&quot;, &quot;lastAt&quot;, &quot;last_at&quot;, &quot;updatedAt&quot;, &quot;updated_at&quot;, &quot;lastMessageTime&quot;)&#10;                                for (k in quickKeys) {&#10;                                    if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                        try {&#10;                                            val s = obj.get(k).asString&#10;                                            if (!s.isNullOrBlank()) {&#10;                                                // Try to find a sibling timestamp in the same object&#10;                                                var siblingTime: String? = null&#10;                                                for (tk in timeKeysSibling) {&#10;                                                    if (obj.has(tk) &amp;&amp; !obj.get(tk).isJsonNull) {&#10;                                                        try { siblingTime = obj.get(tk).asString; break } catch (_: Exception) { }&#10;                                                    }&#10;                                                }&#10;                                                return Pair(s, siblingTime)&#10;                                            }&#10;                                        } catch (_: Exception) { }&#10;                                    }&#10;                                }&#10;&#10;                                // If there's an object representing the latest message, try to extract text + time&#10;                                val objKeys = listOf(&quot;lastMessageObject&quot;, &quot;latest&quot;, &quot;latest_message&quot;, &quot;last_message_object&quot;, &quot;last_message_obj&quot;)&#10;                                for (k in objKeys) {&#10;                                    if (obj.has(k) &amp;&amp; obj.get(k).isJsonObject) {&#10;                                        val m = obj.getAsJsonObject(k)&#10;                                        val textKeys = listOf(&quot;body&quot;, &quot;message&quot;, &quot;text&quot;, &quot;content&quot;)&#10;                                        var txt: String? = null&#10;                                        for (tk in textKeys) if (m.has(tk) &amp;&amp; !m.get(tk).isJsonNull) try { txt = m.get(tk).asString; break } catch (_: Exception) { }&#10;                                        val timeKeys = listOf(&quot;createdAt&quot;,&quot;created_at&quot;,&quot;sentAt&quot;,&quot;sent_at&quot;,&quot;time&quot;,&quot;timestamp&quot;,&quot;date&quot;)&#10;                                        var t: String? = null&#10;                                        for (tk in timeKeys) if (m.has(tk) &amp;&amp; !m.get(tk).isJsonNull) try { t = m.get(tk).asString; break } catch (_: Exception) { }&#10;                                        if (!txt.isNullOrBlank()) return Pair(txt, t)&#10;                                    }&#10;                                }&#10;&#10;                                // If there is an array of messages, try to pick the most recent by timestamp when possible,&#10;                                // otherwise determine array ordering using first/last timestamps or fall back to last element.&#10;                                val arrKeys = listOf(&quot;messages&quot;, &quot;items&quot;, &quot;results&quot;, &quot;conversationMessages&quot;, &quot;msgs&quot;)&#10;                                for (k in arrKeys) {&#10;                                    if (obj.has(k) &amp;&amp; obj.get(k).isJsonArray) {&#10;                                        val a = obj.getAsJsonArray(k)&#10;                                        if (a.size() == 0) continue&#10;&#10;                                        // Build a list of entries with text + parsed time (if present)&#10;                                        data class Entry(val text: String?, val timeStr: String?, val timeMillis: Long?)&#10;                                        val entries = mutableListOf&lt;Entry&gt;()&#10;                                        for (j in 0 until a.size()) {&#10;                                            val jelem = a[j]&#10;                                            if (!jelem.isJsonObject) { entries.add(Entry(null, null, null)); continue }&#10;                                            val mobj = jelem.asJsonObject&#10;                                            var txt: String? = null&#10;                                            for (tk in listOf(&quot;body&quot;,&quot;message&quot;,&quot;text&quot;,&quot;content&quot;,&quot;lastMessage&quot;)) if (mobj.has(tk) &amp;&amp; !mobj.get(tk).isJsonNull) try { txt = mobj.get(tk).asString; break } catch (_: Exception) { }&#10;                                            var timestr: String? = null&#10;                                            for (tk in listOf(&quot;createdAt&quot;,&quot;created_at&quot;,&quot;sentAt&quot;,&quot;sent_at&quot;,&quot;time&quot;,&quot;timestamp&quot;,&quot;date&quot;)) if (mobj.has(tk) &amp;&amp; !mobj.get(tk).isJsonNull) try { timestr = mobj.get(tk).asString; break } catch (_: Exception) { }&#10;                                            var timeVal: Long? = null&#10;                                            if (!timestr.isNullOrBlank()) {&#10;                                                try { timeVal = timestr.toLong() } catch (_: Exception) {&#10;                                                    try { timeVal = java.time.Instant.parse(timestr).toEpochMilli() } catch (_: Exception) { timeVal = null }&#10;                                                }&#10;                                            }&#10;                                            entries.add(Entry(txt, timestr, timeVal))&#10;                                        }&#10;&#10;                                        // If any time values are parseable, pick the entry with max timestamp&#10;                                        val anyTimes = entries.any { it.timeMillis != null }&#10;                                        if (anyTimes) {&#10;                                            val best = entries.maxByOrNull { it.timeMillis ?: Long.MIN_VALUE }&#10;                                            if (best != null &amp;&amp; !best.text.isNullOrBlank()) return Pair(best.text, best.timeStr)&#10;                                        }&#10;&#10;                                        // If no times parseable, try to detect ordering by comparing first/last timestamps when present&#10;                                        if (entries.size &gt;= 2) {&#10;                                            val first = entries.first()&#10;                                            val last = entries.last()&#10;                                            val ftime = first.timeMillis&#10;                                            val ltime = last.timeMillis&#10;                                            if (ftime != null &amp;&amp; ltime != null) {&#10;                                                // if first &gt;= last, array is newest-first; else newest is last&#10;                                                return if (ftime &gt;= ltime) Pair(first.text, first.timeStr) else Pair(last.text, last.timeStr)&#10;                                            } else if (ftime != null) {&#10;                                                return Pair(first.text, first.timeStr)&#10;                                            } else if (ltime != null) {&#10;                                                return Pair(last.text, last.timeStr)&#10;                                            }&#10;                                        }&#10;&#10;                                        // No parseable timestamps found. Prefer the first element as a fallback because many&#10;                                        // APIs return messages in newest-first order. If first is empty, fall back to last.&#10;                                        val firstFallback = entries.firstOrNull()?.text&#10;                                        if (!firstFallback.isNullOrBlank()) {&#10;                                            // debug logging removed&#10;                                            return Pair(firstFallback, null)&#10;                                        }&#10;                                        val lastFallback = entries.lastOrNull()?.text&#10;                                        if (!lastFallback.isNullOrBlank()) {&#10;                                            // debug logging removed&#10;                                            return Pair(lastFallback, null)&#10;                                        }&#10;                                     }&#10;                                }&#10;&#10;                                // Nothing found&#10;                            } catch (_: Exception) { }&#10;                            return Pair(null, null)&#10;                        }&#10;&#10;                        // Helper: parse timestamp string to epoch millis (tries plain long, ISO instant)&#10;                        fun parseTimeToMillis(t: String?): Long? {&#10;                            if (t == null) return null&#10;                            try {&#10;                                // Try numeric epoch millis or seconds&#10;                                val asLong = t.toLongOrNull()&#10;                                if (asLong != null) {&#10;                                    // Heuristic: if number looks like seconds (10 digits), convert to millis&#10;                                    return if (asLong &lt; 1000000000000L) asLong * 1000L else asLong&#10;                                }&#10;                            } catch (_: Exception) { }&#10;                            try {&#10;                                return java.time.Instant.parse(t).toEpochMilli()&#10;                            } catch (_: Exception) { }&#10;                            // Try common custom formats like &quot;yyyy-MM-dd HH:mm:ss&quot;&#10;                            try {&#10;                                val fmt = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;                                val ldt = java.time.LocalDateTime.parse(t, fmt)&#10;                                return ldt.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()&#10;                            } catch (_: Exception) { }&#10;                            // Try a variant with timezone offset if present&#10;                            try {&#10;                                val fmt2 = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;)&#10;                                val zdt = java.time.ZonedDateTime.parse(t, fmt2)&#10;                                return zdt.toInstant().toEpochMilli()&#10;                            } catch (_: Exception) { }&#10;                            return null&#10;                        }&#10;&#10;                        if (jsonArr != null) {&#10;                            for (i in 0 until jsonArr.size()) {&#10;                                val elem = jsonArr[i]&#10;                                try {&#10;                                    val conv = gson.fromJson(elem, Conversation::class.java)&#10;                                    if (conv != null) {&#10;                                        var name = conv.partnerName&#10;&#10;                                        // existing name inference logic preserved&#10;                                        if (name.isNullOrBlank() &amp;&amp; elem.isJsonObject) {&#10;                                            val obj = elem.asJsonObject&#10;                                            // Common candidate keys for partner name (many variants)&#10;                                            val keys = listOf(&#10;                                                &quot;partnerName&quot;, &quot;partner_name&quot;, &quot;partner&quot;, &quot;partnerFullName&quot;,&#10;                                                &quot;partner_full_name&quot;, &quot;name&quot;, &quot;displayName&quot;, &quot;display_name&quot;,&#10;                                                &quot;fullName&quot;, &quot;full_name&quot;, &quot;firstName&quot;, &quot;first_name&quot;, &quot;first_name&quot;&#10;                                            )&#10;                                            for (k in keys) {&#10;                                                if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                                    try { name = obj.get(k).asString; break } catch (_: Exception) {}&#10;                                                }&#10;                                            }&#10;                                            // Check nested 'partner' or 'user' objects&#10;                                            if (name.isNullOrBlank()) {&#10;                                                val nestedKeys = listOf(&quot;partner&quot;, &quot;user&quot;, &quot;customer&quot;, &quot;owner&quot;, &quot;sender&quot;, &quot;receiver&quot;, &quot;profile&quot;, &quot;participant&quot;)&#10;                                                for (nk in nestedKeys) {&#10;                                                    if (obj.has(nk) &amp;&amp; obj.get(nk).isJsonObject) {&#10;                                                        val p = obj.getAsJsonObject(nk)&#10;                                                        val pk = listOf(&quot;fullName&quot;, &quot;full_name&quot;, &quot;name&quot;, &quot;displayName&quot;, &quot;display_name&quot;, &quot;firstName&quot;, &quot;first_name&quot;, &quot;first_name&quot;)&#10;                                                        for (k in pk) {&#10;                                                            if (p.has(k) &amp;&amp; !p.get(k).isJsonNull) {&#10;                                                                try { name = p.get(k).asString; break } catch (_: Exception) {}&#10;                                                            }&#10;                                                        }&#10;                                                        // Try first+last name snake or camel&#10;                                                        if (name.isNullOrBlank()) {&#10;                                                            val firstKeys = listOf(&quot;firstName&quot;, &quot;first_name&quot;, &quot;firstname&quot;)&#10;                                                            val lastKeys = listOf(&quot;lastName&quot;, &quot;last_name&quot;, &quot;lastname&quot;)&#10;                                                            var f: String? = null&#10;                                                            var l: String? = null&#10;                                                            for (fk in firstKeys) if (p.has(fk) &amp;&amp; !p.get(fk).isJsonNull) try { f = p.get(fk).asString } catch (_: Exception) {}&#10;                                                            for (lk in lastKeys) if (p.has(lk) &amp;&amp; !p.get(lk).isJsonNull) try { l = p.get(lk).asString } catch (_: Exception) {}&#10;                                                            if (!f.isNullOrBlank() || !l.isNullOrBlank()) {&#10;                                                                name = listOfNotNull(f?.trim(), l?.trim()).joinToString(&quot; &quot;).trim()&#10;                                                            }&#10;                                                        }&#10;                                                        if (!name.isNullOrBlank()) break&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;&#10;                                        // --- NEW: extract latest message preview and timestamp when available ---&#10;                                        val (previewText, previewAt) = extractLatestMessage(elem)&#10;&#10;                                        // Decide whether to override conv.lastMessage with the extracted preview.&#10;                                        // Only override when:&#10;                                        //  - conv.lastMessage is blank/null, OR&#10;                                        //  - previewAt is parseable and newer than conv.lastMessageAt.&#10;                                        var finalConv = conv&#10;                                        try {&#10;                                            val convTime = parseTimeToMillis(conv.lastMessageAt)&#10;                                            val previewTime = parseTimeToMillis(previewAt)&#10;                                            if (conv.lastMessage.isNullOrBlank()) {&#10;                                                if (!previewText.isNullOrBlank()) finalConv = conv.copy(lastMessage = previewText, lastMessageAt = previewAt ?: conv.lastMessageAt)&#10;                                            } else if (!previewText.isNullOrBlank() &amp;&amp; previewTime != null) {&#10;                                                // if preview timestamp is newer than conv timestamp, prefer preview&#10;                                                if (convTime == null || previewTime &gt; convTime) {&#10;                                                    finalConv = conv.copy(lastMessage = previewText, lastMessageAt = previewAt ?: conv.lastMessageAt)&#10;                                                }&#10;                                            }&#10;                                        } catch (_: Exception) {&#10;                                            // fallback: do not override&#10;                                            finalConv = conv&#10;                                        }&#10;&#10;                                        if (!name.isNullOrBlank() &amp;&amp; name != finalConv.partnerName) {&#10;                                            enriched.add(finalConv.copy(partnerName = name))&#10;                                        } else {&#10;                                            enriched.add(finalConv)&#10;                                        }&#10;                                    }&#10;                                } catch (_: Exception) {&#10;                                    // ignore parse error for this element&#10;                                }&#10;                            }&#10;                        } else {&#10;                            enriched.addAll(conversations)&#10;                        }&#10;&#10;                        if (enriched.isEmpty()) {&#10;                            this@MessagesFragment.showEmpty()&#10;                        } else {&#10;                            tvEmpty?.visibility = View.GONE&#10;                            // NOTE: we used to submit `enriched` here immediately, but that produced&#10;                            // duplicate rows and sometimes showed older previews. The final&#10;                            // collapsed/deduped/sorted list is submitted later in this function.&#10;                            // So defer submitting until we've collapsed/sorted/deduped below.&#10;&#10;                            // Fetching partner names is handled after we compute `deduped` and submit the final list below.&#10;                        }&#10;&#10;                        // Compute final deduped/sorted list for display&#10;                        val deduped = enriched&#10;                            .groupBy { it.partnerID }&#10;                            .map { it.value.maxByOrNull { c -&gt; parseTimeToMillis(c.lastMessageAt) ?: 0L } }&#10;                            .filterNotNull()&#10;                            .sortedWith(compareByDescending&lt;Conversation&gt; { c -&gt; parseTimeToMillis(c.lastMessageAt) ?: 0L })&#10;&#10;                        // Merge cached previews (saved by ChatFragment) so UI reflects recent local messages&#10;                        val finalList: List&lt;Conversation&gt; = try {&#10;                            val merged = deduped.map { conv -&gt;&#10;                                try {&#10;                                    val preview = com.example.capstone2.repository.SharedPrefManager.getConversationPreview(requireContext(), conv.partnerID)&#10;                                    if (preview != null) {&#10;                                        val serverTime = parseTimeToMillis(conv.lastMessageAt)&#10;                                        val previewTime = parseTimeToMillis(preview.lastMessageAt)&#10;                                        if (!preview.lastMessage.isNullOrBlank() &amp;&amp; (previewTime != null &amp;&amp; (serverTime == null || previewTime &gt; serverTime))) {&#10;                                            // preview is newer; use it&#10;                                            return@map conv.copy(lastMessage = preview.lastMessage, lastMessageAt = preview.lastMessageAt)&#10;                                        }&#10;                                    }&#10;                                } catch (_: Exception) { }&#10;                                conv&#10;                            }&#10;                            // Re-sort after merging&#10;                            merged.sortedWith(compareByDescending&lt;Conversation&gt; { c -&gt; parseTimeToMillis(c.lastMessageAt) ?: 0L })&#10;                        } catch (_: Exception) {&#10;                            deduped&#10;                        }&#10;                        adapter.submitList(finalList)&#10;&#10;                        // Debug: prepare and log the final list submitted to the adapter&#10;                        try {&#10;                            val sb = StringBuilder()&#10;                            sb.append(&quot;final-list: &quot;)&#10;                            for (c in finalList) {&#10;                                sb.append(&quot;[id=${c.conversationID},partner=${c.partnerID},name=${c.partnerName},time=${c.lastMessageAt}] &quot;)&#10;                            }&#10;                            // debug logging removed&#10;                        } catch (_: Exception) { }&#10;&#10;                        // Fetch missing partner names from API if any&#10;                        val missingIds = deduped.filter { it.partnerName.isNullOrBlank() }.map { it.partnerID }.distinct()&#10;                         if (missingIds.isNotEmpty()) {&#10;                            // Simple in-memory cache for fetched user names&#10;                            val userNameCache = mutableMapOf&lt;Long, String&gt;()&#10;&#10;                            // Helper: try several endpoints to fetch a display name for a user id&#10;                            suspend fun fetchDisplayNameForId(id: Long): String? {&#10;                                try {&#10;                                    // First try typed endpoint if available&#10;                                    try {&#10;                                        val uresp = api.getUser(id)&#10;                                        if (uresp.isSuccessful) {&#10;                                            val user = uresp.body()&#10;                                            if (user != null) {&#10;                                                val display = listOfNotNull(user.firstName.takeIf { it.isNotBlank() }, user.lastName.takeIf { it.isNotBlank() }).joinToString(&quot; &quot;).ifBlank { user.emailAddress }&#10;                                                if (display.isNotBlank()) return display&#10;                                            }&#10;                                        }&#10;                                    } catch (_: Exception) {&#10;                                        // typed endpoint may not exist or fail; continue to raw attempts&#10;                                    }&#10;&#10;                                    // Candidate raw endpoints relative to base URL — try them in order&#10;                                    val candidates = listOf(&#10;                                        &quot;api/user/$id&quot;,&#10;                                        &quot;api/users/$id&quot;,&#10;                                        &quot;api/customers/$id&quot;,&#10;                                        &quot;api/customer/$id&quot;,&#10;                                        &quot;api/owners/$id&quot;,&#10;                                        &quot;api/owner/$id&quot;,&#10;                                        &quot;api/profile/$id&quot;,&#10;                                        &quot;api/users/$id/profile&quot;,&#10;                                        &quot;api/customers/$id/profile&quot;&#10;                                    )&#10;&#10;                                    for (path in candidates) {&#10;                                        try {&#10;                                            // debug logging removed&#10;                                            val r = api.getRaw(path)&#10;                                            if (!r.isSuccessful) {&#10;                                                // debug logging removed&#10;                                                continue&#10;                                            }&#10;                                            val raw = try { r.body()?.string() } catch (_: Exception) { null }&#10;                                            if (raw.isNullOrBlank()) continue&#10;                                            // debug logging removed&#10;&#10;                                            try {&#10;                                                val je2 = JsonParser.parseString(raw)&#10;                                                fun extractName(elem: JsonElement?): String? {&#10;                                                    if (elem == null) return null&#10;                                                    if (elem.isJsonObject) {&#10;                                                        val obj2 = elem.asJsonObject&#10;                                                        val keys2 = listOf(&quot;name&quot;,&quot;displayName&quot;,&quot;display_name&quot;,&quot;fullName&quot;,&quot;full_name&quot;,&quot;firstName&quot;,&quot;first_name&quot;,&quot;firstname&quot;)&#10;                                                        for (k2 in keys2) {&#10;                                                            if (obj2.has(k2) &amp;&amp; !obj2.get(k2).isJsonNull) {&#10;                                                                try { val s = obj2.get(k2).asString; if (!s.isNullOrBlank()) return s } catch (_: Exception) {}&#10;                                                            }&#10;                                                        }&#10;                                                        val firstKeys2 = listOf(&quot;firstName&quot;,&quot;first_name&quot;,&quot;firstname&quot;)&#10;                                                        val lastKeys2 = listOf(&quot;lastName&quot;,&quot;last_name&quot;,&quot;lastname&quot;)&#10;                                                        var f2: String? = null; var l2: String? = null&#10;                                                        for (fk2 in firstKeys2) if (obj2.has(fk2) &amp;&amp; !obj2.get(fk2).isJsonNull) try { f2 = obj2.get(fk2).asString } catch (_: Exception) {}&#10;                                                        for (lk2 in lastKeys2) if (obj2.has(lk2) &amp;&amp; !obj2.get(lk2).isJsonNull) try { l2 = obj2.get(lk2).asString } catch (_: Exception) {}&#10;                                                        if (!f2.isNullOrBlank() || !l2.isNullOrBlank()) return listOfNotNull(f2?.trim(), l2?.trim()).joinToString(&quot; &quot;).trim()&#10;                                                        val nested2 = listOf(&quot;user&quot;,&quot;partner&quot;,&quot;customer&quot;,&quot;owner&quot;,&quot;profile&quot;,&quot;data&quot;)&#10;                                                        for (nk2 in nested2) {&#10;                                                            if (obj2.has(nk2) &amp;&amp; obj2.get(nk2).isJsonObject) {&#10;                                                                val maybe = extractName(obj2.get(nk2))&#10;                                                                if (!maybe.isNullOrBlank()) return maybe&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                    if (elem.isJsonArray) {&#10;                                                        val arr2 = elem.asJsonArray&#10;                                                        if (arr2.size() &gt; 0) {&#10;                                                            val first = arr2[0]&#10;                                                            return extractName(first)&#10;                                                        }&#10;                                                    }&#10;                                                    return null&#10;                                                }&#10;&#10;                                                val found = extractName(je2)&#10;                                                if (!found.isNullOrBlank()) return found&#10;                                            } catch (_: Exception) {&#10;                                                // parsing failed, try next&#10;                                            }&#10;                                        } catch (_: Exception) {&#10;                                            // raw GET failed, try next&#10;                                        }&#10;                                    }&#10;                                } catch (_: Exception) {&#10;                                    // overall failure, return null&#10;                                }&#10;                                return null&#10;                            }&#10;&#10;                            for (id in missingIds) {&#10;                                try {&#10;                                    // debug logging removed&#10;                                    val display = fetchDisplayNameForId(id)&#10;                                    if (!display.isNullOrBlank()) {&#10;                                        // debug logging removed&#10;                                        userNameCache[id] = display&#10;                                    } else {&#10;                                        // debug logging removed&#10;                                    }&#10;                                } catch (_: Exception) {&#10;                                    // ignore individual fetch errors&#10;                                }&#10;                            }&#10;&#10;                            if (userNameCache.isNotEmpty()) {&#10;                                val updated = deduped.map { c -&gt;&#10;                                    if (c.partnerName.isNullOrBlank() &amp;&amp; userNameCache.containsKey(c.partnerID)) c.copy(partnerName = userNameCache[c.partnerID]) else c&#10;                                }&#10;                                val updatedSorted = updated.sortedWith(compareByDescending&lt;Conversation&gt; { c -&gt; parseTimeToMillis(c.lastMessageAt) ?: 0L })&#10;                                adapter.submitList(updatedSorted)&#10;                            }&#10;                        }&#10;&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;parse convs&quot;, e)&#10;                        this@MessagesFragment.showEmpty()&#10;                    }&#10;                } else {&#10;                    this@MessagesFragment.showEmpty()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;loadConversations&quot;, e)&#10;                this@MessagesFragment.showEmpty()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showEmpty() {&#10;        adapter.submitList(emptyList())&#10;        tvEmpty?.visibility = View.VISIBLE&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        try { previewReceiver?.let { requireContext().unregisterReceiver(it) } } catch (_: Exception) {}&#10;        previewReceiver = null&#10;        super.onDestroyView()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/repository/SharedPrefManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/repository/SharedPrefManager.kt" />
              <option name="originalContent" value="package com.example.capstone2.repository&#10;&#10;import android.content.Context&#10;&#10;object SharedPrefManager {&#10;    private const val PREFS_NAME = &quot;capstone_prefs&quot;&#10;&#10;    /**&#10;     * Safely returns the stored userID from known preference files if present.&#10;     * Accepts values stored as Long, Int, String (numeric), Float, Double.&#10;     */&#10;    fun getUserId(ctx: Context): Long? {&#10;        val names = arrayOf(&quot;capstone_prefs&quot;, &quot;MyAppPrefs&quot;)&#10;        for (n in names) {&#10;            val p = ctx.getSharedPreferences(n, Context.MODE_PRIVATE)&#10;            if (!p.contains(&quot;userID&quot;)) continue&#10;            val v = p.all[&quot;userID&quot;]&#10;            when (v) {&#10;                is Long -&gt; return v&#10;                is Int -&gt; return v.toLong()&#10;                is String -&gt; return v.toLongOrNull()&#10;                is Float -&gt; return v.toLong()&#10;                is Double -&gt; return v.toLong()&#10;                else -&gt; continue&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    fun saveAuthToken(ctx: Context, token: String) {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        p.edit().putString(&quot;auth_token&quot;, token).apply()&#10;    }&#10;&#10;    /**&#10;     * Try to find the auth token in any of the known preference files.&#10;     * This is defensive because some activities use &quot;MyAppPrefs&quot; while the&#10;     * centralized SharedPrefManager historically used &quot;capstone_prefs&quot;.&#10;     */&#10;    fun getAuthToken(ctx: Context): String? {&#10;        val names = arrayOf(PREFS_NAME, &quot;MyAppPrefs&quot;)&#10;        for (n in names) {&#10;            val p = ctx.getSharedPreferences(n, Context.MODE_PRIVATE)&#10;            val t = p.getString(&quot;auth_token&quot;, null)&#10;            if (!t.isNullOrBlank()) return t&#10;        }&#10;        return null&#10;    }&#10;&#10;    fun saveUserId(ctx: Context, userId: Long) {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        p.edit().putLong(&quot;userID&quot;, userId).apply()&#10;    }&#10;&#10;    /**&#10;     * Try to return a user-friendly name for the currently-signed-in user from shared prefs.&#10;     * Checks several common keys (`userFullName`, `displayName`, `firstName`/`lastName`) and&#10;     * returns the first non-empty value found.&#10;     */&#10;    fun getUserFullName(ctx: Context): String? {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val candidates = listOf(&#10;            p.getString(&quot;userFullName&quot;, null),&#10;            p.getString(&quot;displayName&quot;, null),&#10;            p.getString(&quot;userName&quot;, null)&#10;        ).filterNotNull().map { it.trim() }.filter { it.isNotEmpty() }&#10;        if (candidates.isNotEmpty()) return candidates.first()&#10;&#10;        // Try to assemble from first/last name if available&#10;        val first = p.getString(&quot;firstName&quot;, null)&#10;        val last = p.getString(&quot;lastName&quot;, null)&#10;        if (!first.isNullOrBlank() || !last.isNullOrBlank()) {&#10;            return listOfNotNull(first?.trim(), last?.trim()).joinToString(&quot; &quot;)&#10;        }&#10;&#10;        return null&#10;    }&#10;&#10;    // --- debug panel preference helpers ---&#10;    private const val KEY_DEBUG_PANEL_VISIBLE = &quot;debug_panel_visible&quot;&#10;&#10;    fun isDebugPanelEnabled(ctx: Context): Boolean {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        return p.getBoolean(KEY_DEBUG_PANEL_VISIBLE, false)&#10;    }&#10;&#10;    fun setDebugPanelEnabled(ctx: Context, enabled: Boolean) {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        p.edit().putBoolean(KEY_DEBUG_PANEL_VISIBLE, enabled).apply()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.repository&#10;&#10;import android.content.Context&#10;&#10;object SharedPrefManager {&#10;    private const val PREFS_NAME = &quot;capstone_prefs&quot;&#10;&#10;    /**&#10;     * Safely returns the stored userID from known preference files if present.&#10;     * Accepts values stored as Long, Int, String (numeric), Float, Double.&#10;     */&#10;    fun getUserId(ctx: Context): Long? {&#10;        val names = arrayOf(&quot;capstone_prefs&quot;, &quot;MyAppPrefs&quot;)&#10;        for (n in names) {&#10;            val p = ctx.getSharedPreferences(n, Context.MODE_PRIVATE)&#10;            if (!p.contains(&quot;userID&quot;)) continue&#10;            val v = p.all[&quot;userID&quot;]&#10;            when (v) {&#10;                is Long -&gt; return v&#10;                is Int -&gt; return v.toLong()&#10;                is String -&gt; return v.toLongOrNull()&#10;                is Float -&gt; return v.toLong()&#10;                is Double -&gt; return v.toLong()&#10;                else -&gt; continue&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    fun saveAuthToken(ctx: Context, token: String) {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        p.edit().putString(&quot;auth_token&quot;, token).apply()&#10;    }&#10;&#10;    /**&#10;     * Try to find the auth token in any of the known preference files.&#10;     * This is defensive because some activities use &quot;MyAppPrefs&quot; while the&#10;     * centralized SharedPrefManager historically used &quot;capstone_prefs&quot;.&#10;     */&#10;    fun getAuthToken(ctx: Context): String? {&#10;        val names = arrayOf(PREFS_NAME, &quot;MyAppPrefs&quot;)&#10;        for (n in names) {&#10;            val p = ctx.getSharedPreferences(n, Context.MODE_PRIVATE)&#10;            val t = p.getString(&quot;auth_token&quot;, null)&#10;            if (!t.isNullOrBlank()) return t&#10;        }&#10;        return null&#10;    }&#10;&#10;    fun saveUserId(ctx: Context, userId: Long) {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        p.edit().putLong(&quot;userID&quot;, userId).apply()&#10;    }&#10;&#10;    /**&#10;     * Try to return a user-friendly name for the currently-signed-in user from shared prefs.&#10;     * Checks several common keys (`userFullName`, `displayName`, `firstName`/`lastName`) and&#10;     * returns the first non-empty value found.&#10;     */&#10;    fun getUserFullName(ctx: Context): String? {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        val candidates = listOf(&#10;            p.getString(&quot;userFullName&quot;, null),&#10;            p.getString(&quot;displayName&quot;, null),&#10;            p.getString(&quot;userName&quot;, null)&#10;        ).filterNotNull().map { it.trim() }.filter { it.isNotEmpty() }&#10;        if (candidates.isNotEmpty()) return candidates.first()&#10;&#10;        // Try to assemble from first/last name if available&#10;        val first = p.getString(&quot;firstName&quot;, null)&#10;        val last = p.getString(&quot;lastName&quot;, null)&#10;        if (!first.isNullOrBlank() || !last.isNullOrBlank()) {&#10;            return listOfNotNull(first?.trim(), last?.trim()).joinToString(&quot; &quot;)&#10;        }&#10;&#10;        return null&#10;    }&#10;&#10;    // --- debug panel preference helpers ---&#10;    private const val KEY_DEBUG_PANEL_VISIBLE = &quot;debug_panel_visible&quot;&#10;&#10;    fun isDebugPanelEnabled(ctx: Context): Boolean {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        return p.getBoolean(KEY_DEBUG_PANEL_VISIBLE, false)&#10;    }&#10;&#10;    fun setDebugPanelEnabled(ctx: Context, enabled: Boolean) {&#10;        val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        p.edit().putBoolean(KEY_DEBUG_PANEL_VISIBLE, enabled).apply()&#10;    }&#10;&#10;    // --- Conversation preview cache helpers (local optimistic UI) ---&#10;    data class ConversationPreview(val conversationID: String?, val lastMessage: String?, val lastMessageAt: String?)&#10;&#10;    private fun keyConv(partnerId: Long) = &quot;preview_conv_${partnerId}&quot;&#10;    private fun keyMsg(partnerId: Long) = &quot;preview_msg_${partnerId}&quot;&#10;    private fun keyAt(partnerId: Long) = &quot;preview_at_${partnerId}&quot;&#10;&#10;    fun saveConversationPreview(ctx: Context, partnerId: Long, conversationID: String?, lastMessage: String?, lastMessageAt: String?) {&#10;        try {&#10;            val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            val e = p.edit()&#10;            if (conversationID == null) e.remove(keyConv(partnerId)) else e.putString(keyConv(partnerId), conversationID)&#10;            if (lastMessage == null) e.remove(keyMsg(partnerId)) else e.putString(keyMsg(partnerId), lastMessage)&#10;            if (lastMessageAt == null) e.remove(keyAt(partnerId)) else e.putString(keyAt(partnerId), lastMessageAt)&#10;            e.apply()&#10;        } catch (_: Exception) { }&#10;    }&#10;&#10;    fun getConversationPreview(ctx: Context, partnerId: Long): ConversationPreview? {&#10;        return try {&#10;            val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            val conv = p.getString(keyConv(partnerId), null)&#10;            val msg = p.getString(keyMsg(partnerId), null)&#10;            val at = p.getString(keyAt(partnerId), null)&#10;            if (conv == null &amp;&amp; msg == null &amp;&amp; at == null) null else ConversationPreview(conv, msg, at)&#10;        } catch (_: Exception) { null }&#10;    }&#10;&#10;    fun clearConversationPreview(ctx: Context, partnerId: Long) {&#10;        try {&#10;            val p = ctx.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            p.edit().remove(keyConv(partnerId)).remove(keyMsg(partnerId)).remove(keyAt(partnerId)).apply()&#10;        } catch (_: Exception) { }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/viewmodel/ChatViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/capstone2/viewmodel/ChatViewModel.kt" />
              <option name="originalContent" value="package com.example.capstone2.viewmodel&#10;&#10;import androidx.lifecycle.*&#10;import com.example.capstone2.data.api.ApiService&#10;import com.example.capstone2.data.models.Message&#10;import com.example.capstone2.data.models.SendMessageRequest&#10;import kotlinx.coroutines.launch&#10;import com.google.gson.Gson&#10;import com.google.gson.JsonElement&#10;import com.google.gson.JsonParser&#10;import com.google.gson.reflect.TypeToken&#10;import android.util.Log&#10;&#10;class ChatViewModel(private val apiService: ApiService, private val currentUserId: Long) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ChatViewModel&quot;&#10;    }&#10;&#10;    private val _messages = MutableLiveData&lt;List&lt;Message&gt;&gt;(emptyList())&#10;    val messages: LiveData&lt;List&lt;Message&gt;&gt; = _messages&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;(null)&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    // New: debug LiveData to show last request/response in UI when adb isn't available&#10;    private val _debug = MutableLiveData&lt;String?&gt;(null)&#10;    val debug: LiveData&lt;String?&gt; = _debug&#10;&#10;    fun loadConversation(conversationID: String? = null, otherUserID: Long? = null) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val resp = apiService.getConversation(conversationID = conversationID, otherUserID = otherUserID)&#10;&#10;                // Read both body and errorBody (reading them may consume them) and post debug immediately&#10;                val responseBodyStr = try { resp.body()?.string() } catch (e: Exception) { null }&#10;                val responseErrStr = try { resp.errorBody()?.string() } catch (e: Exception) { null }&#10;                val respBodyShort = responseBodyStr ?: &quot;&lt;empty&gt;&quot;&#10;                val respErrShort = responseErrStr ?: &quot;&lt;none&gt;&quot;&#10;                _debug.postValue(&quot;Conversation HTTP ${resp.code()}: body=$respBodyShort err=$respErrShort&quot;)&#10;&#10;                if (!resp.isSuccessful) {&#10;                    _error.postValue(&quot;Failed to load conversation: ${resp.code()}&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val bodyStr = responseBodyStr&#10;                val bodyShort = bodyStr ?: &quot;&lt;empty&gt;&quot;&#10;                if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                    Log.d(TAG, &quot;getConversation raw response: ${bodyStr?.take(4000)}&quot;)&#10;                }&#10;                _debug.postValue(&quot;Conversation response (userId=$currentUserId):\n$bodyShort&quot;)&#10;&#10;                if (bodyStr.isNullOrBlank()) {&#10;                    _messages.postValue(emptyList())&#10;                    return@launch&#10;                }&#10;&#10;                try {&#10;                    val gson = Gson()&#10;                    val je = JsonParser.parseString(bodyStr)&#10;&#10;                    // Helper: recursively find first array element in a JSON tree&#10;                    fun findFirstArray(elem: JsonElement): JsonElement? {&#10;                        if (elem == null) return null&#10;                        if (elem.isJsonArray) return elem&#10;                        if (elem.isJsonObject) {&#10;                            val obj = elem.asJsonObject&#10;                            val keys = listOf(&quot;messages&quot;, &quot;data&quot;, &quot;results&quot;, &quot;items&quot;, &quot;conversation&quot;, &quot;body&quot;)&#10;                            for (k in keys) {&#10;                                if (obj.has(k)) {&#10;                                    val child = obj.get(k)&#10;                                    if (child.isJsonArray) return child&#10;                                    val nested = findFirstArray(child)&#10;                                    if (nested != null) return nested&#10;                                }&#10;                            }&#10;                            val it = obj.entrySet().iterator()&#10;                            while (it.hasNext()) {&#10;                                val entry = it.next()&#10;                                val found = findFirstArray(entry.value)&#10;                                if (found != null) return found&#10;                            }&#10;                        }&#10;                        return null&#10;                    }&#10;&#10;                    // Helper extractors (block-bodied so `return` is permitted inside)&#10;                    fun JsonElement.asSafeString(): String? {&#10;                        return try {&#10;                            if (this.isJsonNull) null else this.asString&#10;                        } catch (e: Exception) {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    fun JsonElement.asSafeLong(): Long? {&#10;                        return try {&#10;                            if (this.isJsonNull) return null&#10;                            val p = this.asJsonPrimitive&#10;                            if (p.isNumber) return p.asLong&#10;                            p.asString.toLongOrNull()&#10;                        } catch (e: Exception) {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    fun getStringFromObj(obj: com.google.gson.JsonObject, candidates: List&lt;String&gt;): String? {&#10;                        for (k in candidates) {&#10;                            if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                val v = try { obj.get(k) } catch (e: Exception) { null }&#10;                                if (v != null) {&#10;                                    val s = v.asSafeString()&#10;                                    if (!s.isNullOrBlank()) return s&#10;                                }&#10;                            }&#10;                        }&#10;                        return null&#10;                    }&#10;&#10;                    fun getLongFromObj(obj: com.google.gson.JsonObject, candidates: List&lt;String&gt;): Long? {&#10;                        for (k in candidates) {&#10;                            if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                val v = try { obj.get(k) } catch (e: Exception) { null }&#10;                                if (v != null) {&#10;                                    val l = v.asSafeLong()&#10;                                    if (l != null) return l&#10;                                }&#10;                            }&#10;                        }&#10;                        return null&#10;                    }&#10;&#10;                    // Parse array case&#10;                    val firstArray = findFirstArray(je)&#10;                    if (firstArray != null &amp;&amp; firstArray.isJsonArray) {&#10;                        val arr = firstArray.asJsonArray&#10;                        val built = mutableListOf&lt;Message&gt;()&#10;&#10;                        for (i in 0 until arr.size()) {&#10;                            val elem = arr[i]&#10;                            try {&#10;                                if (elem.isJsonObject) {&#10;                                    val obj = elem.asJsonObject&#10;                                    val messageText = getStringFromObj(obj, listOf(&quot;message&quot;,&quot;body&quot;,&quot;text&quot;,&quot;content&quot;,&quot;messageText&quot;,&quot;msg&quot;,&quot;message_body&quot;))&#10;                                    val idVal = getLongFromObj(obj, listOf(&quot;messageID&quot;,&quot;id&quot;,&quot;msg_id&quot;))&#10;                                    val senderVal = getLongFromObj(obj, listOf(&quot;senderID&quot;,&quot;senderId&quot;,&quot;from&quot;,&quot;userID&quot;,&quot;userId&quot;))&#10;                                    val receiverVal = getLongFromObj(obj, listOf(&quot;receiverID&quot;,&quot;receiverId&quot;,&quot;to&quot;))&#10;                                    val created = getStringFromObj(obj, listOf(&quot;createdAt&quot;,&quot;timestamp&quot;,&quot;time&quot;,&quot;created_at&quot;))&#10;                                    val conv = getStringFromObj(obj, listOf(&quot;conversationID&quot;,&quot;conversationId&quot;,&quot;conversation&quot;))&#10;                                    val senderName = getStringFromObj(obj, listOf(&quot;senderName&quot;,&quot;sender_name&quot;,&quot;name&quot;,&quot;displayName&quot;,&quot;display_name&quot;))&#10;                                    val receiverName = getStringFromObj(obj, listOf(&quot;receiverName&quot;,&quot;receiver_name&quot;,&quot;receiver&quot;,&quot;toName&quot;,&quot;to&quot;,&quot;receiverDisplayName&quot;,&quot;receiver_display_name&quot;))&#10;&#10;                                    val msg = Message(&#10;                                        id = idVal,&#10;                                        senderID = senderVal ?: -1L,&#10;                                        receiverID = receiverVal ?: -1L,&#10;                                        message = messageText ?: &quot;&quot;,&#10;                                        timestamp = created,&#10;                                        conversationID = conv,&#10;                                        senderName = senderName,&#10;                                        receiverName = receiverName&#10;                                    )&#10;                                    built.add(msg)&#10;                                } else {&#10;                                    // not an object: attempt to parse with Gson fallback&#10;                                    try {&#10;                                        val parsed = gson.fromJson(elem, Message::class.java)&#10;                                        if (parsed != null) built.add(parsed)&#10;                                    } catch (_: Exception) {&#10;                                        // ignore&#10;                                    }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                // ignore element-level errors&#10;                            }&#10;                        }&#10;&#10;                        _messages.postValue(built)&#10;                        return@launch&#10;                    }&#10;&#10;                    // Single object heuristics&#10;                    if (je.isJsonObject) {&#10;                        val obj = je.asJsonObject&#10;                        if (obj.has(&quot;senderID&quot;) || obj.has(&quot;message&quot;) || obj.has(&quot;id&quot;) || obj.has(&quot;conversationID&quot;)) {&#10;                            val single = try { gson.fromJson(obj, Message::class.java) } catch (e: Exception) { null }&#10;                            if (single != null) {&#10;                                _messages.postValue(listOf(single))&#10;                                return@launch&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Final fallback: try parse the body as List&lt;Message&gt;&#10;                    try {&#10;                        val messagesArray = try { gson.fromJson(bodyStr, Array&lt;Message&gt;::class.java) } catch (e: Exception) { null }&#10;                        if (messagesArray != null) {&#10;                            _messages.postValue(messagesArray.toList())&#10;                            return@launch&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed to parse body as messages array&quot;)&#10;                        val emsg = e.message ?: &quot;&lt;null&gt;&quot;&#10;                        if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                            Log.d(TAG, &quot;Exception while parsing list: &quot; + emsg)&#10;                            Log.d(TAG, &quot;Raw response (full): &quot; + (bodyStr ?: &quot;&lt;empty&gt;&quot;))&#10;                        }&#10;                        _messages.postValue(emptyList())&#10;                        return@launch&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Failed to parse messages JSON&quot;)&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                        Log.d(TAG, &quot;Exception while parsing messages JSON: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                        Log.d(TAG, &quot;Raw response (full): &quot; + (bodyStr ?: &quot;&lt;empty&gt;&quot;))&#10;                    }&#10;                    _error.postValue(&quot;Failed to parse messages: &quot; + (e.message ?: &quot;&quot;))&#10;                    return@launch&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _error.postValue(e.message)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(receiverID: Long, text: String, conversationID: String? = null) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val req = SendMessageRequest(receiverID = receiverID, message = text, conversationID = conversationID)&#10;                // Debug: outgoing JSON&#10;                try {&#10;                    val gson = Gson()&#10;                    val outJson = gson.toJson(req)&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                        Log.d(TAG, &quot;sendMessage request JSON: $outJson&quot;)&#10;                    }&#10;                    _debug.postValue(&quot;Outgoing request:\n$outJson&quot;)&#10;                } catch (e: Exception) {}&#10;&#10;                // Primary send&#10;                // The project's ApiService exposes `sendMessageRaw` which accepts a Map payload.&#10;                // Build a raw payload map from the request and use that for the primary send.&#10;                val rawPayload = mutableMapOf&lt;String, Any&gt;(&quot;message&quot; to text, &quot;receiverID&quot; to receiverID)&#10;                conversationID?.let { rawPayload[&quot;conversationID&quot;] = it }&#10;                val resp = apiService.sendMessageRaw(rawPayload)&#10;                if (resp.isSuccessful) {&#10;                    val bodyStr = try { resp.body()?.string() } catch (e: Exception) { null }&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                        Log.d(TAG, &quot;sendMessage response raw: ${bodyStr?.take(2000)}&quot;)&#10;                    }&#10;                    if (!bodyStr.isNullOrBlank()) {&#10;                         try {&#10;                             val gson = Gson()&#10;                             val je = JsonParser.parseString(bodyStr)&#10;                             var parsedMessage: Message? = null&#10;                             if (je.isJsonObject) {&#10;                                 val obj = je.asJsonObject&#10;                                 if (obj.has(&quot;data&quot;)) {&#10;                                     try { parsedMessage = gson.fromJson(obj.get(&quot;data&quot;), Message::class.java) } catch (e: Exception) {}&#10;                                 }&#10;                                 if (parsedMessage == null) {&#10;                                     try { parsedMessage = gson.fromJson(obj, Message::class.java) } catch (e: Exception) {}&#10;                                 }&#10;                             } else if (je.isJsonArray) {&#10;                                 try {&#10;                                     val arr = je.asJsonArray&#10;                                     if (arr.size() &gt; 0) parsedMessage = gson.fromJson(arr[0], Message::class.java)&#10;                                 } catch (e: Exception) {}&#10;                             }&#10;&#10;                             if (parsedMessage != null) {&#10;                                 val current = _messages.value?.toMutableList() ?: mutableListOf()&#10;                                 current.add(parsedMessage)&#10;                                 _messages.postValue(current)&#10;                                 _debug.postValue(&quot;Sent OK. Created message id=${parsedMessage.id}&quot;)&#10;                                 // refresh authoritative state&#10;                                 loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                             } else {&#10;                                 // fallback: refresh conversation to pull the message&#10;                                 _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nWarning: couldn't parse created message from server response&quot;)&#10;                                 loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                             }&#10;                         } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;Failed to parse sendMessage response: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                             _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nFailed to parse send response: &quot; + (e.message ?: &quot;&quot;))&#10;                             loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                         }&#10;                     } else {&#10;                         // empty body, refresh&#10;                         loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                     }&#10;                 } else {&#10;                     // Non-successful primary response&#10;                     val errBody = try { resp.errorBody()?.string() } catch (e: Exception) { null }&#10;                     Log.e(TAG, &quot;sendMessage failed with HTTP ${resp.code()} body=${errBody}&quot;)&#10;                     val errShort = errBody ?: &quot;&lt;no body&gt;&quot;&#10;                     _debug.postValue(&quot;Server error: HTTP ${resp.code()}\n$errShort&quot;)&#10;&#10;                     if (resp.code() == 422) {&#10;                         // validation: try a raw retry with camelCase keys&#10;                         val rawMap = mutableMapOf&lt;String, Any&gt;(&quot;message&quot; to text, &quot;receiverID&quot; to receiverID)&#10;                         conversationID?.let { rawMap[&quot;conversationID&quot;] = it }&#10;                        if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                             Log.d(TAG, &quot;Attempting raw send retry with body: $rawMap&quot;)&#10;                         }&#10;                         _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nRetrying with raw body: $rawMap&quot;)&#10;&#10;                         try {&#10;                             val retryResp = apiService.sendMessageRaw(rawMap)&#10;                             if (retryResp.isSuccessful) {&#10;                                val bodyStr = try { retryResp.body()?.string() } catch (e: Exception) { null }&#10;                                if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                                    Log.d(TAG, &quot;retry raw response: ${bodyStr?.take(2000)}&quot;)&#10;                                }&#10;                                 _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nRetry response: &quot; + (bodyStr ?: &quot;&lt;empty&gt;&quot;))&#10;&#10;                                 if (!bodyStr.isNullOrBlank()) {&#10;                                     try {&#10;                                         val gson = Gson()&#10;                                         val je = JsonParser.parseString(bodyStr)&#10;                                         var maybe: Message? = null&#10;                                         if (je.isJsonObject) {&#10;                                             val obj = je.asJsonObject&#10;                                             if (obj.has(&quot;data&quot;)) {&#10;                                                 try { maybe = gson.fromJson(obj.get(&quot;data&quot;), Message::class.java) } catch (e: Exception) {}&#10;                                             }&#10;                                             if (maybe == null) {&#10;                                                 try { maybe = gson.fromJson(obj, Message::class.java) } catch (e: Exception) {}&#10;                                             }&#10;                                         } else if (je.isJsonArray) {&#10;                                             try { val arr = je.asJsonArray; if (arr.size() &gt; 0) maybe = gson.fromJson(arr[0], Message::class.java) } catch (e: Exception) {}&#10;                                         }&#10;&#10;                                         if (maybe != null) {&#10;                                             val current = _messages.value?.toMutableList() ?: mutableListOf()&#10;                                             current.add(maybe)&#10;                                             _messages.postValue(current)&#10;                                             _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nRetry parsed message id=${maybe.id}&quot;)&#10;                                             loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                                             return@launch&#10;                                         } else {&#10;                                             // couldn't parse but HTTP OK: refresh&#10;                                             loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                                         }&#10;                                     } catch (e: Exception) {&#10;                                         Log.e(TAG, &quot;retry parse exception&quot;, e)&#10;                                         // fallthrough to error handling below&#10;                                     }&#10;                                 } else {&#10;                                     // empty retry body: refresh&#10;                                     loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                                 }&#10;                             } else {&#10;                                val retryErr = try { retryResp.errorBody()?.string() } catch (e: Exception) { null }&#10;                                Log.e(TAG, &quot;raw retry failed HTTP ${retryResp.code()} body=${retryErr}&quot;)&#10;                                 val userVisible = buildString {&#10;                                     append(&quot;Failed to send message: ${resp.code()}&quot;)&#10;                                     if (!errBody.isNullOrBlank()) {&#10;                                         append(&quot; - &quot;)&#10;                                         append(if (errBody.length &gt; 1000) errBody.take(1000) + &quot;...&quot; else errBody)&#10;                                     }&#10;                                     if (!retryErr.isNullOrBlank()) {&#10;                                         append(&quot; | Retry: &quot;)&#10;                                         append(if (retryErr.length &gt; 1000) retryErr.take(1000) + &quot;...&quot; else retryErr)&#10;                                     }&#10;                                 }&#10;                                 _error.postValue(userVisible)&#10;                                 val retryErrShort = retryErr ?: &quot;&lt;no body&gt;&quot;&#10;                                 _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nRetry failed: $retryErrShort&quot;)&#10;                                 return@launch&#10;                             }&#10;                         } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;raw retry exception: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                             _error.postValue(errBody ?: e.message ?: &quot;Failed to send message&quot;)&#10;                             _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nRetry exception: &quot; + (e.message ?: &quot;&quot;))&#10;                             return@launch&#10;                         }&#10;                     } else {&#10;                         // For 500/internal errors, show server status and let maintainer fix it&#10;                         _error.postValue(&quot;Server returned HTTP ${resp.code()}&quot;)&#10;                         return@launch&#10;                     }&#10;                 }&#10;             } catch (e: Exception) {&#10;                Log.e(TAG, &quot;sendMessage exception: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                 _error.postValue(e.message)&#10;                 _debug.postValue((_debug.value ?: &quot;&quot;) + &quot;\nException: &quot; + (e.message ?: &quot;&quot;))&#10;             }&#10;         }&#10;     }&#10; }&#10;" />
              <option name="updatedContent" value="package com.example.capstone2.viewmodel&#10;&#10;import androidx.lifecycle.*&#10;import com.example.capstone2.data.api.ApiService&#10;import com.example.capstone2.data.models.Message&#10;import com.example.capstone2.data.models.SendMessageRequest&#10;import kotlinx.coroutines.launch&#10;import com.google.gson.Gson&#10;import com.google.gson.JsonElement&#10;import com.google.gson.JsonParser&#10;import com.google.gson.reflect.TypeToken&#10;import android.util.Log&#10;&#10;class ChatViewModel(private val apiService: ApiService, private val currentUserId: Long) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ChatViewModel&quot;&#10;    }&#10;&#10;    private val _messages = MutableLiveData&lt;List&lt;Message&gt;&gt;(emptyList())&#10;    val messages: LiveData&lt;List&lt;Message&gt;&gt; = _messages&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;(null)&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    fun loadConversation(conversationID: String? = null, otherUserID: Long? = null) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val resp = apiService.getConversation(conversationID = conversationID, otherUserID = otherUserID)&#10;&#10;                // Read both body and errorBody (reading them may consume them)&#10;                val responseBodyStr = try { resp.body()?.string() } catch (e: Exception) { null }&#10;                val responseErrStr = try { resp.errorBody()?.string() } catch (e: Exception) { null }&#10;                val respBodyShort = responseBodyStr ?: &quot;&lt;empty&gt;&quot;&#10;                val respErrShort = responseErrStr ?: &quot;&lt;none&gt;&quot;&#10;                if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                    Log.d(TAG, &quot;getConversation raw response: ${responseBodyStr?.take(4000)}&quot;)&#10;                }&#10;&#10;                if (!resp.isSuccessful) {&#10;                    _error.postValue(&quot;Failed to load conversation: ${resp.code()}&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val bodyStr = responseBodyStr&#10;                val bodyShort = bodyStr ?: &quot;&lt;empty&gt;&quot;&#10;                if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                    Log.d(TAG, &quot;getConversation raw response: ${bodyStr?.take(4000)}&quot;)&#10;                }&#10;&#10;                if (bodyStr.isNullOrBlank()) {&#10;                    _messages.postValue(emptyList())&#10;                    return@launch&#10;                }&#10;&#10;                try {&#10;                    val gson = Gson()&#10;                    val je = JsonParser.parseString(bodyStr)&#10;&#10;                    // Helper: recursively find first array element in a JSON tree&#10;                    fun findFirstArray(elem: JsonElement): JsonElement? {&#10;                        if (elem == null) return null&#10;                        if (elem.isJsonArray) return elem&#10;                        if (elem.isJsonObject) {&#10;                            val obj = elem.asJsonObject&#10;                            val keys = listOf(&quot;messages&quot;, &quot;data&quot;, &quot;results&quot;, &quot;items&quot;, &quot;conversation&quot;, &quot;body&quot;)&#10;                            for (k in keys) {&#10;                                if (obj.has(k)) {&#10;                                    val child = obj.get(k)&#10;                                    if (child.isJsonArray) return child&#10;                                    val nested = findFirstArray(child)&#10;                                    if (nested != null) return nested&#10;                                }&#10;                            }&#10;                            val it = obj.entrySet().iterator()&#10;                            while (it.hasNext()) {&#10;                                val entry = it.next()&#10;                                val found = findFirstArray(entry.value)&#10;                                if (found != null) return found&#10;                            }&#10;                        }&#10;                        return null&#10;                    }&#10;&#10;                    // Helper extractors (block-bodied so `return` is permitted inside)&#10;                    fun JsonElement.asSafeString(): String? {&#10;                        return try {&#10;                            if (this.isJsonNull) null else this.asString&#10;                        } catch (e: Exception) {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    fun JsonElement.asSafeLong(): Long? {&#10;                        return try {&#10;                            if (this.isJsonNull) return null&#10;                            val p = this.asJsonPrimitive&#10;                            if (p.isNumber) return p.asLong&#10;                            p.asString.toLongOrNull()&#10;                        } catch (e: Exception) {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    // Helpers to extract string/long candidates from a JSON object&#10;                    fun getStringFromObj(obj: com.google.gson.JsonObject, candidates: List&lt;String&gt;): String? {&#10;                        for (k in candidates) {&#10;                            if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                try {&#10;                                    val v = obj.get(k)&#10;                                    val s = v.asSafeString()&#10;                                    if (!s.isNullOrBlank()) return s&#10;                                } catch (_: Exception) { }&#10;                            }&#10;                        }&#10;                        return null&#10;                    }&#10;&#10;                    fun getLongFromObj(obj: com.google.gson.JsonObject, candidates: List&lt;String&gt;): Long? {&#10;                        for (k in candidates) {&#10;                            if (obj.has(k) &amp;&amp; !obj.get(k).isJsonNull) {&#10;                                try {&#10;                                    val v = obj.get(k)&#10;                                    val l = v.asSafeLong()&#10;                                    if (l != null) return l&#10;                                } catch (_: Exception) { }&#10;                            }&#10;                        }&#10;                        return null&#10;                    }&#10;&#10;                    // Helper: parse timestamp string to epoch millis (tries plain long, ISO instant, and common formats)&#10;                    fun parseTimeToMillis(t: String?): Long? {&#10;                        if (t == null) return null&#10;                        try {&#10;                            val asLong = t.toLongOrNull()&#10;                            if (asLong != null) return if (asLong &lt; 1000000000000L) asLong * 1000L else asLong&#10;                        } catch (_: Exception) { }&#10;                        try { return java.time.Instant.parse(t).toEpochMilli() } catch (_: Exception) { }&#10;                        try {&#10;                            val fmt = java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;                            val ldt = java.time.LocalDateTime.parse(t, fmt)&#10;                            return ldt.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()&#10;                        } catch (_: Exception) { }&#10;                        return null&#10;                    }&#10;&#10;                    // Parse array case&#10;                    val firstArray = findFirstArray(je)&#10;                    if (firstArray != null &amp;&amp; firstArray.isJsonArray) {&#10;                        val arr = firstArray.asJsonArray&#10;                        val built = mutableListOf&lt;Message&gt;()&#10;&#10;                        for (i in 0 until arr.size()) {&#10;                            val elem = arr[i]&#10;                            try {&#10;                                if (elem.isJsonObject) {&#10;                                    val obj = elem.asJsonObject&#10;                                    val messageText = getStringFromObj(obj, listOf(&quot;message&quot;,&quot;body&quot;,&quot;text&quot;,&quot;content&quot;,&quot;messageText&quot;,&quot;msg&quot;,&quot;message_body&quot;))&#10;                                    val idVal = getLongFromObj(obj, listOf(&quot;messageID&quot;,&quot;id&quot;,&quot;msg_id&quot;))&#10;                                    val senderVal = getLongFromObj(obj, listOf(&quot;senderID&quot;,&quot;senderId&quot;,&quot;from&quot;,&quot;userID&quot;,&quot;userId&quot;))&#10;                                    val receiverVal = getLongFromObj(obj, listOf(&quot;receiverID&quot;,&quot;receiverId&quot;,&quot;to&quot;))&#10;                                    val created = getStringFromObj(obj, listOf(&quot;createdAt&quot;,&quot;timestamp&quot;,&quot;time&quot;,&quot;created_at&quot;))&#10;                                    val conv = getStringFromObj(obj, listOf(&quot;conversationID&quot;,&quot;conversationId&quot;,&quot;conversation&quot;))&#10;                                    val senderName = getStringFromObj(obj, listOf(&quot;senderName&quot;,&quot;sender_name&quot;,&quot;name&quot;,&quot;displayName&quot;,&quot;display_name&quot;))&#10;                                    val receiverName = getStringFromObj(obj, listOf(&quot;receiverName&quot;,&quot;receiver_name&quot;,&quot;receiver&quot;,&quot;toName&quot;,&quot;to&quot;,&quot;receiverDisplayName&quot;,&quot;receiver_display_name&quot;))&#10;&#10;                                    val msg = Message(&#10;                                        id = idVal,&#10;                                        senderID = senderVal ?: -1L,&#10;                                        receiverID = receiverVal ?: -1L,&#10;                                        message = messageText ?: &quot;&quot;,&#10;                                        timestamp = created,&#10;                                        conversationID = conv,&#10;                                        senderName = senderName,&#10;                                        receiverName = receiverName&#10;                                    )&#10;                                    built.add(msg)&#10;                                } else {&#10;                                    // not an object: attempt to parse with Gson fallback&#10;                                    try {&#10;                                        val parsed = gson.fromJson(elem, Message::class.java)&#10;                                        if (parsed != null) built.add(parsed)&#10;                                    } catch (_: Exception) {&#10;                                        // ignore&#10;                                    }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                // ignore element-level errors&#10;                            }&#10;                        }&#10;&#10;                        // Sort messages oldest-first (so newest is last) by parsed timestamp when possible&#10;                        try {&#10;                            built.sortBy { parseTimeToMillis(it.timestamp) ?: Long.MAX_VALUE }&#10;                        } catch (_: Exception) { }&#10;&#10;                        _messages.postValue(built)&#10;                        return@launch&#10;                    }&#10;&#10;                    // Single object heuristics&#10;                    if (je.isJsonObject) {&#10;                        val obj = je.asJsonObject&#10;                        if (obj.has(&quot;senderID&quot;) || obj.has(&quot;message&quot;) || obj.has(&quot;id&quot;) || obj.has(&quot;conversationID&quot;)) {&#10;                            val single = try { gson.fromJson(obj, Message::class.java) } catch (e: Exception) { null }&#10;                            if (single != null) {&#10;                                _messages.postValue(listOf(single))&#10;                                return@launch&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Final fallback: try parse the body as List&lt;Message&gt;&#10;                    try {&#10;                        val messagesArray = try { gson.fromJson(bodyStr, Array&lt;Message&gt;::class.java) } catch (e: Exception) { null }&#10;                        if (messagesArray != null) {&#10;                            // Ensure oldest-first ordering&#10;                            val list = messagesArray.toMutableList()&#10;                            try { list.sortBy { parseTimeToMillis(it.timestamp) ?: Long.MAX_VALUE } } catch (_: Exception) {}&#10;                            _messages.postValue(list)&#10;                            return@launch&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed to parse body as messages array&quot;)&#10;                        val emsg = e.message ?: &quot;&lt;null&gt;&quot;&#10;                        if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                            Log.d(TAG, &quot;Exception while parsing list: &quot; + emsg)&#10;                            Log.d(TAG, &quot;Raw response (full): &quot; + (bodyStr ?: &quot;&lt;empty&gt;&quot;))&#10;                        }&#10;                        _messages.postValue(emptyList())&#10;                        return@launch&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Failed to parse messages JSON&quot;)&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                        Log.d(TAG, &quot;Exception while parsing messages JSON: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                        Log.d(TAG, &quot;Raw response (full): &quot; + (bodyStr ?: &quot;&lt;empty&gt;&quot;))&#10;                    }&#10;                    _error.postValue(&quot;Failed to parse messages: &quot; + (e.message ?: &quot;&quot;))&#10;                    return@launch&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _error.postValue(e.message)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(receiverID: Long, text: String, conversationID: String? = null) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val req = SendMessageRequest(receiverID = receiverID, message = text, conversationID = conversationID)&#10;                // Debug: outgoing JSON&#10;                try {&#10;                    val gson = Gson()&#10;                    val outJson = gson.toJson(req)&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                        Log.d(TAG, &quot;sendMessage request JSON: $outJson&quot;)&#10;                    }&#10;                } catch (e: Exception) {}&#10;&#10;                // Primary send&#10;                // The project's ApiService exposes `sendMessageRaw` which accepts a Map payload.&#10;                // Build a raw payload map from the request and use that for the primary send.&#10;                val rawPayload = mutableMapOf&lt;String, Any&gt;(&quot;message&quot; to text, &quot;receiverID&quot; to receiverID)&#10;                conversationID?.let { rawPayload[&quot;conversationID&quot;] = it }&#10;                val resp = apiService.sendMessageRaw(rawPayload)&#10;                if (resp.isSuccessful) {&#10;                    val bodyStr = try { resp.body()?.string() } catch (e: Exception) { null }&#10;                    if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                        Log.d(TAG, &quot;sendMessage response raw: ${bodyStr?.take(2000)}&quot;)&#10;                    }&#10;                    if (!bodyStr.isNullOrBlank()) {&#10;                         try {&#10;                             val gson = Gson()&#10;                             val je = JsonParser.parseString(bodyStr)&#10;                             var parsedMessage: Message? = null&#10;                             if (je.isJsonObject) {&#10;                                 val obj = je.asJsonObject&#10;                                 if (obj.has(&quot;data&quot;)) {&#10;                                     try { parsedMessage = gson.fromJson(obj.get(&quot;data&quot;), Message::class.java) } catch (e: Exception) {}&#10;                                 }&#10;                                 if (parsedMessage == null) {&#10;                                     try { parsedMessage = gson.fromJson(obj, Message::class.java) } catch (e: Exception) {}&#10;                                 }&#10;                             } else if (je.isJsonArray) {&#10;                                 try {&#10;                                     val arr = je.asJsonArray&#10;                                     if (arr.size() &gt; 0) parsedMessage = gson.fromJson(arr[0], Message::class.java)&#10;                                 } catch (e: Exception) {}&#10;                             }&#10;&#10;                             if (parsedMessage != null) {&#10;                                 val current = _messages.value?.toMutableList() ?: mutableListOf()&#10;                                 current.add(parsedMessage)&#10;                                 _messages.postValue(current)&#10;                                 // refresh authoritative state&#10;                                 loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                             } else {&#10;                                 // fallback: refresh conversation to pull the message&#10;                                 loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                             }&#10;                         } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;Failed to parse sendMessage response: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                             loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                         }&#10;                     } else {&#10;                         // empty body, refresh&#10;                         loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                     }&#10;                 } else {&#10;                     // Non-successful primary response&#10;                     val errBody = try { resp.errorBody()?.string() } catch (e: Exception) { null }&#10;                     Log.e(TAG, &quot;sendMessage failed with HTTP ${resp.code()} body=${errBody}&quot;)&#10;&#10;                     if (resp.code() == 422) {&#10;                         // validation: try a raw retry with camelCase keys&#10;                         val rawMap = mutableMapOf&lt;String, Any&gt;(&quot;message&quot; to text, &quot;receiverID&quot; to receiverID)&#10;                         conversationID?.let { rawMap[&quot;conversationID&quot;] = it }&#10;                        if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                             Log.d(TAG, &quot;Attempting raw send retry with body: $rawMap&quot;)&#10;                         }&#10;&#10;                         try {&#10;                             val retryResp = apiService.sendMessageRaw(rawMap)&#10;                             if (retryResp.isSuccessful) {&#10;                                val bodyStr = try { retryResp.body()?.string() } catch (e: Exception) { null }&#10;                                if (Log.isLoggable(TAG, Log.DEBUG)) {&#10;                                    Log.d(TAG, &quot;retry raw response: ${bodyStr?.take(2000)}&quot;)&#10;                                }&#10;&#10;                                 if (!bodyStr.isNullOrBlank()) {&#10;                                     try {&#10;                                         val gson = Gson()&#10;                                         val je = JsonParser.parseString(bodyStr)&#10;                                         var maybe: Message? = null&#10;                                         if (je.isJsonObject) {&#10;                                             val obj = je.asJsonObject&#10;                                             if (obj.has(&quot;data&quot;)) {&#10;                                                 try { maybe = gson.fromJson(obj.get(&quot;data&quot;), Message::class.java) } catch (e: Exception) {}&#10;                                             }&#10;                                             if (maybe == null) {&#10;                                                 try { maybe = gson.fromJson(obj, Message::class.java) } catch (e: Exception) {}&#10;                                             }&#10;                                         } else if (je.isJsonArray) {&#10;                                             try { val arr = je.asJsonArray; if (arr.size() &gt; 0) maybe = gson.fromJson(arr[0], Message::class.java) } catch (e: Exception) {}&#10;                                         }&#10;&#10;                                         if (maybe != null) {&#10;                                             val current = _messages.value?.toMutableList() ?: mutableListOf()&#10;                                             current.add(maybe)&#10;                                             _messages.postValue(current)&#10;                                             loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                                             return@launch&#10;                                         } else {&#10;                                             // couldn't parse but HTTP OK: refresh&#10;                                             loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                                         }&#10;                                     } catch (e: Exception) {&#10;                                         Log.e(TAG, &quot;retry parse exception&quot;, e)&#10;                                         // fallthrough to error handling below&#10;                                     }&#10;                                 } else {&#10;                                     // empty retry body: refresh&#10;                                     loadConversation(conversationID = conversationID, otherUserID = receiverID)&#10;                                 }&#10;                             } else {&#10;                                val retryErr = try { retryResp.errorBody()?.string() } catch (e: Exception) { null }&#10;                                Log.e(TAG, &quot;raw retry failed HTTP ${retryResp.code()} body=${retryErr}&quot;)&#10;                                 val userVisible = buildString {&#10;                                     append(&quot;Failed to send message: ${resp.code()}&quot;)&#10;                                     if (!errBody.isNullOrBlank()) {&#10;                                         append(&quot; - &quot;)&#10;                                         append(if (errBody.length &gt; 1000) errBody.take(1000) + &quot;...&quot; else errBody)&#10;                                     }&#10;                                     if (!retryErr.isNullOrBlank()) {&#10;                                         append(&quot; | Retry: &quot;)&#10;                                         append(if (retryErr.length &gt; 1000) retryErr.take(1000) + &quot;...&quot; else retryErr)&#10;                                     }&#10;                                 }&#10;                                 _error.postValue(userVisible)&#10;                                 return@launch&#10;                             }&#10;                         } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;raw retry exception: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                             _error.postValue(errBody ?: e.message ?: &quot;Failed to send message&quot;)&#10;                             return@launch&#10;                         }&#10;                     } else {&#10;                         // For 500/internal errors, show server status and let maintainer fix it&#10;                         _error.postValue(&quot;Server returned HTTP ${resp.code()}&quot;)&#10;                         return@launch&#10;                     }&#10;                 }&#10;             } catch (e: Exception) {&#10;                Log.e(TAG, &quot;sendMessage exception: &quot; + (e.message ?: &quot;&lt;null&gt;&quot;))&#10;                 _error.postValue(e.message)&#10;             }&#10;         }&#10;     }&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_messages.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:padding=&quot;8dp&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvConversations&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:paddingBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvEmpty&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:text=&quot;No conversations&quot;&#10;        android:visibility=&quot;gone&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_conversation.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_conversation.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;12dp&quot;&gt;&#10;&#10;    &lt;!-- Row: Partner name (left) and time (right) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvPartner&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;@string/partner_name&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:maxLines=&quot;1&quot;&#10;            android:ellipsize=&quot;end&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvTime&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:textColor=&quot;#757575&quot;&#10;            android:paddingStart=&quot;8dp&quot;&#10;            android:paddingEnd=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Row: Last message preview (left) and unread badge (right) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:layout_marginTop=&quot;4dp&quot;&#10;        android:gravity=&quot;center_vertical&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvLastMessage&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:textColor=&quot;#757575&quot;&#10;            android:maxLines=&quot;1&quot;&#10;            android:ellipsize=&quot;end&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvUnread&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginStart=&quot;8dp&quot;&#10;            android:paddingStart=&quot;8dp&quot;&#10;            android:paddingEnd=&quot;8dp&quot;&#10;            android:paddingTop=&quot;2dp&quot;&#10;            android:paddingBottom=&quot;2dp&quot;&#10;            android:background=&quot;@android:drawable/btn_default_small&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:visibility=&quot;gone&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;12dp&quot;&gt;&#10;&#10;    &lt;!-- Row: Partner name (left) and time (right) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvPartner&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;@string/partner_name&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:maxLines=&quot;1&quot;&#10;            android:ellipsize=&quot;end&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvTime&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:textColor=&quot;#757575&quot;&#10;            android:paddingStart=&quot;8dp&quot;&#10;            android:paddingEnd=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Row: Last message preview (left) and unread badge (right) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:layout_marginTop=&quot;4dp&quot;&#10;        android:gravity=&quot;center_vertical&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvLastMessage&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:textColor=&quot;@color/text_primary&quot;&#10;            android:maxLines=&quot;1&quot;&#10;            android:ellipsize=&quot;end&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvUnread&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginStart=&quot;8dp&quot;&#10;            android:paddingStart=&quot;8dp&quot;&#10;            android:paddingEnd=&quot;8dp&quot;&#10;            android:paddingTop=&quot;2dp&quot;&#10;            android:paddingBottom=&quot;2dp&quot;&#10;            android:background=&quot;@android:drawable/btn_default_small&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:visibility=&quot;gone&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>